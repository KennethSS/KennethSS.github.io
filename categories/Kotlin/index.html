<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>Category: Kotlin - 케니스의 개발 블로그</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="케니스의 개발 블로그"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="케니스의 개발 블로그"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="케니스의 개발 블로그"><meta property="og:url" content="http://example.com/"><meta property="og:site_name" content="케니스의 개발 블로그"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:author" content="John Doe"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"케니스의 개발 블로그","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"John Doe"},"publisher":{"@type":"Organization","name":"케니스의 개발 블로그","logo":{"@type":"ImageObject","url":"http://example.com/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="케니스의 개발 블로그" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/KennethSS"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-9-tablet is-9-desktop is-9-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">Categories</a></li><li class="is-active"><a href="#" aria-current="page">Kotlin</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-01-30T09:11:03.000Z" title="2023. 1. 30. 오후 6:11:03">2023-01-30</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-01-30T09:11:50.601Z" title="2023. 1. 30. 오후 6:11:50">2023-01-30</time></span><span class="level-item"><a class="link-muted" href="/categories/Kotlin/">Kotlin</a></span><span class="level-item">11 minutes read (About 1668 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/01/30/Kotlin-%EB%B6%88%EB%B3%80%EC%84%B1-Immutability-%EA%B3%BC-%EA%B0%80%EB%B3%80%EC%84%B1-Mutability/">Kotlin - 불변성(Immutability)과 가변성(Mutability)</a></h1><div class="content"><h2 id="불변성-Immutability-과-가변성-Mutability"><a href="#불변성-Immutability-과-가변성-Mutability" class="headerlink" title="불변성(Immutability)과 가변성(Mutability)"></a>불변성(Immutability)과 가변성(Mutability)</h2><h3 id="불변성이란-무엇일까"><a href="#불변성이란-무엇일까" class="headerlink" title="불변성이란 무엇일까?"></a>불변성이란 무엇일까?</h3><p>함수형 프로그래밍에서는 불변성을 중요하게 생각합니다. 코틀린은 함수형 프로그래밍을 지원하는 언어로 불변성을 강제하지않고 가변을 허용하지만 불변성을 권장하고 있습니다. </p>
<p>불변성(Immutability)이란 함수형 프로그램에서 중요하게 다루는 부분으로 보통의 의미는 <strong>상태를 변경하지 않는 것</strong>으로 정의됩니다.</p>
<p>그렇다면 상태를 변경하는 것은 프로그램의 변수를 변경하거나 재할당하는 행위라고 볼 수 있지만 더 근본적으로는 컴퓨터에 저장된 메모리의 특정 공간에 저장된 값을 변경하는 행위를 의미합니다. 이런 행위는 어떤 문제가 생기길래 코틀린에서 불변성을 권장할까요?</p>
</br>

<h3 id="가변성-Mutability-의-문제"><a href="#가변성-Mutability-의-문제" class="headerlink" title="가변성(Mutability)의 문제"></a>가변성(Mutability)의 문제</h3><p>불변성과 반대로 가변성은 상태를 가지는 경우를 얘기합니다. 만약 상태를 가지면 어떤 문제점들이 발생할까요? </p>
<p>앞서 상태를 변경하는 행위는 메모리의 저장된 값을 변경하는 행위라고 언급했습니다. 이렇게 메모리에 저장된 하나의 값을 누구든지 변경할 수 있다는 것은 무분별한 상태가 변경이 된다는 것을 의미합니다. 무분별한 상태가 변경이 되는 것은 다음과 같은 문제를 발생 시킬 수 있습니다.</p>
<ul>
<li>멀티스레드에서 값을 보장하지 못함</li>
<li>값의 예측이 어렵고 변경에 있어서 위험하다</li>
<li>테스트와 디버깅이 어려움</li>
<li>상태 변경 발생 시 처리를 해주어야함</li>
</ul>
</br>

<h3 id="불변성-Immutability-을-지켜야-하는-이유"><a href="#불변성-Immutability-을-지켜야-하는-이유" class="headerlink" title="불변성(Immutability)을 지켜야 하는 이유"></a>불변성(Immutability)을 지켜야 하는 이유</h3><p>불변성이란 값이나 상태를 변경할 수 없는 것으로 정의됩니다. 불변 객체는 생성 시점 이후 한 번 정의된 상태는 계속 유지하며 변경되지 않으므로 스레드 간 안전성이 보장되며 이를 통해 동기화 문제를 해결할 수 있습니다. 그리고 한 번 생성한 값은 변경되지 않으므로 캐시도 수월합니다. 또한 기존 객체에서 프로퍼티가 변경된 객체를 리턴 받고자 할 때 방어적 복사본을 작성하지 않아도됩니다.</p>
<ul>
<li>스레드 안전성(thread-safe)</li>
<li>캐시가 쉬움</li>
<li>방어적 복사본이나 깊은 복사를 하지 않아도됨</li>
<li>사이드 이펙트를 줄임</li>
</ul>
</br>

<h3 id="Kotlin에서는-가변성을-어떻게-제한하고-있을까"><a href="#Kotlin에서는-가변성을-어떻게-제한하고-있을까" class="headerlink" title="Kotlin에서는 가변성을 어떻게 제한하고 있을까?"></a>Kotlin에서는 가변성을 어떻게 제한하고 있을까?</h3><p>코틀린에서는 크게 3가지로 가변성을 제한하고 있습니다.</p>
<ul>
<li>읽기 전용 프로퍼티 <code>val</code></li>
<li>Mutable 컬렉션과 read-only 컬렉션 구분</li>
<li>data class의 copy()</li>
</ul>
</br>

<h3 id="Kotlin에서-불변-객체-사용과-데이터의-변경"><a href="#Kotlin에서-불변-객체-사용과-데이터의-변경" class="headerlink" title="Kotlin에서 불변 객체 사용과 데이터의 변경"></a>Kotlin에서 불변 객체 사용과 데이터의 변경</h3><p>코틀린에서는 value를 의미하는 읽기 전용 프로퍼티인  <code>val</code> 를 이용해 불변 변수를 사용할 수 있습니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Play</span> &#123;</span><br><span class="line">	<span class="keyword">val</span> count = <span class="number">0</span></span><br><span class="line">  <span class="keyword">val</span> countStr: String = <span class="string">&quot;Count&quot;</span></span><br><span class="line">  	<span class="keyword">get</span>() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;<span class="variable">$field</span> <span class="subst">$&#123;++count&#125;</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">fun</span> <span class="title">addedCount</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Added Count: <span class="variable">$countStr</span>&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// &quot;Added Count: Count 0&quot;</span></span><br><span class="line">	<span class="comment">// &quot;Added Count: Count 1&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>그치만 <code>val</code>는 완전한 불변이아닌 불변성에 가깝습니다. 그 이유는 countStr 변수에 backing field를 사용하여 호출할 때 마다 변경된 값을 리턴할 수 있기 때문입니다. 완전한 불변성으로 강제하는 방법은 <code>const val</code>를 사용하여 컴파일 타임 상수를 가지는 것입니다.</p>
</br>

<p>코틀린에서 불변성의 종류는 <strong>참조 불변성</strong>, <strong>불변 값</strong> 두 가지가 존재합니다. 불변 값은 <code>const val</code>을 통해 제공합니다.</p>
<p>참조 불변성 같은 경우 <code>val</code>를 제공하여 참조가 할당되었을 때 다시 할당할 수 없게 합니다. Collection의 MutableList를 예로 들어본다면 </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> list = mutableListOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">  println(list) <span class="comment">// [1, 2, 3]</span></span><br><span class="line">  list.add(<span class="number">4</span>) </span><br><span class="line">  println(list) <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">val</span> anotherList = mutableListOf(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">  list = anotherList <span class="comment">// 컴파일 에러</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>참조 불변성에 의하면 list는 값이 변경되어야 하지 않아야할텐데 변경이 일어났습니다. 이는 <code>val</code> 속성이 불변 참조를 하므로 실제 List의 인스턴스는 변하지 않았고 MutableList의 내부의 값만 변경되었기 때문에 에러가 발생하지 않습니다.</p>
<p>또한 코틀린은 컬렉션에 대해서 읽기 전용(read-only)와 가변 컬렉션을 엄격하게 구분하고 있습니다. </p>
<ul>
<li>읽기 전용 : Iterable, Collection, List, Set 인터페이스</li>
<li>Mutable : MutableIterable, MutableCollection, MutableSet, MutableList 인터페이스</li>
</ul>
<p>읽기 전용은 내부에서 값을 변경하는 함수들을 제공하지 않습니다. 만약 데이터를 추가, 삭제, 수정하려는 경우에는 <code>toMutableList()</code> 함수를 이용해서 요소들을 변경 가능한 컬렉션으로 변경하여 사용해야합니다. 만약 <code>list as MutableList</code>와 같이 다운캐스팅을 시도 한다면 코틀린에서 정한 읽기전용 규칙을 무시하기 때문에 이러한 행위는 지양해야 합니다.</p>
<p>또한 코틀린에서 컬렉션을 다룰 때  <code>var</code>와 함께 Mutable Collection을 사용하면 두개의 가변 포인트를 모두 동기화 해주어야 하기 때문에 이렇게 사용해서는 안됩니다.</p>
</br>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Fruit</span>(</span><br><span class="line">    <span class="keyword">val</span> name: String,</span><br><span class="line">    <span class="keyword">val</span> price: <span class="built_in">Int</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">val</span> banana = Fruit(<span class="string">&quot;banana&quot;</span>, <span class="number">500</span>)</span><br><span class="line">	<span class="keyword">val</span> strawberry = banana.copy(name = <span class="string">&quot;strawberry&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;banana <span class="subst">$&#123;banana.hashCode()&#125;</span> <span class="variable">$banana</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;strawberry <span class="subst">$&#123;strawberry.hashCode()&#125;</span> <span class="variable">$strawberry</span>&quot;</span>)</span><br><span class="line">    <span class="comment">//banana -337338577 Fruit(name=banana, price=500)</span></span><br><span class="line">    <span class="comment">//strawberry 986991237 Fruit(name=strawberry, price=500)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>data class의 copy를 통해서 기존 객체의 값을 변경하지 않고 프로퍼티를 변경하여 새로운 값을 할당한 객체를 받아 불변성을 유지할 수 있습니다.</p>
</br>

<h3 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h3><p>불변성이 항상 장점만 가진다고 생각하지는 않습니다. 가변을 피하기 위해 새로운 객체를 생성하는 것은 비용 증가로 이어지기 때문에 불필요한 인스턴스화나 잦은 복사는 오버헤드로 이어질 수 도있다고 생각합니다. 하지만 불변성이 가지는 장점들이 가변성의 많은 단점들을 해소하기 때문에 코틀린에서도 불변성을 권장했을겁니다. </p>
<p>긴 글 읽어주셔서 감사합니다. 🙇‍♂️</p>
</br>



<h3 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://readystory.tistory.com/105">Kotlin 코틀린(kotlin)과 불변성(immutability)</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://javabom.tistory.com/120">이펙티브 코틀린 Item1. 가변성을 제한하라</a></p>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-01-28T06:45:16.000Z" title="2023. 1. 28. 오후 3:45:16">2023-01-28</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-01-28T06:45:50.471Z" title="2023. 1. 28. 오후 3:45:50">2023-01-28</time></span><span class="level-item"><a class="link-muted" href="/categories/Kotlin/">Kotlin</a></span><span class="level-item">5 minutes read (About 795 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/01/28/kotlin-default%EA%B0%80-final%EC%9D%B8-%EC%9D%B4%EC%9C%A0/">kotlin default가 final인 이유</a></h1><div class="content"><p>평상시에 코틀린 파일을 디컴파일하면서 final로 선언되어있는 코드를 보면서 의문만 가지고 이유에 대해서 찾아보지 못하다가 이번 기회에 코틀린에서 default가 final인 이유에 대해서 찾아보았습니다.</p>
<p>제가 생각했을 때는 크게 두가지 이유가 있습니다.</p>
</br>

<p><strong>첫번째</strong>는 코틀린은 함수형 프로그래밍에서 아이디어를 얻어왔고 가변을 사용했을 때 발생하는 문제점들을 줄이기 위해 불변을 사용합니다. 그래서 모든 클래스들이 기본값으로 final로 선언되어 있는 이유기도 합니다. </p>
</br>

<p><strong>두번째</strong>는 상속에대한 문제입니다.</p>
</br>

<p>코틀린 <a target="_blank" rel="noopener" href="https://kotlinlang.org/docs/inheritance.html">공식 문서</a>에 상속을 설명하는 부분을 보면 다음과 같은 문구가 있습니다.</p>
<blockquote>
<p>By default, Kotlin classes are final – they can’t be inherited. To make a class inheritable, mark it with the <code>open</code> keyword:</p>
</blockquote>
<p>코틀린 클래스는 기본적으로 final이며 이는 상속이 불가능하게 합니다. 만약 상속이 가능하게 하려면 <code>open</code>키워드를 써야합니다. 라고 설명되어있습니다.</p>
</br>

<p>객체지향 관점에서 상속은 개발자들이 아직까지도 올바르게 사용하지 못하는 실수들을 하곤합니다. 무분별한 상속은 객체지향의 의도나 목적과는 반대로 설계할 가능성이 있습니다. </p>
</br>

<p>스택오버플로에서 <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/49002/prefer-composition-over-inheritance">상속보다 구성을 선호</a>하는 원칙에 대해서 오래전 부터 논의한 내용이 있습니다. 그래서 제가 생각하기에는 코틀린은 클래스에 대해서 기본값을 final로 설정을하고 개발자들이 어떠한 문제를 마주했을 때 이 문제를 해결하기 위해서 상속을 사용하는 것 보다 더 나은 방법으로 문제를 해결할 수 있게 생각해보라는 의미로도 해석해 볼 수 있을 것 같습니다.</p>
</br>

<p>실제 글 작성 기준인 2023년 1월 28일 기준으로 코틀린 discuss의 <a target="_blank" rel="noopener" href="https://discuss.kotlinlang.org/t/classes-final-by-default/166/12">Classes final by default</a> 글에서 178명의 투표로 final이 52%, open이 48%로 비슷한 비율로 투표가 유지되고 있습니다.</p>
<p><img src="https://velog.velcdn.com/images/wlsrhkd4023/post/c842aa1e-0cf7-48b3-9355-c5ea57ea4ada/image.png"></p>
</br>

<p>final 키워드는 프로퍼티 값을 Immutable하게 만들거나 클래스나 메서드를 상속이나 오버라이드 하지 못하게 만드는 특징이 있습니다. 그렇기 때문에 런타임에 다형성을 체크하지 않아 성능상의 약간의 이점을 가져갈 수 도 있습니다.</p>
</br>

<h3 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h3><ul>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/51680006/why-are-kotlin-classes-final-by-default-instead-of-open">Why are Kotlin classes final by default instead of open?</a></li>
<li><a target="_blank" rel="noopener" href="https://cchcc.github.io/blog/Kotlin-%EB%94%94%ED%8F%B4%ED%8A%B8%EA%B0%80-final%EC%9D%B8-%EC%9D%B4%EC%9C%A0/">Kotlin 디폴트가 final인 이유</a></li>
<li><a target="_blank" rel="noopener" href="https://discuss.kotlinlang.org/t/classes-final-by-default/166/2">Kotlin discuss - <strong>Classes final by default</strong></a></li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-01-27T17:45:59.000Z" title="2023. 1. 28. 오전 2:45:59">2023-01-28</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-01-27T17:53:55.347Z" title="2023. 1. 28. 오전 2:53:55">2023-01-28</time></span><span class="level-item"><a class="link-muted" href="/categories/Kotlin/">Kotlin</a></span><span class="level-item">18 minutes read (About 2723 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/01/28/Kotlin-Type-alias%EC%99%80-Inline-class/">Kotlin - Type alias와 Inline class</a></h1><div class="content"><blockquote>
<p>❓ 이 글은 Kotlin 공식 문서를 번역과 함께 추가 첨언한 글입니다.</p>
</blockquote>
<p>alias는 사전상의 의미로 가명, ~라는 가명으로 알려진의 뜻으로 정의되어있습니다.</p>
<p>코틀린에서 Type aliase는 제네릭 타입의 컬렉션 쓸 때 이름이 길게 된다면 짧은 이름으로 줄여서 사용할 수 있게 별명을 지어주는 것을 가능하게 해줍니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> NodeSet = Set&lt;Network.Node&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typealias</span> FileTable&lt;K&gt; = MutableMap&lt;K, MutableList&lt;File&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>또한 고차 함수 형태도 짧은 이름으로 지어서 사용할 수 있습니다</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> MyHandler = (<span class="built_in">Int</span>, String, Any) -&gt; <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typealias</span> Predicate&lt;T&gt; = (T) -&gt; <span class="built_in">Boolean</span></span><br></pre></td></tr></table></figure>

<p>클래스 내부의 Inner class의 정보를 줄일 때도 사용할 수 있습니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">Inner</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">Inner</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typealias</span> AInner = A.Inner</span><br><span class="line"><span class="keyword">typealias</span> BInner = B.Inner</span><br></pre></td></tr></table></figure>

</br>

<p>Type aliases는 새로운 타입을 생성하기 위해 사용하는것이 아니라 기본적인 타입들을 동등하게 이해시키기 위해서 사용합니다. 만약 <code>typealias Predicate&lt;T&gt;</code> 를 추가하고 Predicate<T>를 코드에서 사용한다면 코틀린 컴파일러 (Int) -&gt; Boolean으로 확장합니다.  </p>
<p>따라서 일반적인 함수 유형을 변수 타입에 맞게 전달할 수 있고 그 반대도 마찬가지로 가능합니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> Predicate&lt;T&gt; = (T) -&gt; <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(p: <span class="type">Predicate</span>&lt;<span class="type">Int</span>&gt;)</span></span> = p(<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> f: (<span class="built_in">Int</span>) -&gt; <span class="built_in">Boolean</span> = &#123; it &gt; <span class="number">0</span> &#125;</span><br><span class="line">    println(foo(f)) <span class="comment">// prints &quot;true&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> p: Predicate&lt;<span class="built_in">Int</span>&gt; = &#123; it &gt; <span class="number">0</span> &#125;</span><br><span class="line">    println(listOf(<span class="number">1</span>, -<span class="number">2</span>).filter(p)) <span class="comment">// prints &quot;[1]&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Result</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// [1]</span></span><br></pre></td></tr></table></figure>



<p>Type Alias는 클래스 혹은 함수 내부에서 정의하는 것은 불가능하며 Top level에서 변수로 정의해야 합니다.  Top level에서 선언한 Type alias는 Public이기 때문에 internal로 사용범위를 모듈로 제한한다고 해도 모듈안에서는 누구나 접근 가능하기 때문에 꼭 필요한 곳에 명세하여 사용해야 합니다.</p>
<p>Type alias에 대해서 정리하면</p>
<ul>
<li>유의미한 이름을 정의해서 사용하면 코드의 가독성을 증가시킬 수 있음</li>
<li>반대로 명확하지 않고 명세나 정의되지 않은 typealias는 오히려 사용성을 저하시킬 수 있음</li>
<li>typealias는 Top level에서만 선언이 가능하기 때문에 여러 곳에서 접근이 가능</li>
</ul>
<hr>
<h1 id="Inline-classes"><a href="#Inline-classes" class="headerlink" title="Inline classes"></a>Inline classes</h1><p>Type alias와 같이 언급되는 Inline class가 있습니다. Inline class가 어떤 것인지 살펴보겠습니다.</p>
<p>비즈니스 로직을 작성하기위해 어떤 타입으로 감싸는 Wrapper를 작성하는 경우가 있습니다. 예를 들어 단순히 Price를 표시하기 위해 Int 형태의 Primitive 타입으로 작성할 수도 있지만 도메인을 조금 더 잘 표현하기 위해 의미를 부여하기 위해서 SalePrice 타입으로 표현할 수 있습니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Item</span>(</span><br><span class="line">	<span class="keyword">val</span> salePrice: <span class="built_in">Int</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Item</span>(</span><br><span class="line">	<span class="keyword">val</span> salePrice: SalePrice</span><br><span class="line">)</span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">SalePrice</span>(<span class="keyword">val</span> price: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure>



<p>하지만 SalePrice와 같은 Wrapper는 Heap영역에 할당되면서 런타임 오버헤드가 발생합니다. 만약 Wrapping된 대상이 Primitive 타입이라면 보통 받을 수 있는 런타임에 최적화를 받지 못해 런타임 성능을 더 악화시킵니다.</p>
<p>이 문제를 해결하기 위해 코틀린에서는 특별한 클래스인 인라인 클래스를 제공합니다. 인라인 클래스는 value 기반 클래스 하위의 집합으로 어떠한 식별자를 가지지 않고 값만 보유하고 있습니다.</p>
<p>인라인 클래스는 클래스 이름 앞에  <code>value</code> 한정자를 사용해서 선언할 수 있습니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value <span class="keyword">class</span> <span class="title class_">Password</span>(<span class="keyword">private</span> <span class="keyword">val</span> s: String)</span><br></pre></td></tr></table></figure>

<p>JVM 백엔드에서 인라인 클래스 선언은 <code>value</code> 한정자 위에 <code>@JvmInline</code> 어노테이션을 선언해야합니다.</p>
<blockquote>
<p>:warning: 인라인 클래스의 <code>inline</code> 한정자는 더 이상 사용되지 않습니다.</p>
</blockquote>
<p>인라인 클래스는 생성자에서 초기화된 단일 프로퍼티만 가질 수 있습니다. 인라인 클래스의 인스턴스는 런타임시에 단일 프로퍼티로 변경되어 표시됩니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 실제로 Password 클래스의 인스턴스화는 발생하지 않습니다.</span></span><br><span class="line"><span class="comment">// 런타임에는 &#x27;securePassword&#x27; 는 단순히 String만 가집니다.</span></span><br><span class="line"><span class="keyword">val</span> securePassword = Password(<span class="string">&quot;Don&#x27;t try this in production&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>이게 인라인 클래스의 핵심 기능이며 클래스의 데이터를 <em>inlined</em> 한다는 관점에서 inline 함수를 호출하는 방식과 유사해서 해당 방식에 영감을 받아 인라인 클래스라는 이름이 붙여지게 되었습니다.</p>
<h3 id="Members"><a href="#Members" class="headerlink" title="Members"></a>Members</h3><p>인라인 클래스는 일반적인 클래스의 기능들을 제공합니다. <code>init</code> 블록을 가질 수 있고 프로퍼티와 함수 또한 선언이 가능합니다. 내부 변수는 backing field를 가질 수 있지만 인라인 클래스의 프로퍼티는 backing field를 가질 수 없으며 간단한 연산가능한 프로퍼티로만 가져야합니다(lateinit과 delegated 프로퍼티도 안됨)</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JvmInline</span></span><br><span class="line">value <span class="keyword">class</span> <span class="title class_">Name</span>(<span class="keyword">val</span> s: String) &#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        require(s.length &gt; <span class="number">0</span>) &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> length: <span class="built_in">Int</span></span><br><span class="line">        <span class="keyword">get</span>() = s.length</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">greet</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Hello, <span class="variable">$s</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> name = Name(<span class="string">&quot;Kotlin&quot;</span>)</span><br><span class="line">    name.greet() <span class="comment">// method `greet` is called as a static method</span></span><br><span class="line">    println(name.length) <span class="comment">// property getter is called as a static method</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Inheritance"><a href="#Inheritance" class="headerlink" title="Inheritance"></a>Inheritance</h3><p>인라인 클래스는 인터페이스 상속이 가능하지만 항상 <code>final</code> 이어야 하기 때문에 다른 클래스로 확장하거나 상속할 수 없습니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Printable</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">prettyPrint</span><span class="params">()</span></span>: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JvmInline</span></span><br><span class="line">value <span class="keyword">class</span> <span class="title class_">Name</span>(<span class="keyword">val</span> s: String) : Printable &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">prettyPrint</span><span class="params">()</span></span>: String = <span class="string">&quot;Let&#x27;s <span class="variable">$s</span>!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> name = Name(<span class="string">&quot;Kotlin&quot;</span>)</span><br><span class="line">    println(name.prettyPrint()) <span class="comment">// Still called as a static method</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Representation"><a href="#Representation" class="headerlink" title="Representation"></a>Representation</h3><p>컴파일러는 생성된 코드에서 인라인 클래스의 <em>wrapper</em> 형태를 유지합니다. 따라서 인라인 클래스는 런타임에 Primitive 타입이나 wrapper 모두 표현할 수 있습니다. 이것은 Kotlin의 <code>Int</code> 클래스가 Primitive 타입인 <code>int</code> 나 Wrapper인 <code>Integer</code> 클래스로 표현하는 방법과 같습니다.</p>
<p>코틀린 컴파일러는 성능이 우수하거나 최적화된 코드를 생성하기 위해 wrapper 대신 기본 타입을 선호하지만  wrapper 형태의 유지를 필요할 때도 있습니다. 일반적으로 인라인 클래스는 다른 유형으로 사용될 때마다 자동으로 boxed, unboxed 되기 때문에 기본 값과 wrapper 모두를 참조 동등성을 비교하는 것은 의미가 없습니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">I</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@JvmInline</span></span><br><span class="line">value <span class="keyword">class</span> <span class="title class_">Foo</span>(<span class="keyword">val</span> i: <span class="built_in">Int</span>) : I</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">asInline</span><span class="params">(f: <span class="type">Foo</span>)</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">asGeneric</span><span class="params">(x: <span class="type">T</span>)</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">asInterface</span><span class="params">(i: <span class="type">I</span>)</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">asNullable</span><span class="params">(i: <span class="type">Foo</span>?)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">id</span><span class="params">(x: <span class="type">T</span>)</span></span>: T = x</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> f = Foo(<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">    asInline(f)    <span class="comment">// unboxed: used as Foo itself</span></span><br><span class="line">    asGeneric(f)   <span class="comment">// boxed: used as generic type T</span></span><br><span class="line">    asInterface(f) <span class="comment">// boxed: used as type I</span></span><br><span class="line">    asNullable(f)  <span class="comment">// boxed: used as Foo?, which is different from Foo</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// &#x27;f&#x27;가 먼저 boxed(&#x27;id&#x27;로 전달되는 동안)되고 이후에 unboxed(&#x27;id&#x27;에서 반환될 때)</span></span><br><span class="line">  	<span class="comment">// 결국 &#x27;c&#x27;는 unboxed된(단지 42의 값) f를 가집니다.</span></span><br><span class="line">    <span class="keyword">val</span> c = id(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>인라인 클래스는 제네릭 타입 파라미터를 기본 타입으로 가질 수 있습니다. 아래 케이스에서는 컴파일러가 Any?로 맵하거나 일반적으로 타입 파라미터의 상한하는 경우입니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JvmInline</span></span><br><span class="line">value <span class="keyword">class</span> <span class="title class_">UserId</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">val</span> value: T)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">compute</span><span class="params">(s: <span class="type">UserId</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;&#125; <span class="comment">// compiler generates fun compute-&lt;hashcode&gt;(s: Any?)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>:warning: 제네릭 인라인 클래스는 <a target="_blank" rel="noopener" href="https://kotlinlang.org/docs/components-stability.html">실험</a> 기능입니다. 언제든지 버려질 수 있으며  <code>-language-version 1.8</code> 컴파일러 옵션이 요구됩니다.</p>
</blockquote>
<h3 id="Managling"><a href="#Managling" class="headerlink" title="Managling"></a>Managling</h3><p>인라인 클래스는 Primitive타입으로 컴파일되므로 시그니처 충돌이라든지 예상하지 못한 오류를 마주할 수 있습니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JvmInline</span></span><br><span class="line">value <span class="keyword">class</span> <span class="title class_">UInt</span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Represented as &#x27;public final void compute(int x)&#x27; on the JVM</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">compute</span><span class="params">(x: <span class="type">Int</span>)</span></span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Also represented as &#x27;public final void compute(int x)&#x27; on the JVM!</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">compute</span><span class="params">(x: <span class="type">UInt</span>)</span></span> &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>이런 문제를 해결하기 위해 인라인 클래스를 사용하는 함수는 함수 이름안에 정적인 해시코드를 추가하여 public final void compute-hashcode(int x) 처럼 지저분하게 표현됩니다.</p>
<blockquote>
<p>📘 mangling 스키마는 1.4.30 부터 변경되었습니다. 컴파일러 플래그에 <code>-Xuse-14-inline-classes-mangling-scheme</code>를 사용하여 컴파일러가 1.4.0 mangling 방식을 사용하여 바이너리 호환성을 유지하도록 합니다.</p>
</blockquote>
<h3 id="Java-코드에서-호출"><a href="#Java-코드에서-호출" class="headerlink" title="Java 코드에서 호출"></a>Java 코드에서 호출</h3><p>Java 코드에서도 인라인 클래스를 허용하는 함수를 호출할 수 있습니다. 이렇게 하려면 함수 선언 앞에  <code>@JvmName</code> 어노테이션을 추가해서 mangling을 수동으로 비활성화해야합니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JvmInline</span></span><br><span class="line">value <span class="keyword">class</span> <span class="title class_">UInt</span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">compute</span><span class="params">(x: <span class="type">Int</span>)</span></span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JvmName(<span class="string">&quot;computeUInt&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">compute</span><span class="params">(x: <span class="type">UInt</span>)</span></span> &#123; &#125;</span><br></pre></td></tr></table></figure>



<h3 id="Inline-classes-and-delegation"><a href="#Inline-classes-and-delegation" class="headerlink" title="Inline classes and delegation"></a>Inline classes and delegation</h3><p>인라인 클래스에서 인터페이스로 인라인 프로퍼티 값에 대한 delegate 구현은 허용됩니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> = <span class="string">&quot;foo&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JvmInline</span></span><br><span class="line">value <span class="keyword">class</span> <span class="title class_">MyInterfaceWrapper</span>(<span class="keyword">val</span> myInterface: MyInterface) : MyInterface <span class="keyword">by</span> myInterface</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> my = MyInterfaceWrapper(<span class="keyword">object</span> : MyInterface &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// body</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    println(my.foo()) <span class="comment">// prints &quot;foo&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="Inline-classes-vs-type-alias"><a href="#Inline-classes-vs-type-alias" class="headerlink" title="Inline classes vs type alias"></a>Inline classes vs type alias</h3><p>인라인 클래스와 type alias는 타입에 대해서 새로운 타입으로 변경하고 런타임에 원래 타입으로 변경되어 사용된다는 점은 동일합니다. 하지만 이 둘의 차이점은 분명히 있습니다. <strong>type aliases</strong>는 기존 타입에 별칭을 붙여 완벽하게 호환하는 것인 반면 <strong>인라인 클래스</strong>는 새로운 타입을 생성하는 것으로 기존 타입과 구분되어 호환되지 않습니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> NameTypeAlias = String</span><br><span class="line"></span><br><span class="line"><span class="meta">@JvmInline</span></span><br><span class="line">value <span class="keyword">class</span> <span class="title class_">NameInlineClass</span>(<span class="keyword">val</span> s: String)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">acceptString</span><span class="params">(s: <span class="type">String</span>)</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">acceptNameTypeAlias</span><span class="params">(n: <span class="type">NameTypeAlias</span>)</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">acceptNameInlineClass</span><span class="params">(p: <span class="type">NameInlineClass</span>)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> nameAlias: NameTypeAlias = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">val</span> nameInlineClass: NameInlineClass = NameInlineClass(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> string: String = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    acceptString(nameAlias) <span class="comment">// OK: 기존 타입 대신에 alis를 넘겨주어도 됨</span></span><br><span class="line">    acceptString(nameInlineClass) <span class="comment">// Not OK: 기존 타입 대신에 인라인 클래스는 넘길 수 없음</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// And vice versa:</span></span><br><span class="line">    acceptNameTypeAlias(string) <span class="comment">// OK: alias 대신에 기본 타입을 넘길 수 있음</span></span><br><span class="line">    acceptNameInlineClass(string) <span class="comment">// Not OK: 기존 타입 대신에 인라인 클래스는 넘길 수 없음</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>지금까지 type alias와 Inline class에 대해서 알아보았습니다. </p>
<p>정리하자면 도메인에서 비즈니스 로직을 감싸기 위해 사용하는 Wrapper는 오버헤드가 발생할 수 있으니 Inline class를 활용해서 작성하면 좋을 것 같고 type alias 같은 경우는 복잡한 형태의 중첩된 제너릭을 사용해서 도메인으로서 사용하는 자료구조의 이름이 복잡할 때 컨벤션을 정해서 이름을 줄여 사용하면 유용해 보입니다.</p>
<h3 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://kotlinlang.org/docs/type-aliases.html">Kotlin - Type aliases</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://kotlinlang.org/docs/inline-classes.html#inline-classes-and-delegation">Kotlin - Inline classes</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://thdev.tech/kotlin/2020/10/13/kotlin_effective_06/">Taehwan - Kotlin typealias와 inline class를 알아보고 적절한 사용법을 알아보자.</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://wooooooak.github.io/kotlin/2021/01/03/inline_class/">쾌락코딩 - Kotlin Inline class</a></p>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-01-27T08:36:38.000Z" title="2023. 1. 27. 오후 5:36:38">2023-01-27</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-01-28T05:33:19.681Z" title="2023. 1. 28. 오후 2:33:19">2023-01-28</time></span><span class="level-item"><a class="link-muted" href="/categories/Kotlin/">Kotlin</a></span><span class="level-item">11 minutes read (About 1658 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/01/27/Kotlin-1-8-0-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-%EC%9A%94%EC%95%BD/">Kotlin 1.8.0 업데이트 요약</a></h1><div class="content"><p>코틀린 1.8.0 버전이 2022년 12월 28일에 정식으로 출시되었습니다. 새로운 코틀린 버전이 출시되면서 어떤 부분이 변경되었는지 업데이트를 요약해 보았습니다.</p>
<ul>
<li><p>IDE 지원</p>
</li>
<li><p>kotlin-reflect 성능 개선</p>
</li>
<li><p>최적화 비활성화를 위한 컴파일러 옵션 </p>
</li>
<li><p>JVM 컴파일 Target 업데이트</p>
</li>
<li><p>Java에서 Kotlin으로 TimeUnit 전환</p>
</li>
<li><p>Gradle 7.2 &amp; 7.3</p>
</li>
<li><p>Lombok @Builder 어노테이션 지원</p>
</li>
<li><p>코틀린 멀티플랫폼 : 새로운 안드로이드 소스세트 레이아웃</p>
</li>
<li><p>기타</p>
</li>
</ul>
<h2 id="IDE-지원"><a href="#IDE-지원" class="headerlink" title="IDE 지원"></a>IDE 지원</h2><p>코틀린 1.8.0 플러그인은 아래 IDE 버전에서 사용할 수 있습니다.</p>
<table>
<thead>
<tr>
<th>IDE</th>
<th>Supported versions</th>
</tr>
</thead>
<tbody><tr>
<td>IntelliJ IDEA</td>
<td>2021.3, 2022.1, 2022.2</td>
</tr>
<tr>
<td>Android Studio</td>
<td>Electric Eel (221), Flamingo (222)</td>
</tr>
</tbody></table>
<h2 id="kotlin-reflect-성능-개선"><a href="#kotlin-reflect-성능-개선" class="headerlink" title="kotlin-reflect 성능 개선"></a>kotlin-reflect 성능 개선</h2><p>kotlin-reflect가 JVM target 1.8로 컴파일 된다는 이점을 활용하여 내부 캐시 메커니즘을 Java의 <code>ClassValue</code>로 마이그레이션 하면서 기존에만 캐싱하던  <code>KClass</code>와 더불어 이제는 <code>KType</code> 그리고 <code>KDeclarationContainer</code>까지 캐싱됩니다. 이러한 변경으로 <code>typeOf()</code>가 호출할 때 큰 성능 향상을 가져갈 수 있습니다.</p>
</br>



<h2 id="최적화-비활성화를-위한-컴파일러-옵션"><a href="#최적화-비활성화를-위한-컴파일러-옵션" class="headerlink" title="최적화 비활성화를 위한 컴파일러 옵션"></a>최적화 비활성화를 위한 컴파일러 옵션</h2><p>코틀린 1.8.0에서는 더 나은 디버깅 환경을 위해 최적화 옵션을 비활성화하는  <code>-Xdebug</code> 컴파일러 옵션이 추가되었습니다. 이 옵션을 활성화하면 코루틴의 <code>was optimized out</code>기능이 비활성화 됩니다. 앞으로는 더 많은 최적화를 비활성화 할 수 있는 옵션들이 추가될 예정입니다.</p>
<p><code>was optimized out</code>은 일시 중단 함수를 사용할 때 변수들을 최적화하는 기능입니다. 하지만 최적화된 변수를 볼 수 없어 코드를 디버깅 하기에는 어려움이 따릅니다.</p>
<blockquote>
<p><code>-Xdebug</code> 를 통해 이 기능을 비활성화 하면 메모리 누수가 발생할 수 있으므로 </p>
<p>이 옵션은 프로덕션에서는 절대 사용해서는 안됩니다. </p>
</blockquote>
</br>



<h2 id="JVM-컴파일-Target-업데이트"><a href="#JVM-컴파일-Target-업데이트" class="headerlink" title="JVM 컴파일 Target 업데이트"></a>JVM 컴파일 Target 업데이트</h2><p>Kotlin 1.8.0 버전부터 코틀린 컴파일러는 JVM 버전 19를 지원합니다.</p>
<p>기존에 JVM target 1.6에서 컴파일되었던 코틀린 표준 라이브러리(<code>kotlin-stdlib</code>, <code>kotlin-reflect</code>, and <code>kotlin-script-*</code>)가 JVM target 1.8로 컴파일 됩니다. 또한 코틀린 1.8.0에서는 JVM target 1.6 그리고 1.7을 지원하지 않습니다. 결과적으로 이러한 아티팩트들이 <code>kotlin-stdlib</code>로 병합되기 때문에 빌드 스크립트를 더  이상  <code>kotlin-stdlib-jdk7</code> and <code>kotlin-stdlib-jdk8</code>을 분리해서  선언하지 않아도 됩니다.</p>
<blockquote>
<p>:blue_book: 빌드 스크립트에서 <code>kotlin-stdlib-jdk7</code> 이나 <code>kotlin-stdlib-jdk8</code> 이 명시적으로 선언되어있는 경우 <code>kotlin-stdlib</code>로 바꿔야 합니다.</p>
</blockquote>
<p>서로 다른 버전의 코틀린 표준 라이브러리를 섞어서 사용한다면 클래스가 중복되거나 누락될 가능성이 있습니다. 이를 방지하기 위해 Kotlin Gradle 플러그인을 사용하면 <a target="_blank" rel="noopener" href="https://kotlinlang.org/docs/whatsnew18.html#usage-of-the-latest-kotlin-stdlib-version-in-transitive-dependencies">표준 라이브러리 정렬</a>에 도움이 됩니다.</p>
<h2 id="Java에서-Kotlin으로-TimeUnit-전환"><a href="#Java에서-Kotlin으로-TimeUnit-전환" class="headerlink" title="Java에서 Kotlin으로 TimeUnit 전환"></a>Java에서 Kotlin으로 TimeUnit 전환</h2><p>Kotlin 1.6.0에서 실험적이었던 <code>toTimeUnit()</code> 그리고 <code>toDurationUnit()</code>기능들은 <code>kotlin.time</code> 패키지에서 스테이블 되었습니다. 이 함수들은 Java와 Kotlin의 상호운용성을 향상시키며 이제는 Java의 <code>java.util.concurrent.TimeUnit</code>을 Kotlin의 <code>kotlin.time.DurationUnit</code>으로 쉽게 전환할 수 있습니다. 이 함수들은 JVM에서만 지원합니다.</p>
<h2 id="Gradle-7-2-amp-7-3"><a href="#Gradle-7-2-amp-7-3" class="headerlink" title="Gradle 7.2 &amp; 7.3"></a>Gradle 7.2 &amp; 7.3</h2><p>코틀린 1.8.0은 Gradle 버전 7.2와 7.3을 완전히 지원합니다. Gradle 최소 지원 버전은 6.8.3 이며 Android Gradle 플러그인은 4.1.3 입니다. Gradle 버전을 최신 릴리즈 버전까지 사용할 수 있으나 지원 중단 경고가 표시되거나 새로운 Gradle 기능이 동작하지 않을 수도 있습니다.</p>
<h2 id="Lombok-Builder-어노테이션-지원"><a href="#Lombok-Builder-어노테이션-지원" class="headerlink" title="Lombok @Builder 어노테이션 지원"></a>Lombok @Builder 어노테이션 지원</h2><p>많은 커뮤니티에서 코틀린 Lombok의 @Builder 어노테이션을 지원해달라는 요청이 많았고 1.8.0부터는 해당 어노테이션을 지원합니다. Lombok을 사용하려면 gradle 플러그인을 추가해야 합니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    kotlin(<span class="string">&quot;plugin.lombok&quot;</span>) version <span class="string">&quot;1.8.0&quot;</span></span><br><span class="line">    id(<span class="string">&quot;io.freefair.lombok&quot;</span>) version <span class="string">&quot;5.3.0&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>아직 <code>@SuperBuilder</code> 혹은 <code>@Tolerate</code> 어노테이션을 지원할 계획은 없지만 많은 사람들의 요구가 있을 때 고려해볼 수 있습니다.</p>
<h2 id="코틀린-멀티플랫폼-새로운-안드로이드-소스세트-레이아웃"><a href="#코틀린-멀티플랫폼-새로운-안드로이드-소스세트-레이아웃" class="headerlink" title="코틀린 멀티플랫폼 : 새로운 안드로이드 소스세트 레이아웃"></a>코틀린 멀티플랫폼 : 새로운 안드로이드 소스세트 레이아웃</h2><p>코틀린 1.8.0부터는 여러 면에서 혼란스러웠던 디렉터리들의 네이밍 스키마들을 대체하는 새로운 안드로이드 소스세트 레이아웃 도입되었습니다.</p>
<p><code>AndroidTest</code> 디렉터리를 예로 들면 하나는 <code>KotlinSourceSets</code>이었고 다른 하나는 <code>AndroidSourceSets</code> 였습니다.</p>
<ul>
<li>코틀린의 <code>androidTest</code>는 <code>unitTest</code> 형태를 의미하지만 안드로이드 진영에서는 <code>interationTest</code>를 의미합니다.</li>
<li><code>src/androidTest/java</code>는 <code>UnitTest</code>가 있고 <code>src/androidTest/kotlin</code>는 <code>InstrumentedTest</code>가 있는 혼란스러운 <code>SourceDirectories</code> 레이아웃을 만듭니다.</li>
<li><code>KotlinSourceSets</code> 그리고 <code>AndroidSourceSets</code> 모두 Gradle 구성에 비슷한 네이밍 스키마를 사용하므로 <code>androidTest</code>의 결과 구성들은  <code>androidTestImplementation</code>, <code>androidTestApi</code>, <code>androidTestRuntimeOnly</code> 그리고  <code>androidTestCompileOnly</code> 와 같습니다.</li>
</ul>
<h3 id="KotlinSourceSet-네이밍-스키마"><a href="#KotlinSourceSet-네이밍-스키마" class="headerlink" title="KotlinSourceSet 네이밍 스키마"></a>KotlinSourceSet 네이밍 스키마</h3><table>
<thead>
<tr>
<th>현재 소스 세트 레이아웃</th>
<th>새로운 소스 세트 레이아웃</th>
</tr>
</thead>
<tbody><tr>
<td><code>targetName</code> + <code>AndroidSourceSet.name</code></td>
<td><code>targetName</code> + <code>AndroidVariantType</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th>현재 소스 세트 레이아웃</th>
<th>새로운 소스 세트 레이아웃</th>
</tr>
</thead>
<tbody><tr>
<td>main</td>
<td>androidMain</td>
<td>androidMain</td>
</tr>
<tr>
<td>test</td>
<td>androidTest</td>
<td>android<strong>Unit</strong>Test</td>
</tr>
<tr>
<td>androidTest</td>
<td>android<strong>Android</strong>Test</td>
<td>android<strong>Instrumented</strong>Test</td>
</tr>
</tbody></table>
<h3 id="SourceDirectories"><a href="#SourceDirectories" class="headerlink" title="SourceDirectories"></a>SourceDirectories</h3><table>
<thead>
<tr>
<th>현재 소스 세트 레이아웃</th>
<th>새로운 소스 세트 레이아웃</th>
</tr>
</thead>
<tbody><tr>
<td>The layout adds additional <code>/kotlin</code> SourceDirectories</td>
<td><code>src/&#123;AndroidSourceSet.name&#125;/kotlin</code>, <code>src/&#123;KotlinSourceSet.name&#125;/kotlin</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th>현재 소스 세트 레이아웃</th>
<th>새로운 소스 세트 레이아웃</th>
</tr>
</thead>
<tbody><tr>
<td>main</td>
<td>src&#x2F;androidMain&#x2F;kotlin, src&#x2F;main&#x2F;kotlin, src&#x2F;main&#x2F;java</td>
<td>src&#x2F;androidMain&#x2F;kotlin, src&#x2F;main&#x2F;kotlin, src&#x2F;main&#x2F;java</td>
</tr>
<tr>
<td>test</td>
<td>src&#x2F;androidTest&#x2F;kotlin, src&#x2F;test&#x2F;kotlin, src&#x2F;test&#x2F;java</td>
<td>src&#x2F;android<strong>Unit</strong>Test&#x2F;kotlin, src&#x2F;test&#x2F;kotlin, src&#x2F;test&#x2F;java</td>
</tr>
<tr>
<td>androidTest</td>
<td>src&#x2F;android<strong>Android</strong>Test&#x2F;kotlin, src&#x2F;androidTest&#x2F;java</td>
<td>src&#x2F;android<strong>Instrumented</strong>Test&#x2F;kotlin, src&#x2F;androidTest&#x2F;java, <strong>src&#x2F;androidTest&#x2F;kotlin</strong></td>
</tr>
</tbody></table>
<h3 id="AndroidManifest-xml-파일-위치"><a href="#AndroidManifest-xml-파일-위치" class="headerlink" title="AndroidManifest.xml 파일 위치"></a>AndroidManifest.xml 파일 위치</h3><table>
<thead>
<tr>
<th>현재 소스 세트 레이아웃</th>
<th>새로운 소스 세트 레이아웃</th>
</tr>
</thead>
<tbody><tr>
<td>src&#x2F;{<strong>Android</strong>SourceSet.name}&#x2F;…Manifest.xml</td>
<td>src&#x2F;{<strong>Kotlin</strong>SourceSet.name}&#x2F;…Manifest.xml</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th>현재 소스 세트 레이아웃</th>
<th>새로운 소스 세트 레이아웃</th>
</tr>
</thead>
<tbody><tr>
<td>main</td>
<td>src&#x2F;main&#x2F;AndroidManifest.xml</td>
<td>src&#x2F;<strong>android</strong>Main&#x2F;AndroidManifest.xml</td>
</tr>
<tr>
<td>debug</td>
<td>src&#x2F;debug&#x2F;AndroidManifest.xml</td>
<td>src&#x2F;<strong>android</strong>Debug&#x2F;AndroidManifest.xml</td>
</tr>
</tbody></table>
<h2 id="기타"><a href="#기타" class="headerlink" title="기타"></a>기타</h2><ul>
<li>Xcode 14.1 지원</li>
<li>Objective-C&#x2F;Swift 와의 상호운용성 향상</li>
<li>CocoaPods Gradle 플러그인에서 Dynamic frameworks를 기본으로 연결</li>
</ul>
<p>지금까지 긴 글 읽어 주셔서 감사합니다. :bow:</p>
<h3 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h3><ul>
<li><a target="_blank" rel="noopener" href="https://kotlinlang.org/docs/whatsnew18.html">Kotlin 1.8.0</a></li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-01-19T02:05:33.000Z" title="2023. 1. 19. 오전 11:05:33">2023-01-19</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-01-19T02:08:40.242Z" title="2023. 1. 19. 오전 11:08:40">2023-01-19</time></span><span class="level-item"><a class="link-muted" href="/categories/Kotlin/">Kotlin</a></span><span class="level-item">4 minutes read (About 600 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/01/19/kotlin-%EB%8F%99%EB%93%B1%EC%84%B1-Equality-%EB%8F%99%EC%9D%BC%EC%84%B1-Identify/">kotlin 동등성(Equality), 동일성(Identify)</a></h1><div class="content"><p>코틀린에서는 두 객체를 비교하는타입에는 2가지가 있습니다.</p>
<ul>
<li>동등성, Structural equality (&#x3D;&#x3D;)</li>
<li>동일성, Referential equality (&#x3D;&#x3D;&#x3D;)</li>
</ul>
<p>동일성은 객체가 참조하는 주소값을 비교하고, 동등성은 객체가 가지는 정보를 비교합니다.</p>
<p>Java에서는 동일성인 <code>==</code>가 코틀린의 동일성인 <code>===</code>와 같은 것을 의미하고 Java 동등성인  <code>equals</code>는 코틀린의 동등성인 <code>==</code>를 의미합니다.</p>
<table>
<thead>
<tr>
<th></th>
<th>Kotlin</th>
<th>Java</th>
</tr>
</thead>
<tbody><tr>
<td>동등성(equality)</td>
<td>&#x3D;&#x3D;</td>
<td>equals</td>
</tr>
<tr>
<td>동일성(Identify)</td>
<td>&#x3D;&#x3D;&#x3D;</td>
<td>&#x3D;&#x3D;</td>
</tr>
</tbody></table>
<h3 id="동등성-비교-Structural-equality"><a href="#동등성-비교-Structural-equality" class="headerlink" title="동등성 비교(Structural equality)"></a>동등성 비교(Structural equality)</h3><p>코틀린에서는 <code>==</code> 연산자나 반대인 <code>!=</code> 연산자로 구조적 동등성을 확인 할 수 있습니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a?.equals(b) ?: (b === <span class="literal">null</span>)</span><br></pre></td></tr></table></figure>

<p>위 코드는 <code>a</code>가 <code>null</code>이 아닐 때 <code>equals(Any?)</code>함수를 호출하고 <code>a</code>가 <code>null</code>이 아닐 때 b의 레퍼런스가 <code>null</code>과 같은지에 대한 코드입니다. <code>a == null</code> 코드는 자동적으로 <code>a === null</code>로 변환해주기 때문에  <code>null</code>을 명시적으로 <code>==</code>로 비교하는 것은  의미가 없습니다. </p>
<p><code>equals(other: Any?): Boolean)</code> 함수를 오버라이딩해서 커스텀 equals를 구현할 수 있습니다. <code>equals(other: Foo)</code> 함수와 같은 이름과 시그니처를 가진 함수는 <code>==</code> 및 <code>!=</code> 연산자를 사용한 동등성 검사에 영향을 주지 않습니다.</p>
<p>또한 동등성 비교는 <code>Comparable&lt;...&gt;</code> 같은 인터페이스를 정의해서 비교할 필요가 없습니다. 오직 커스텀 <code>equals(Any?)</code>만 구현해서 동작할 수 있게 하면 됩니다</p>
<h3 id="동일성-비교-Referential-equality"><a href="#동일성-비교-Referential-equality" class="headerlink" title="동일성 비교(Referential equality)"></a>동일성 비교(Referential equality)</h3><p>동일성 비교는 <code>===</code>연산자와 그 반대인 <code>!==</code>로 동일성 검사를 할 수 있습니다. <code>a===b</code>가 true를 리턴할 때는 <code>a</code>와 <code>b</code>가 가리키는 주소 값이 동일 하다는 것을 의미합니다. 런타임시 primitive타입(Int, String, Float..)의 값의 경우 <code>===</code>은 <code>==</code>와 동일합니다.</p>
<h3 id="Floating-point-숫자-비교"><a href="#Floating-point-숫자-비교" class="headerlink" title="Floating-point 숫자 비교"></a>Floating-point 숫자 비교</h3><p>피연산 함수로 알려진 Float, Dobule(null 혹은 not null)은 IEEE 754 표준에 맞는 부동 소수점 산술을 따라야합니다. 아래와 같은 기준을 따르지 않는다면 동등성 비교가 사용됩니다.</p>
<ul>
<li><p><code>Nan</code>은 <code>NaN</code>자신과 동등한 것으로 비교가 가능하다</p>
</li>
<li><p><code>NaN</code>은  <code>POSITIVE_INFINITY</code>를 포함해 다른 어떤 것보다 크다</p>
</li>
<li><p><code>-0.0</code>은 <code>0.0</code> 보다 작다</p>
</li>
</ul>
<h3 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h3><p><a target="_blank" rel="noopener" href="https://kotlinlang.org/docs/equality.html">Kotlin Docs - Equality</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-01-13T18:35:38.000Z" title="2023. 1. 14. 오전 3:35:38">2023-01-14</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-01-19T02:09:49.878Z" title="2023. 1. 19. 오전 11:09:49">2023-01-19</time></span><span class="level-item"><a class="link-muted" href="/categories/Kotlin/">Kotlin</a></span><span class="level-item">11 minutes read (About 1600 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/01/14/kotlin-sequence/">kotlin-sequence</a></h1><div class="content"><p>Kotlin standard library는 Collection과 함께 또 다른 유형인 <em>Sequences</em><code>(Sequence&lt;T&gt;)</code> 를 포함하고 있습니다. 컬렉션과는 달리 시퀀스는 엘리먼트를 포함하지 않으며 반복하는 동안 엘리먼트를 생성합니다. 시퀀스는 <code>Iterable</code>과 동일한 기능을 제공하지만 여러 단계 처리에 대한 다른 접근방식을 구현합니다.</p>
<p><code>Iterable</code>은  여러 과정을 처리할 때 각 단계를 완료하고 그 결과인 중간 컬렉션을 반환합니다. 시퀀스는 여러 과정의 처리에서 가능한 Lazily(나중에)하게 처리합니다. 이 의미는 시퀀스는 여러 단계의 처리는 바로 실행하지 않고 전체 단계가 처리된 결과가 요청되었을 때 실제 시퀀스 연산이 일어나면서 Lazily(나중에)하게 처리됩니다.</p>
<p>동작 실행 순서도 다르다고 할 수 있습니다. <code>Sequence</code>는 모든 단일 요소에 대해 처리를 One-By-One 형태로 수행하는 반면 <code>Iterable</code> 은 전체 컬렉션의 각 단계를 완료하고 그 다음 단계로 진행합니다.</p>
<p>따라서 시퀀스를 사용하면 중간 단계의 결과에 대한 처리를 피할 수 있습니다. 그러므로 전체 컬렉션의 체이닝 동작에서 퍼포먼스 향상을 기대할 수 있습니다. 그러나 이런 시퀀스의 Lazy 특성은 오히려 간단한 계산이나 작은 컬렉션을 처리할 때 불필요한 오버헤드가 발생할 수 있습니다. 이런 이유로 <code>Sequence</code>와 <code>Iterable</code> 사이에서 어떤것이 해당 케이스에서 더 효율적인지를 고려해야합니다.</p>
<h1 id="Construct"><a href="#Construct" class="headerlink" title="Construct"></a>Construct</h1><h4 id="From-elements"><a href="#From-elements" class="headerlink" title="From elements"></a>From elements</h4><p>시퀀스를 만들기 위해서는 <code>sequenceOf()</code> 함수를 호출하고 인자들을 나열하면 됩니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> numbersSequence = sequenceOf(<span class="string">&quot;four&quot;</span>, <span class="string">&quot;three&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;one&quot;</span>)</span><br></pre></td></tr></table></figure>



<h4 id="From-an-Iterable"><a href="#From-an-Iterable" class="headerlink" title="From an Iterable"></a>From an Iterable</h4><p><code>Iterable</code>객체(<code>List</code>와  <code>Set</code>등)를 <code>asSequence()</code>를 호출해서 시퀀스로 만들 수 있습니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> numbers = listOf(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>, <span class="string">&quot;four&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> numbersSequence = numbers.asSequence()</span><br></pre></td></tr></table></figure>

<h4 id="From-a-Function"><a href="#From-a-Function" class="headerlink" title="From a Function"></a>From a Function</h4><p>시퀀스의 요소들을 계산 할 수 있는 방식인 <code>generateSequence()</code>함수와 함께 구축하는 방법도 있습니다. 선택적으로 첫번째 인자를 명시적으로 선언할 수 있습니다. 이런 시퀀스 생성은 <code>null</code>을 반환하면 중지됩니다. 아래 예제를 보면 무한한 시퀀스가 있습니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> oddNumbers = generateSequence(<span class="number">1</span>) &#123; it + <span class="number">2</span> &#125; <span class="comment">// `it` is the previous element</span></span><br><span class="line"><span class="comment">//println(oddNumbers.take(5).toList()) // Result : [1, 3, 5, 7, 9]</span></span><br><span class="line"></span><br><span class="line">println(oddNumbers.count())     <span class="comment">// error: the sequence is infinite</span></span><br><span class="line"><span class="comment">// Result : Evaluation stopped while it&#x27;s taking too long️</span></span><br></pre></td></tr></table></figure>

<p> <code>generateSequence()</code>를 사용할 때 유한한 시퀀스를 만들기 위해서는 마지막 요소 다음에 null을 반환해야 합니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> oddNumbersLessThan10 = generateSequence(<span class="number">1</span>) &#123; <span class="keyword">if</span> (it &lt; <span class="number">8</span>) it + <span class="number">2</span> <span class="keyword">else</span> <span class="literal">null</span> &#125;</span><br><span class="line">println(oddNumbersLessThan10.count()) <span class="comment">// Result: 5</span></span><br></pre></td></tr></table></figure>

<h3 id="From-chunk"><a href="#From-chunk" class="headerlink" title="From chunk"></a>From chunk</h3><p>마지막으로 시퀀스를 임의의 크기의 덩어리로 생성할 수 있는 기능이 있습니다. 이 기능은 람다 함수내에서 호출할 수 있는 <code>yield()</code> 그리고 <code>yieldAll()</code> 함수입니다. 이 함수는 시퀀스 소비자에게 요소들을 반환하고 소비자가 다음 요소를 요청할 때 까지 <code>sequence()</code> 실행을 일시중단 합니다. <code>yield()</code>는 단일 요소를 인자로 가지고 <code>yieldAll()</code>은 <code>Iterable</code>객체를 인자로 가지고 <code>Iterator</code>나 다른 <code>Sequence</code>도 가질 수 있습니다. <code>yieldAll</code>에 인자로 들어가는 <code>Sequence</code>는 무한할 수 있지만 모든 후속 호출은 실행되지 않기 때문에 마지막에만 호출해야 합니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> oddNumbers = sequence &#123;</span><br><span class="line">    yield(<span class="number">1</span>)</span><br><span class="line">    yieldAll(listOf(<span class="number">3</span>, <span class="number">5</span>))</span><br><span class="line">    yieldAll(generateSequence(<span class="number">7</span>) &#123; it + <span class="number">2</span> &#125;)</span><br><span class="line">&#125;</span><br><span class="line">println(oddNumbers.take(<span class="number">5</span>).toList())</span><br></pre></td></tr></table></figure>



<h2 id="Sequence-operations"><a href="#Sequence-operations" class="headerlink" title="Sequence operations"></a>Sequence operations</h2><p>시퀀스 동작은 상태요구에 따라서 그룹별로 분류될 수 있습니다. </p>
<ul>
<li><code>map()</code>이나 <code>filter()</code>과 같은 스테이트리스(Stateless) 동작은 상태나 각 요소들간의 의존적인 과정을 요구하지 않지만 <code>take()</code> 나 <code>drop()</code>처럼 적은 양을 가진 상수의 상태는 요구할 수 있습니다.</li>
<li>스테이트풀(Stateful) 동작은 시퀀스에서 비례하는 요소들의 숫자만큼 상당한 양의 상태가 필요합니다.</li>
</ul>
<p>시퀀스 동작이 Lazliy하게 생성된 다른 시퀀스를 리턴하면 그것을 <code>itermediate</code>라 하고 다른 동작은 <code>terminal</code>이라고 합니다.<code>terminal</code>의 수행 동작의 예로는 <code>toList()</code> 또는 <code>sum()</code>이 있습니다. 시퀀스 요소들은 오직 <code>terminal</code>이라는 동작으로만 얻어질 수 있습니다. </p>
<p>시퀀스는 여러번의 Iteration이 가능하지만 일부 시퀀스의 구현은 한번만 반복으로 되도록 제한되어 있습니다. 해당 내용은 문화되어있습니다.</p>
<h2 id="Sequence-processing-example"><a href="#Sequence-processing-example" class="headerlink" title="Sequence processing example"></a>Sequence processing example</h2><p><code>Iterable</code>과 <code>Sequnce</code>의 차이를 예제로 살펴보겠습니다.</p>
<h4 id="Iterable"><a href="#Iterable" class="headerlink" title="Iterable"></a>Iterable</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> words = <span class="string">&quot;The quick brown fox jumps over the lazy dog&quot;</span>.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="keyword">val</span> lengthsList = words.filter &#123; println(<span class="string">&quot;filter: <span class="variable">$it</span>&quot;</span>); it.length &gt; <span class="number">3</span> &#125;</span><br><span class="line">    .map &#123; println(<span class="string">&quot;length: <span class="subst">$&#123;it.length&#125;</span>&quot;</span>); it.length &#125;</span><br><span class="line">    .take(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">println(<span class="string">&quot;Lengths of first 4 words longer than 3 chars:&quot;</span>)</span><br><span class="line">println(lengthsList)</span><br><span class="line"><span class="comment">// Result</span></span><br><span class="line"><span class="comment">// filter: The</span></span><br><span class="line"><span class="comment">// filter: quick</span></span><br><span class="line"><span class="comment">// filter: brown</span></span><br><span class="line"><span class="comment">// filter: fox</span></span><br><span class="line"><span class="comment">// filter: jumps</span></span><br><span class="line"><span class="comment">// filter: over</span></span><br><span class="line"><span class="comment">// filter: the</span></span><br><span class="line"><span class="comment">// filter: lazy</span></span><br><span class="line"><span class="comment">// filter: dog</span></span><br><span class="line"><span class="comment">// length: 5</span></span><br><span class="line"><span class="comment">// length: 5</span></span><br><span class="line"><span class="comment">// length: 5</span></span><br><span class="line"><span class="comment">// length: 4</span></span><br><span class="line"><span class="comment">// length: 4</span></span><br><span class="line"><span class="comment">// Lengths of first 4 words longer than 3 chars:</span></span><br><span class="line"><span class="comment">// [5, 5, 5, 4]</span></span><br></pre></td></tr></table></figure>

<p>위의 예제를 보면 단어 리스트에서 길이가 3을 초과하는 <code>filter()</code>와 필터링된 문자열 길이를 <code>map()</code> 이 순서대로 호출되는걸 볼 수 있습니다. 순차적으로 filter의 모든 요소들이 수행되고 리턴된 결과로 map이 수행됩니다.</p>
<p><img src="https://kotlinlang.org/docs/images/list-processing.png" alt="image"></p>
<h4 id="Sequence"><a href="#Sequence" class="headerlink" title="Sequence"></a>Sequence</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> words = <span class="string">&quot;The quick brown fox jumps over the lazy dog&quot;</span>.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="comment">//convert the List to a Sequence</span></span><br><span class="line"><span class="keyword">val</span> wordsSequence = words.asSequence()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> lengthsSequence = wordsSequence.filter &#123; println(<span class="string">&quot;filter: <span class="variable">$it</span>&quot;</span>); it.length &gt; <span class="number">3</span> &#125;</span><br><span class="line">    .map &#123; println(<span class="string">&quot;length: <span class="subst">$&#123;it.length&#125;</span>&quot;</span>); it.length &#125;</span><br><span class="line">    .take(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">println(<span class="string">&quot;Lengths of first 4 words longer than 3 chars&quot;</span>)</span><br><span class="line"><span class="comment">// terminal operation: obtaining the result as a List</span></span><br><span class="line">println(lengthsSequence.toList())</span><br><span class="line"><span class="comment">// Result</span></span><br><span class="line"><span class="comment">// Lengths of first 4 words longer than 3 chars</span></span><br><span class="line"><span class="comment">// filter: The</span></span><br><span class="line"><span class="comment">// filter: quick</span></span><br><span class="line"><span class="comment">// length: 5</span></span><br><span class="line"><span class="comment">// filter: brown</span></span><br><span class="line"><span class="comment">// length: 5</span></span><br><span class="line"><span class="comment">// filter: fox</span></span><br><span class="line"><span class="comment">// filter: jumps</span></span><br><span class="line"><span class="comment">// length: 5</span></span><br><span class="line"><span class="comment">// filter: over</span></span><br><span class="line"><span class="comment">// length: 4</span></span><br><span class="line"><span class="comment">// [5, 5, 5, 4]</span></span><br></pre></td></tr></table></figure>

<p>코드의 결과물을 보면 프린트가 먼저 출력된 것을 통해  <code>filter()</code>와 <code>map()</code> 함수들이 시퀀스를 리스트로 치환할 때 호출되면서 시퀀스의 시작이 실제로 필요로 할 때 시작되는 것을 알 수 있습니다. 또한 <code>map()</code>은 <code>filter()</code>에서 요소를 리턴하자 마자 실행됩니다. 그리고 <code>take(4)</code>로 4개의 요소만 필요하기 때문에 시퀀스 처리가 만족하는 개수가 4개가 되었을 때 수행은 정지된다.</p>
<p><img src="https://kotlinlang.org/docs/images/sequence-processing.png" alt="image"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-01-08T03:13:44.000Z" title="2023. 1. 8. 오후 12:13:44">2023-01-08</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-01-19T02:10:18.738Z" title="2023. 1. 19. 오전 11:10:18">2023-01-19</time></span><span class="level-item"><a class="link-muted" href="/categories/Kotlin/">Kotlin</a><span> / </span><a class="link-muted" href="/categories/Kotlin/Coroutine/">Coroutine</a></span><span class="level-item">14 minutes read (About 2110 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/01/08/coroutine/">기본 코루틴(Coroutine Basics)</a></h1><div class="content"><h2 id="첫번째-코루틴-Your-first-coroutine"><a href="#첫번째-코루틴-Your-first-coroutine" class="headerlink" title="첫번째 코루틴(Your first coroutine)"></a>첫번째 코루틴(Your first coroutine)</h2><p>코루틴은 일시 중단 가능한 계산의 인스턴스입니다. 코드의 블록들이 다른 코드 들과 동시에 동작해야 한다는 점에서는 개념적으로 스레드와 유사합니다. 하지만 코루틴은 </p>
<p>나머지 코드와 동시에 작동하는 코드들이 하나의 블럭에서 실행해야  코드의 블럭이 실행될 때 동시적으로 실행할 수 있습니다. 그러나 코루틴은 특정한 스레드에 바운드 되지 않고 한 스레드에서 일시 중단하고 다른 스레드에서 다시 재개할 수 있습니다.</p>
<p>코루틴은 경량 스레드라고 생각할 수 있습니다. 하지만 실제 우리가 사용하는 스레드와는 다르게 만드는 중요한 요소들이 있습니다.</p>
<p>다음 코드를 실행하여 첫번째 코루틴 작업을 확인해봅니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123; <span class="comment">// this: CoroutineScope</span></span><br><span class="line">    launch &#123; <span class="comment">// launch a new coroutine and continue</span></span><br><span class="line">        delay(<span class="number">1000L</span>) <span class="comment">// non-blocking delay for 1 second (default time unit is ms)</span></span><br><span class="line">        println(<span class="string">&quot;World!&quot;</span>) <span class="comment">// print after delay</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Hello&quot;</span>) <span class="comment">// main coroutine continues while a previous one is delayed</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// result</span></span><br><span class="line">Hello</span><br><span class="line">World!</span><br></pre></td></tr></table></figure>

<p>다음과 같은 결과가 나오는 걸 볼 수 있습니다.</p>
<p>한번 이 코드가 무엇인지 해부해보겠습니다</p>
<p><code>launch</code>는 코루틴 빌더입니다. <code>launch</code>는 새로운 코루틴을 실행함과 동시에 나머지 코드들을 독립적으로 계속 작업합니다. 그것이 <code>Hello</code>가 첫번째로 프린트된 이유입니다.</p>
<p><code>delay</code> 는 특별한 일시중단 함수입니다. 코루틴을 특정 시간동안 일시 중단합니다. 코루틴을 일시중단해도 기본스레드가 차단되지는 않으며 다른 코루틴들도 기본스레드를 사용하여 코루틴을 실행하할 수 있습니다.</p>
<p><code>runBlocking</code>은  <code>fun main()</code> 과 같은 기본적인 코루틴이 아닌 세계와  <code>runBlocking &#123; ... &#125;</code> 중괄호 안에 있는 코루틴 코드들을 연결하는 코루틴 빌더입니다. <code>runBlocking</code> 코드를 작성해보면 IDE에서 중괄호 바로 뒤에 CoroutineScope라는 힌트가 표시됩니다.</p>
<p><code>launch</code>는 CoroutineScope에서만 선언이 가능하기 때문에 만약 깜빡하고 <code>runBlocking</code>을 코드에서 제거한다면  <code>launch</code>를 호출할 때 에러가 발생합니다. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unresolved reference: launch</span><br></pre></td></tr></table></figure>

<p><code>runBlocking</code> 은 의미는 <code>runBlocking &#123; ... &#125;</code> 내부의 모든 코루틴들이 실행이 완료 될 때까지 이를 실행하는 스레드(메인스레드라고 가정)는 차단된다는 것을 의미합니다. 스레드는 차단하는 것은 스레드의 비용이 비싸기 때문에 비효율적이지만 실제코드에서는 앱의 최상위 레벨에서 runBlcoking 자주 사용되는 것을 볼 수 있습니다.</p>
<h3 id="구조화된-동시성-Structured-concurrency"><a href="#구조화된-동시성-Structured-concurrency" class="headerlink" title="구조화된 동시성(Structured concurrency)"></a>구조화된 동시성(Structured concurrency)</h3><p>코루틴 <strong>구조화된 동시성</strong>을 원칙을 따릅니다. 즉, 구조화된 동시성이란 새로운 코루틴은 오직 코루틴의 수명을 제한하는 특정한 <a target="_blank" rel="noopener" href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/">CoroutineScope</a>에서만 실행될 수 있다는 것을 의미합니다. 위의 예제에서는 <code>runBlocking</code> 해당하는 스코프를 설정하고 World!는 몇초뒤에 프린트 된 것을 볼 수 있습니다.</p>
<p>실제 앱에서는 많은 양의 코루틴을 실행해야합니다. 구조화된 동시성은 손실이나 릭을 발생하지 않게 보장합니다. 외부 범위는 모든 하위 코루틴이 완료될 때까지 완료할 수 없습니다. 또한 구조화된 동시성은은 코드에서 발생한 모든 에러가 올바르게 보고되고 손실이 발생하지 않게 합니다.</p>
<hr>
<h2 id="함수-추출-리팩토링-Extract-function-refactoring"><a href="#함수-추출-리팩토링-Extract-function-refactoring" class="headerlink" title="함수 추출 리팩토링(Extract function refactoring)"></a>함수 추출 리팩토링(Extract function refactoring)</h2><p>launch { … } 내부의 코드 블록을 별도의 함수로 추출해보겠습니다. 만약 코드에서 “함수 추출”이라는 리팩토링을 수행한다면 <code>suspend</code> 수정자와 함께 새로운 함수를 만들 수 있습니다. 이건 당신의 첫번째 <em>중단 함수</em> 입니다. 중단 함수는 코루틴 내부에서 일반적인 함수처럼 사용합니다 하지만 일반적인 함수와 다른 점은 코루틴을 일시중지하기 위해 다른 코루틴 함수의 기능들(deplay 함수 같은) 추가 기능들이 존재한다는 것입니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123; <span class="comment">// this: CoroutineScope</span></span><br><span class="line">    launch &#123; doWorld() &#125;</span><br><span class="line">    println(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this is your first suspending function</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWorld</span><span class="params">()</span></span> &#123;</span><br><span class="line">    delay(<span class="number">1000L</span>)</span><br><span class="line">    println(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// result</span></span><br><span class="line">Hello</span><br><span class="line">World!</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="스코프-빌더-Scope-builder"><a href="#스코프-빌더-Scope-builder" class="headerlink" title="스코프 빌더(Scope builder)"></a>스코프 빌더(Scope builder)</h2><p>코루틴스코프 빌더를 사용하여 다른 빌더에서 제공되는 코루틴 스코프외에도 자신만의 스코프를 선언할 수 있습니다. 그리고 코루틴 스코프를 생성한 후 해당 스코프내의 생성된 자식 작업들이 완료되기 전까지는 스코프가 완료되지 않습니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    doWorld()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWorld</span><span class="params">()</span></span> = coroutineScope &#123;  <span class="comment">// this: CoroutineScope</span></span><br><span class="line">    launch &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// result</span></span><br><span class="line">Hello</span><br><span class="line">World!</span><br></pre></td></tr></table></figure>

<p><code>runBlocking</code> 그리고 <code>coroutineScope</code> 빌더들은 둘다 바디와 모든 자식들이 작업이 완료되기까지 기다리는 것으로 유사하게 보이지만 가장 큰 차이점은 <code>runBlocking</code> 함수가 대기를 위해 현재 스레드를 _차단_한다면 <code>coroutineScope</code>는 단순히 일시중단하고 다른 용도를 위해 기본 스레드를 해제합니다. 그 차이 때문에 <code>runBlocking</code>은 일반 함수이고 <code>coroutineScope</code>는 정지함수 입니다.</p>
<p><code>coroutineScope</code>를 어떠한 중단함수로서 사용할 수 있습니다. 예를 들어 Hello와 World의 동시적인 로그 출력을 <code>suspend fun doWorld()</code> 로 옮길 수 있습니다.</p>
<hr>
<h2 id="스코프-빌더-그리고-동시성-Scope-builder-and-concurrency"><a href="#스코프-빌더-그리고-동시성-Scope-builder-and-concurrency" class="headerlink" title="스코프 빌더 그리고 동시성(Scope builder and concurrency﻿)"></a>스코프 빌더 그리고 동시성(Scope builder and concurrency﻿)</h2><p><code>coroutineScope</code> 빌더는 여러 동시 작업을 수행하기 위해 정지 함수 내에서 사용할 수 있습니다</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sequentially executes doWorld followed by &quot;Done&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    doWorld()</span><br><span class="line">    println(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concurrently executes both sections</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWorld</span><span class="params">()</span></span> = coroutineScope &#123; <span class="comment">// this: CoroutineScope</span></span><br><span class="line">    launch &#123;</span><br><span class="line">        delay(<span class="number">2000L</span>)</span><br><span class="line">        println(<span class="string">&quot;World 2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    launch &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;World 1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// result</span></span><br><span class="line">Hello</span><br><span class="line">World <span class="number">1</span></span><br><span class="line">World <span class="number">2</span></span><br><span class="line">Done</span><br></pre></td></tr></table></figure>

<p><code>launch &#123; ... &#125;</code> 블록 내부에 두 개의 코드들은 동시적으로 실행되며 <code>World 1</code>이 먼저 프린트 된 후 1초 후에 <code>World  2</code>의 프린트가 시작되고 2초 뒤에 프린트합니다. <code>coroutineScope</code> <code>doWorld</code> </p>
<p>코루틴 스코프에 있는 <code>doWorld</code>의 함수는 두 개의 작업이 모두 완료된 후에만 완료됩니다. 그래서 <code>doWorld</code>는 모든 작업이 완료된 후 Done 문자열이 인쇄되도록 허용합니다</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Hello</span><br><span class="line">World 1</span><br><span class="line">World 2</span><br><span class="line">Done</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="명시적-작업-An-explicit-job"><a href="#명시적-작업-An-explicit-job" class="headerlink" title="명시적 작업(An explicit job)"></a>명시적 작업(An explicit job)</h2><p><code>launch</code> 코루틴 빌더는 <code>Job</code> 객체를 리턴합니다. <code>Job</code>은 실행된 코루틴을 핸들링하고 작업이 완전히 끝날때까지 명시적으로 기다리는 용도로 사용할 수 있습니다. 예를들어 자식 코루틴들이 완료되기전까지 기다린 후에 “Done” 문자열을 출력할 수 있습니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> job = launch &#123; <span class="comment">// launch a new coroutine and keep a reference to its Job</span></span><br><span class="line">    delay(<span class="number">1000L</span>)</span><br><span class="line">    println(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">job.join() <span class="comment">// wait until child coroutine completes</span></span><br><span class="line">println(<span class="string">&quot;Done&quot;</span>) </span><br><span class="line"><span class="comment">// result</span></span><br><span class="line">Hello</span><br><span class="line">World!</span><br><span class="line">Done</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="코루틴은-가볍습니다-Coroutines-are-light-weight"><a href="#코루틴은-가볍습니다-Coroutines-are-light-weight" class="headerlink" title="코루틴은 가볍습니다(Coroutines are light-weight)"></a>코루틴은 가볍습니다(Coroutines are light-weight)</h2><p>코루틴은 JVM 스레드에서 리소스 집약이 더 적습니다. 스레드를 사용할 때 JVM의 가용 메모리를 소진하는 코드는 리소 제한에 도달하지 않고 콜튄을 사용하여 표현할 수 있습니다.</p>
<p>스레드에서 JVM의 가용 메모리를 소진하는 코드는 코루틴을 사용하는것으로 리소스 제한에 도달하지 않을 수 있습니다. 예를들어 다음 코드는 100000개의 서로 다른 코루틴을 시작하여 각각 5초를 기다린 다음 마침표(‘.’)를 프린트하는 코드가 있습니다. 이 코드는 매우 적은 메모리를 사용합니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    repeat(<span class="number">100_000</span>) &#123; <span class="comment">// launch a lot of coroutines</span></span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(<span class="number">5000L</span>)</span><br><span class="line">            print(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>해당 코드를 스레드에서 비교하고 싶으신 경우 <code>runBlocking</code>과 <code>launch</code>를 <code>thread</code>로 교체하고 <code>delay</code> 함수도 <code>Thread.sleep</code>으로 교체해줍니다. 만약 해당 코드를 실행한다면 많은 메모리를 소비하여 OOM(out-of-memoery)에러가 발생할 수 있습니다.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-12-15T05:18:40.000Z" title="2022. 12. 15. 오후 2:18:40">2022-12-15</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-01-08T03:11:35.824Z" title="2023. 1. 8. 오후 12:11:35">2023-01-08</time></span><span class="level-item"><a class="link-muted" href="/categories/Kotlin/">Kotlin</a></span><span class="level-item">3 minutes read (About 423 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/12/15/Ktoin%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9-%E1%84%85%E1%85%A1%E1%86%B7%E1%84%83%E1%85%A1-%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%E1%84%8B%E1%85%AA-%E1%84%80%E1%85%A9%E1%84%8E%E1%85%A1%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%E1%84%85%E1%85%A1%E1%86%AB/">Kotlin으로 람다 함수와 고차함수란</a></h1><div class="content"><h2 id="Kotlin으로-람다-함수-Lambda-Function-와-고차-함수-High-Order-Function-에-대해서-알아보자"><a href="#Kotlin으로-람다-함수-Lambda-Function-와-고차-함수-High-Order-Function-에-대해서-알아보자" class="headerlink" title="Kotlin으로 람다 함수(Lambda Function)와  고차 함수(High Order Function)에 대해서 알아보자"></a>Kotlin으로 람다 함수(Lambda Function)와  고차 함수(High Order Function)에 대해서 알아보자</h2><h3 id="Lambda-Function-람다-함수-이란"><a href="#Lambda-Function-람다-함수-이란" class="headerlink" title="Lambda Function(람다 함수) 이란?"></a>Lambda Function(람다 함수) 이란?</h3><p>람다 함수는 함수형 프로그래밍 언어에서 사용되는 개념으로 <strong>익명 함수</strong>라고도 불린다<br>Java8 부터 사용이 가능하며, 가독성을 향상시키고 보일러 플레이트 코드를 줄일 수 있다</p>
<h3 id="Lambda-Function-람다-함수-의-사용-방법"><a href="#Lambda-Function-람다-함수-의-사용-방법" class="headerlink" title="Lambda Function(람다 함수) 의 사용 방법"></a>Lambda Function(람다 함수) 의 사용 방법</h3><p><strong>기본 사용 방법</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> lambdaName : Type = &#123; argumentList -&gt; codeBody &#125;</span><br></pre></td></tr></table></figure>

<p><strong>Type Interface를 활용하는 방법</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> square = &#123; number: <span class="built_in">Int</span> -&gt; number * number &#125;</span><br><span class="line"><span class="keyword">val</span> nine = square(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>





<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> lambdaName = &#123; a: <span class="built_in">Int</span>, b: String -&gt; </span><br><span class="line">	<span class="string">&quot;<span class="variable">$a</span> <span class="variable">$b</span>&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1개 이상의 타입을 파라미터로 전달 가능하고 리턴 타입을 생략 할 수 있습니다</p>
<hr>
<h3 id="High-Order-Function-고차-함수-란"><a href="#High-Order-Function-고차-함수-란" class="headerlink" title="High Order Function(고차 함수) 란?"></a>High Order Function(고차 함수) 란?</h3><p>함수를 인수로 취하거나 함수를 결과로 반환할 수 있는 함수를 말합니다</p>
<p>아래 사용되고 있는 예시를 보겠습니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">square</span><span class="params">(x: <span class="type">Int</span>, y: <span class="type">Int</span>, block: (<span class="type">result</span>: <span class="type">Int</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">        block(x * y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">square(<span class="number">4</span>, <span class="number">4</span>) &#123; result -&gt;</span><br><span class="line">	<span class="comment">// result 16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>x, y를 인자를 받고 해당 block이라는 람다식을 invoke 합니다.</li>
<li>선언된 square 함수에서 block 파라미터의 블록에서 결과값을 받을 수 있습니다</li>
</ul>
<p>고차 함수로 람다함수를 파라미터로 넘겨줄 때 과도하게 사용하면 런타임 오버헤드가 발생합니다.<br>그럴때는 inline 키워드를 사용하여 오버헤드를 방지해야 합니다.</p>
<p><a target="_blank" rel="noopener" href="https://kennethss.medium.com/kotlin-%EA%B3%A0%EC%B0%A8%ED%95%A8%EC%88%98%EC%99%80-inline-noinline-crossinline-reified-960f1f1511c2">Medium 글</a></p>
<p>Medium 설명글에 inline에 대해서 작성한 글이 있습니다. 참고해 보시길 바랍니다.</p>
</div></article></div></div><div class="column column-left is-3-tablet is-3-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Your name"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Your name</p><p class="is-size-6 is-block">Your title</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Your location</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">24</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">14</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">10</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/KennethSS" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/KennethSS"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Android/"><span class="level-start"><span class="level-item">Android</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/Android/Compose/"><span class="level-start"><span class="level-item">Compose</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/CS/"><span class="level-start"><span class="level-item">CS</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/CS/Data-Structure/"><span class="level-start"><span class="level-item">Data Structure</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Coroutine/"><span class="level-start"><span class="level-item">Coroutine</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/Coroutine/Flow/"><span class="level-start"><span class="level-item">Flow</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Design-Pattern/"><span class="level-start"><span class="level-item">Design Pattern</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/Design-Pattern/Behavioral/"><span class="level-start"><span class="level-item">Behavioral</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Design-Pattern/Creational/"><span class="level-start"><span class="level-item">Creational</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Kotlin/"><span class="level-start"><span class="level-item">Kotlin</span></span><span class="level-end"><span class="level-item tag">8</span></span></a><ul><li><a class="level is-mobile" href="/categories/Kotlin/Coroutine/"><span class="level-start"><span class="level-item">Coroutine</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/RxJava/"><span class="level-start"><span class="level-item">RxJava</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/RxJava/Transforming/"><span class="level-start"><span class="level-item">Transforming</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/android/"><span class="level-start"><span class="level-item">android</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-02-04T16:46:13.000Z">2023-02-05</time></p><p class="title"><a href="/2023/02/05/%EB%8F%99%EC%8B%9C%EC%84%B1-Concurrency-%EA%B3%BC-%EB%B3%91%EB%A0%AC%EC%84%B1-Parallelism/">동시성(Concurrency)과 병렬성(Parallelism)</a></p><p class="categories"><a href="/categories/CS/">CS</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-02-02T13:01:26.000Z">2023-02-02</time></p><p class="title"><a href="/2023/02/02/Compose-hiltViewModel-%EA%B3%BC-viewModel-%EC%B0%A8%EC%9D%B4/">Compose - hiltViewModel()과 viewModel() 차이</a></p><p class="categories"><a href="/categories/Android/">Android</a> / <a href="/categories/Android/Compose/">Compose</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-02-01T18:27:21.000Z">2023-02-02</time></p><p class="title"><a href="/2023/02/02/%EC%A4%91%EC%9E%AC%EC%9E%90-%ED%8C%A8%ED%84%B4-Mediator-Pattern/">중재자 패턴(Mediator Pattern)</a></p><p class="categories"><a href="/categories/Design-Pattern/">Design Pattern</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-01-30T09:11:03.000Z">2023-01-30</time></p><p class="title"><a href="/2023/01/30/Kotlin-%EB%B6%88%EB%B3%80%EC%84%B1-Immutability-%EA%B3%BC-%EA%B0%80%EB%B3%80%EC%84%B1-Mutability/">Kotlin - 불변성(Immutability)과 가변성(Mutability)</a></p><p class="categories"><a href="/categories/Kotlin/">Kotlin</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-01-29T15:47:52.000Z">2023-01-30</time></p><p class="title"><a href="/2023/01/30/Coroutine-StateFlow%EC%99%80-SharedFlow-%ED%8A%B9%EC%A7%95-%EB%B0%8F-%EC%B0%A8%EC%9D%B4/">Coroutine - StateFlow와 SharedFlow 특징 및 차이</a></p><p class="categories"><a href="/categories/Coroutine/">Coroutine</a> / <a href="/categories/Coroutine/Flow/">Flow</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/02/"><span class="level-start"><span class="level-item">February 2023</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/01/"><span class="level-start"><span class="level-item">January 2023</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/12/"><span class="level-start"><span class="level-item">December 2022</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Android/"><span class="tag">Android</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CS/"><span class="tag">CS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Compose/"><span class="tag">Compose</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Coroutine/"><span class="tag">Coroutine</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Design-Pattern/"><span class="tag">Design Pattern</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Flow/"><span class="tag">Flow</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Kotlin/"><span class="tag">Kotlin</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RxJava/"><span class="tag">RxJava</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/categories/"><span class="tag">categories</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/java/"><span class="tag">java</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe for updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="케니스의 개발 블로그" height="28"></a><p class="is-size-7"><span>&copy; 2023 John Doe</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/KennethSS"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>