{"posts":[{"title":"Android - TextView 자동 크기 조절","text":"Photo by Mel Poole on Unsplash 요구사항안드로이드 개발을 하다가보면 하나의 다음과같은 요구사항이 생기는 상황이 생깁니다. TextView 안에 2줄일 때는 14sp, 텍스트가 만약에 길어질 때는 3줄로 제한하면서 12sp로 변경 이런 요구사항을 어떻게 해결할 수 있을까요? 글자 수 초과 시 텍스트 사이즈를 변경하는 코드를 만들거나 Canvas를 이용해 글자의 범위가 넘어가면 측정하는 로직을 따로 작성할 수 있지만 단순한 동작을 위해 너무 많은 작업이나 코드를 생산하게 되는 일이 발생합니다. 다행히 안드로이드에서는 Android 8.0(API 26)이상을 사용한다면 TextView에 해당 기능을 지원하고 있습니다. 그 이전 버전은 AppCompat을 사용하여 다루어야하고 최소 버전은 4.0(API 14) 이상입니다. 그럼 실제로 어떠한 상황에서 쓰여야하는지 살펴보겠습니다. 위 사진은 29cm의 상품리스트 화면입니다. 상품의 설명으로 커피잔 세트… 으로 간단하게 설명이 되어 있지만 이 TextView에 더 많은 텍스트를 넣기위해 3줄을 허용하게 변경하는 요구사항이 발생할 수 있습니다. 이 경우에 기존 2줄의 높이는 유지하면서 3줄의 조금 더 작은 텍스트사이즈의 설명이 들어가게 하려면 안드로이드에서 제공하는 자동 크기 조절기능을 이용해 해결할 수 있습니다. TextView 자동 크기 조절은 크게 3가지로 나누어 작업할 수 있습니다. 기본 : autoSizeTextType만 지정한 방법 세부사항 : 텍스트의 최소, 최대, 단위를 구성한 방법 미리 정의한 크기 : 텍스트 크기의 배열을 이용한 방법 ⚠️ 텍스트 크기 조절 기능을 이용한다면 TextView의 width, height 속성을 wrap_content 로 지정해서는 안됩니다. 기본기본을 정의하는 방법은 간단합니다. xml에서 autoSizeTextType을 uniform으로 지정하거나 프로그래매틱 방법으로는 TextView의 setAutoSizeTextTypeWithDefaults(int autoSizeTextType) 함수를 호출해서 적용할 수 있습니다. 1234&lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;200dp&quot; android:autoSizeTextType=&quot;uniform&quot; /&gt; 📘 기본값으로 적용되는 텍스트 사이즈는 최소(12sp), 최대(112sp), 단위(1px)로 지정됩니다. 세부사항세부사항을 정의하는 방법은 기본값을 지정하는 방법에 더해서 최소, 최대, 단위를 추가해 구성하는 방법입니다. 1234567&lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;200dp&quot; android:autoSizeTextType=&quot;uniform&quot; android:autoSizeMinTextSize=&quot;12sp&quot; android:autoSizeMaxTextSize=&quot;100sp&quot; android:autoSizeStepGranularity=&quot;2sp&quot; /&gt; 각 옵션들에 대한 설명 autoSizeMinTextSize : 텍스트 사이즈가 조절될 때 최소 사이즈 autoSizeMaxTextSize : 텍스트 사이즈가 조절될 때 최대 사이즈 autoSizeStepGranularity : 텍스트 사이즈 조절 시 사이 단계의 크기 미리 정의한 크기최소, 최대값등을 정의하지 않고도 텍스트 크기 조절을 지정한 사이즈 리스트에만 한정하는 방법이 있습니다. 123456789&lt;resources&gt; &lt;array name=&quot;autosize_text_sizes&quot;&gt; &lt;item&gt;10sp&lt;/item&gt; &lt;item&gt;12sp&lt;/item&gt; &lt;item&gt;20sp&lt;/item&gt; &lt;item&gt;40sp&lt;/item&gt; &lt;item&gt;100sp&lt;/item&gt; &lt;/array&gt;&lt;/resources&gt; 텍스트 크기 변경의 범위를 배열의 형태로 지정합니다. 12345&lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;200dp&quot; android:autoSizeTextType=&quot;uniform&quot; android:autoSizePresetSizes=&quot;@array/autosize_text_sizes&quot; /&gt; autoSizePresetSizes에 배열을 지정합니다. 적용해보기아까의 요구사항을 위의 내용들을 이용해 적용해보겠습니다. 12345678910&lt;TextView android:id=&quot;@+id/content&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;64dp&quot; android:autoSizeTextType=&quot;uniform&quot; android:autoSizeMaxTextSize=&quot;16sp&quot; android:autoSizeMinTextSize=&quot;8sp&quot; android:autoSizeStepGranularity=&quot;1sp&quot; ... /&gt; UI에서 어색하지 않을 정도의 범주로 최대를 16sp, 최소를 8sp로 지정하고 최대한 영역을 활용할 수 있게 단계를 1sp로 지정했습니다. 적용전 적용후(최소) 적용후(최대) 이제 기존 높이에 변화없이 최소, 최대 값을 유지하면서 유연하게 텍스트를 표현할 수 있습니다. 긴 글 읽어주셔서 감사합니다. 🙇‍♂️ 참고 https://developer.android.com/develop/ui/views/text-and-emoji/autosizing-textview","link":"/2023/02/10/Android-TextView-%EC%9E%90%EB%8F%99-%ED%81%AC%EA%B8%B0-%EC%A1%B0%EC%A0%88/"},{"title":"CS - 마샬링(Marshalling) 직렬화(Serialization) 차이","text":"개발자들과 대화에서 마샬링과 직렬화는 어떤 차이가 있는지에 대한 주제가 논의로 발생해서 이에 대해서 궁금증이 생겨 이 두 개의 차이점을 알아보고 정리해보려고합니다. 마샬링이란?위키피디아를 번역한 내용입니다. 미국식 철자는 Marshaling CS에서 __마샬링(Marshalling)__은 파일로 저장하거나 네트워크 전송하기 위해서 객체의 데이터 포맷을 적합한 형태로 변환하여 메모리에 표현하는 과정입니다. 일반적으로 컴퓨터 프로그램에서 서로 다른 파트끼리 데이터를 전달하거나 하나의 프로그램에서 다른 프로그램으로 데이터를 전달할 때 사용됩니다. **마샬링(Marshalling)**은 **직렬화(Serialization)**와 유사하거나 동의어일 수 있습니다. 마샬링은 클라이언트에서 서버에 어떠한 객체를 전달하려는 인텐트나 프로세스로 표현할 수 있습니다. 인텐트는 하나의 실행중인 프로그램에서 동일한 객체를 다른 실행중인 프로그램에도 가지고 있는 것입니다. 즉, 서버에 전송되어 표시되는 객체를 의미합니다. 직렬화는 바이트 스트림을 같은 데이터를 변환하는것에만 관심이 있으므로 인텐트를 가질 필요는 없습니다. 마샬링은 직렬화와 다른 방식으로 수행되지만 직렬화 형식을 일반적으로 사용합니다. 기본 오브젝트(primitives object) 대신 혼합 오브젝트(composite object)를 사용하기 때문에 복잡한 커뮤니케이션을 단순화 할 수 있습니다. 마샬링의 반대되는 개념으로 언마샬링이 있습니다.(언마샬링은 deserialization과 유사합니다)언마샬링 인터페이스는 직렬화된 객체를 가지고와서 내부 데이터 구조로 변경합니다. 마샬링의 정확한 정의는 파이썬, 자바, 닷넷프레임워크등의 다양한 프로그래밍의 언어마다 다르며 일부의 컨텍스트에서는 직렬화와 같은 의미로 사용합니다. 직렬화와 다른점객체를 직렬화한다는 건 객체의 복사본으로 다시 변환할 수 있는 방식으로 바이스 스트림으로 변환하다는 것을 의미합니다. 마샬링이라는 용어는 파이썬 표준 라이브러리에서 내부 파이썬 객체를 저장하는 특수한 유형의 직렬화에 사용됩니다. 마샬링은 원격 호출을 위해 객체를 직렬화할 때 사용됩니다. 마샬링된 객체는 원래 객체의 상태를 코드베이스를 포함하여 기록합니다(코드베이스는 소스코드가 아니라 객체 코드 URL 목록). 따라서 다시 객체 상태와 코드베이스를 변환하려면 언마샬링을 수행해야합니다. 따라서 객체를 “마샬링”한다는 것은 마샬링된 객체가 “비마샬링”될 때 객체의 상태와 코드베이스를 기록하여 원본 객체의 복사본을 얻을 수 있게하는 행위입니다. 차이점마샬링은 객체의 메모리 구조에서 저장 또는 전송에 적합한 다른 데이터 형식으로 변환하는 과정이다. 마샬링은 프로그램간 이동할 때 사용하는 변환 과정이라고 할 수 있다. 이 과정에서 비마샬링할 때 객체의 복사본을 얻을 수 있게 원격 객체의 상태와 코드베이스를 기록한다. 직렬화는 객체의 상태를 저장하기 위해 객체를 바이트 스트림(Byte Stream) 형태로 변환하는 것을 의미한다. 즉 객체에 저장된 데이터를 스트림 형태로 쓰기위해 연속적인 데이터로 변환하는 것이다 마샬링은 직렬화보다 더 큰 개념으로 사용된다. 그래서 직렬화 가능하거나 리모트 가능한 모든 객체는 마샬링이 가능하다. 즉 정리하면 큰 차이는 직렬화는 객체가 대상이고 마샬링은 변환 그 자체의 목적으로 코드베이스를 기록하는데 차이가 있다. 참고 마샬링 - 위키디피아 직렬화 - 위키디피아 Marshalling - Wikipedia","link":"/2023/01/19/CS-%EB%A7%88%EC%83%AC%EB%A7%81-Marshalling-%EC%A7%81%EB%A0%AC%ED%99%94-Serialization-%EC%B0%A8%EC%9D%B4/"},{"title":"Android - is translated here but not found in default locale 이슈","text":"Photo by David Marcu on Unsplash 문제안드로이드에서 string 리소스에 텍스트를 추가하는데 다음과 같은 에러를 발생시킬 때가 있습니다. 1&quot;sample_text&quot; is translated here but not found in default locale 원인해당 린트에러는 번역을 제공하지 않는 Locale에서 문자열을 조회하게 된다면 충돌을 발생할 수 있으니 주의하라는 내용인데요. 어느새 부터 가끔씩 value/strings.xml 파일에서 선언하면 발생했습니다. 현지화 작업을 하지 않는다면 보통은 이 문구를 신경쓰지 않아도 되지만 에러가 신경쓰여서 해결해보려고합니다. 해결 방법들 Android Studio - Preferences - Inspections - Extra translation에서 Severity를 Error가 아닌 다른 형태로 바꾸어 린트 경고를 변경합니다. 간혹 Clean Project 후 에러가 사라지는 경우도 있습니다.","link":"/2023/02/09/Android-is-translated-here-but-not-found-in-default-locale-%EC%9D%B4%EC%8A%88/"},{"title":"Compose - hiltViewModel()과 viewModel() 차이","text":"들어가며최근 컴포즈 스터디모임에서 논의된 내용으로 컴포즈에서 ViewModel을 생성할 때 viewModel()을 이용한 생성과 hiltViewModel()을 이용한 생성이 구체적으로 어떻게 다른지에 대한 논의가 있었습니다. ViewModel을 생성하는 두개의 방법이 어떤 차이가 있는지 알아보겠습니다. 설정1234dependencies { implementation(&quot;androidx.navigation:navigation-compose:2.5.3&quot;) implementation(&quot;androidx.hilt:hilt-navigation-compose:1.0.0&quot;)} ViewModel 생성기존 안드로이드에서 일반적으로 액티비티나 프래그먼트를 이용해 화면 단위를 구성했습니다. 각 컴포넌트에서 ViewModel 생성은 viewModels()와 같은 확장함수를 이용해 간단하게 구현할 수 있습니다. 이렇게 만들어진 ViewModel은 생성된 컴포넌트의 생명주기에 따라 컴포넌트가 완전히 파괴된 이후에 ViewModel도 자연스럽게 소멸됩니다. 그렇다면 컴포즈에서는 어떻게 생성할 수 있을까요? 컴포즈에서는 ViewModel을 생성하는 함수을 제공합니다. 1234@ComposableMainScreen( viewModel: MainViewModel = viewModel()) 내부적인 코드는 다음과 같습니다. 123456789101112131415package androidx.lifecycle.viewmodel.compose@Composablepublic inline fun &lt;reified VM : ViewModel&gt; viewModel( viewModelStoreOwner: ViewModelStoreOwner = checkNotNull(LocalViewModelStoreOwner.current) { &quot;No ViewModelStoreOwner was provided via LocalViewModelStoreOwner&quot; }, key: String? = null, factory: ViewModelProvider.Factory? = null, extras: CreationExtras = if (viewModelStoreOwner is HasDefaultViewModelProviderFactory) { viewModelStoreOwner.defaultViewModelCreationExtras } else { CreationExtras.Empty }): VM = viewModel(VM::class.java, viewModelStoreOwner, key, factory, extras) 컴포저블에서 생성한 ViewModel의 ViewModelStoreOwner의 기본값은 LocalViewModelStoreOwner가 제공해주는데 NavHost 컴포저블 범위가 아니라면 ViewTreeViewModelStoreOwner.get() 함수에 View 파라미터를 전달하여 얻은 ViewModelStoreOwner를 리턴합니다. 이 View는 LocalView.current를 호출해서 가져오는데 코드를 따라가보면 결국 최상위 AndroidComposeView의 View를 얻어옵니다. 1ViewTreeViewModelStoreOwner.get(LocalView.current) 화면 단위 ViewModel 구성이전 내용에서 컴포즈에서 기본 생성자로 생성한 ViewModel은 최상위 AndroidComposeView의 View를 가져와 ViewModelStoreOwner를 지정한다고 얘기했습니다. 즉, 액티비티나 프래그먼트를 생성 후 화면전체의 요소를 컴포즈로 구현하고 확장함수인 viewModels()를 호출하여 ViewModel을 컴포저블에게 전달하거나 컴포저블 함수에서 직접 viewModel()을 호출해도 컴포넌트가 완전히 파괴되기 전까지 동일한 인스턴스를 호출하기 때문에 기존 방법대로 의도하여 동작하게 할 수 있습니다. 하지만 하나의 액티비티안에 컴포즈로만 구현할 때는 화면 단위의 ViewModel의 생성과 소멸을 직접 컨트롤해야하기 때문에 어려움이 따릅니다. 다음 예시를 한번 살펴보겠습니다. 12345678910111213141516override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { Theme { var currentScreen by remember { mutableStateOf(Screen.Home) } Crossfade(targetState = currentScreen) { screen -&gt; when (screen) { Screen.Home -&gt; HomeScreen(onNavigateCategory = { currentScreen = Screen.Category }) Screen.Category -&gt; CategoryScreen(onBackScreen = { currentScreen = Screen.Home }) } } } }} 액티비티에서 Crossfade 컴포저블 함수를 이용하여 2가지의 화면간 전환을 구현한다고 가정했을 때 위와 같은 코드로 작성할 수 있습니다. 그리고 각 화면인 HomeScreen과 CategoryScreen 컴포저블 함수를 구현하고 기본 생성자만 가지고 있는 ViewModel을 정의합니다. 12345678910111213@Composableprivate fun HomeScreen( onNavigateCategory: () -&gt; Unit, homeViewModel: HomeViewModel = viewModel(), categoryViewModel: CategoryViewModel = viewModel()) { Log.d(&quot;HomeScreen&quot;, &quot;HomeViewModel: $homeViewModel&quot;) Log.d(&quot;HomeScreen&quot;, &quot;CategoryViewModel: $categoryViewModel&quot;) Button(onClick = { onNavigateCategory() }) { Text(&quot;Navigate to Category&quot;) }}class HomeViewModel : ViewModel() 12345678910111213@Composablefun CategoryScreen( onBackScreen: () -&gt; Unit, categoryViewModel: CategoryViewModel = viewModel(), homeViewModel: HomeViewModel = viewModel()) { Log.d(&quot;CategoryScreen&quot;, &quot;HomeViewModel: $homeViewModel&quot;) Log.d(&quot;CategoryScreen&quot;, &quot;CategoryViewModel: $categoryViewModel&quot;) Button(onClick = { onBackScreen() }) { Text(&quot;Back&quot;) }}class CategoryViewModel : ViewModel() 해당 코드를 실행해보면 기존 화면에서 ViewModel 인스턴스는 소멸되고 전환된 화면에서 새로운 인스턴스를 기대하지만 동일한 인스턴스를 반환합니다. 이렇게 된다면 비즈니스 로직들을 가지고 있는 VIewModel을 다른 화면에서 재사용하기가 어려워집니다. 1234HomeViewModel: com.kennethss.android.compose.HomeViewModel@ac8887CategoryViewModel: com.kennethss.android.compose.CategoryViewModel@a7973b4HomeViewModel: com.kennethss.android.compose.HomeViewModel@ac8887CategoryViewModel: com.kennethss.android.compose.CategoryViewModel@a7973b4 ViewModel을 재생성 하기위해 화면간 전환 시 LocalViewModelStoreOwner.current?.viewModelStore?.clear()를 호출하여 ViewModel의 인스턴스 전체를 해제하거나 별도의 장치로 부분적으로 해제를 해야합니다. 이런 생성과 소멸에 대한 컨트롤을 구현하려면 많은 보일러플레이트 코드가 생성되고 유지보수가 어렵게됩니다. 이를 해결하기 위해 안드로이드에서는 화면간 전환을 도와주는 Navigation 컴포넌트를 제공하고있고 컴포즈 역시 이를 지원합니다. hiltViewModel()젯팩의 Navigation 컴포넌트는 컴포즈를 지원하여 기존 Navigation 기능들과 인프라들을 활용하여 컴포저블간의 이동을 도와주는 라이브러리입니다. 그리고 의존성 주입 라이브러리인 Hilt도 컴포즈와 원활하게 동작합니다. 이를 이용해서 hiltViewModel()이 동작하는 방법과 viewModel()과 다른점을 살펴보겠습니다. 컴포저블에서 hiltViewModel()을 호출하여 ViewModel을 생성 할 수 있습니다. 12345678910@Composableprivate fun HomeScreen( homeViewModel: HomeViewModel = hiltViewModel() //..) { //..}@HiltViewModelclass HomeViewModel @Inject constructor(): ViewModel() hiltViewModel 내부 코드를 살펴보겠습니다. 1234567891011121314151617181920212223242526package androidx.hilt.navigation.compose@Composableinline fun &lt;reified VM : ViewModel&gt; hiltViewModel( viewModelStoreOwner: ViewModelStoreOwner = checkNotNull(LocalViewModelStoreOwner.current) { &quot;No ViewModelStoreOwner was provided via LocalViewModelStoreOwner&quot; }): VM { val factory = createHiltViewModelFactory(viewModelStoreOwner) return viewModel(viewModelStoreOwner, factory = factory)}@Composable@PublishedApiinternal fun createHiltViewModelFactory( viewModelStoreOwner: ViewModelStoreOwner): ViewModelProvider.Factory? = if (viewModelStoreOwner is NavBackStackEntry) { HiltViewModelFactory( context = LocalContext.current, navBackStackEntry = viewModelStoreOwner )} else { // Use the default factory provided by the ViewModelStoreOwner // and assume it is an @AndroidEntryPoint annotated fragment or activity null} 해당 코드의 주석을 해석해보자면, 현재 내비게이션 그래프에서 백스택에 대한 새로운 ViewModel 스코프를 생성하고 내비게이션 그래프가 없다면 프래그먼트나 액티비티 같은 현재 사용되고 있는 스코프를 전달한다고 작성되어 있습니다. 코드를 보면 createHiltViewModelFactory() 함수를 이용해 별도의 factory를 가져오고 인자로 받은 ViewModelStoreOwner 타입이 NavBackStackEntry일 경우 HiltViewModelFactory() 함수를 호출하고 인자로 전달합니다. 그게 아니라면 null을 리턴하여 컴포즈에서 기본으로 생성할 수 있는 viewModel()호출과 동일한 동작을 합니다. 1234567891011121314151617181920212223242526package androidx.hilt.navigationpublic fun HiltViewModelFactory( context: Context, navBackStackEntry: NavBackStackEntry): ViewModelProvider.Factory { val activity = context.let { var ctx = it while (ctx is ContextWrapper) { if (ctx is Activity) { return@let ctx } ctx = ctx.baseContext } throw IllegalStateException( &quot;Expected an activity context for creating a HiltViewModelFactory for a &quot; + &quot;NavBackStackEntry but instead found: $ctx&quot; ) } return HiltViewModelFactory.createInternal( activity, navBackStackEntry, // SavedStateRegistryOwner로 치환 navBackStackEntry.arguments, // Bundle 객체 navBackStackEntry.defaultViewModelProviderFactory, //ViewModelProvider.Factory )} 결국 이렇게 전달받은 Context와 NavBackStackEntry는 HiltViewModelFactory클래스에서 Factory을 생성하기 위해 사용합니다. 123456@Composableinline fun &lt;reified VM : ViewModel&gt; hiltViewModel( viewModelStoreOwner: ViewModelStoreOwner = checkNotNull(LocalViewModelStoreOwner.current) { &quot;No ViewModelStoreOwner was provided via LocalViewModelStoreOwner&quot; }): VM 다시 hiltViewModel() 로 돌아가면 LocalViewModelStoreOwner.current는 ViewModelStoreOwner를 리턴하는데 current를 제공해주는 오브젝트는 NavHost에서 화면이 전환될 때 마다 NavBackStackEntry의 확장함수인 LocalOwnersProvider를 호출하여 CompositionLocal를 이용해 NavBackStackEntry를 전달하고 결과적으로 ViewModel은 NavBackStackEntry의 스코프를 가지게됩니다. 1234567891011@Composablepublic fun NavBackStackEntry.LocalOwnersProvider( // ..) { CompositionLocalProvider( LocalViewModelStoreOwner provides this, // .. ) { // .. }} NavGraph에서 ViewModel 인스턴스 유지Navigation 컴포즈를 사용할 때 로그인이나 회원가입 흐름에서 화면 단위로 공통된 ViewModel 인스턴스를 유지해야 하는 경우도 발생합니다. 이 경우 기존 Fragment에서는 activityViewModels()을 활용해 유지했다면 컴포즈 내비게이션에서는 hiltViewModel()을 이용해 ViewModel 인스턴스를 유지할 수 있습니다. 12345678910111213composable( route = &quot;category&quot; ..) { backStackEntry -&gt; val parentEntry = remember(backStackEntry) { navController.getBackStackEntry(&quot;home&quot;) } CategoryScreen( categoryViewModel = hiltViewModel(parentEntry) )} CategoryScreen에서 뒤로가기를 눌러 HomeScreen으로 이동해도 CategoryViewModel의 인스턴스는 유지됩니다. 결론viewModel()과 hiltViewModel()의 가장 큰 차이는 NavBackStackEntry의 사용 여부라고 볼 수 있습니다. 왠지navViewModel과 같은 네이밍이 떠오르지만 HiltViewModelFactory를 이용해 Factory를 생성한다는 점에서 hiltViewModel() 이름을 짓지 않았을까 라고 추측해봅니다. 🧐 지금까지 긴 글 읽어주셔서 감사합니다. 🙇‍♂️ 참고 Type safety in Kotlin DSL and Navigation Compose Compose and other libraries","link":"/2023/02/02/Compose-hiltViewModel-%EA%B3%BC-viewModel-%EC%B0%A8%EC%9D%B4/"},{"title":"Coroutine - StateFlow와 SharedFlow 특징 및 차이","text":"들어가며안드로이드 개발을 하다보면 상태와 이벤트처리를 해야합니다. 기존에는 LiveData, SingleLiveData를 활용해서 View의 상태를 업데이트하거나 이벤트를 전달하는 방법을 제공했습니다. 하지만 LiveData를 도메인 레이어안에서 플랫폼 독립적으로 사용하려고 한다면 안드로이드 의존성 때문에 어려움이 생깁니다. 이전 RxJava를 많이 사용하던 시절에는 RxJava/Kotlin의 Hot Stream인 Subject인 BehaviorSubject를 이용해 상태를 관리하여 안드로이드 플랫폼에 독립적으로 사용했습니다. 그러나 이제는 안드로이드 앱들이 Kotlin으로만 작성되고 있어 RxJava/Kotlin의 의존성없이 Kotlin 코루틴의 Flow를 사용해서 데이터 스트림을 구현할 수 있습니다. Flow는 기본적으로 Cold Stream 이지만 이를 Hot Stream으로 사용할 수 있는 Flow가 StateFlow , SharedFlow 입니다. 이 중 최신 상태를 관리하고 전달해 주는 StateFlow의 특징에 대해서 먼저 알아보겠습니다. StateFlowStateFlow는 컬렉터에게 단일의 최신 데이터 값만 업데이트를 보장하는 핫 플로우입니다. StateFlow의 특징은 초기값 가지며 emit() 혹은 value 로 프로퍼티에 접근할 수 있습니다. 또한 이전에 내보낸 값과 동일한 값을 소비자에게 전달하지 않도록 distinctUntilChanged()와 같은 연산자의 기능을 가지고 있습니다. 📘 StateFlow는 Any.equals를 이용해서 이전에 내보낸 값과 동일한 값인지 비교하고 결합합니다. Any.equals의 규칙을 따르지 않은 클래스는 StateFlow에서 의도된 동작을 보장하지 못합니다. 12345private val _stateFlow = MutableStateFlow(0)val stateFlow = _stateFlow.asStateFlow() // ready-only_stateFlow.emit(1)_stateFlow.value = 1 StateFlow는 항상 최신의 값을 가져오기 때문에 최신 상태를 유지하는 데이터 홀더로써 사용이 권장됩니다 SharedFlowSharedFlow도 마찬가지로 Hot Flow로 애플리케이션에서 구독자들에게 이벤트를 전달하는 목적으로 사용합니다. SharedFlow의 생성은 MutableSharedFlow() 생성자 함수로 만들 수 있습니다. 파라미터가 없는 기본 생성자로 만들 수도 있지만 아래와 같은 파라미터로 SharedFlow의 옵션들을 설정할 수 있습니다. replay : 새로운 구독자에게 이전 이벤트를 전달할 개수 extraBufferCapacity : 추가적인 버퍼를 생성하고 emit 한 데이터를 버퍼에 유지 onBufferOverflow : 버퍼가 가득찬 경우 어떤 동작을 할지 정의 SharedFlow는 replay cache에서 가장 최신의 값들을 가지며 새로운 구독자가 생겼을 때 가장 먼저 replay cache에서 데이터를 가져오고 이후 새로 emit된 값을 가져옵니다. replay cache는 resetReplayCache()함수로 재설정할 수 있습니다. 또한 replay cache는 버퍼를 제공하는데 뒤늦게 구독한 구독자가 일시 중단하지 않고 버퍼에서 값을 가져올 수 있도록 도와줍니다. 이러한 버퍼 값은 SharedFlow를 생성할 때 extraBufferCapacity 변수를 사용하여 추가 버퍼를 예약하여 사용할 수 있으며 이렇게 설정한 버퍼 공간은 앞서 구독한 구독자와 뒤늦게 구독한 구독자와의 데이터 지연의 정도를 결정합니다. SharedFlow의버퍼사이즈는 replay와 extraBufferCapacity를 합친 값으로 정의되므로 buffer를 사용하기 위해서는 extraBufferCapacity 값을 1이상으로 설정해주어야합니다. 하지만 이렇게 설정한 버퍼도 용량이 가득차게 된다면 오버플로에 맞는 전략을 수립해야합니다. SharedFlow에서 적용 가능한 BufferOverFlow는 3가지를 제공합니다. BufferOverflow.SUSPEND : 버퍼가 가득찼을 때 업스트림인 send()나 emit()이 blocking 됩니다. BufferOverflow.DROP_OLDEST : 가장 오래된 값을 버리고 새로운 값을 추가합니다. BufferOverflow.LATEST : 최신 값을 버리고 새로운 값을 추가합니다. 📘 버퍼 오버플로는 새로운 값을 받을 준비가 안된 최소 하나의 구독자가 있을 때만 발생합니다. 구독자가 하나도 없는 경우에는 최근의 replay value만 저장되며 오버플로는 트리거되지 않으며 만약 BufferOverFlow.SUSPEND, BufferOverFlow.DROP_LATEST 사용에도 blocking 되지 않습니다. 기본적으로 SharedFlow는 매개변수 없는 생성자 함수로 생성시 replay cache나 buffer가 없는 StateFlow를 만들 수 있습니다. 이런 경우에 emit()함수를 호출하면 구독자가 값을 받을 때 까지 일시중단하며 구독자가 없는 경우는 즉시 리턴합니다. 1234override suspend fun emit(value: T) { if (tryEmit(value)) return // fast-path emitSuspend(value)} SharedFlow의 내부 코드를 살펴보면 emit() 함수는 tryEmit()함수가 true라면 리턴하게 되어있습니다. 12345678910111213override fun tryEmit(value: T): Boolean { var resumes: Array&lt;Continuation&lt;Unit&gt;?&gt; = EMPTY_RESUMES val emitted = synchronized(this) { if (tryEmitLocked(value)) { resumes = findSlotsToResumeLocked(resumes) true } else { false } } for (cont in resumes) cont?.resume(Unit) return emitted} 따라서 tryEmit()은 구독자가 없는 경우라면 true를 반환하는 것을 알 수 있습니다. (이 경우 내보내려고 한 값은 즉시 손실됩니다) SharedFlow를 이용해서 안드로이드에서 이벤트를 전파하는 코드는 다음과 같습니다. 안드로이드에선 일반적으로 ViewModel에서 해당코드를 작성하게 됩니다. 12345678910private val _events = MutableSharedFlow&lt;Event&gt;( replay = 0, extraBufferCapacity = 1, onBufferOverflow = BufferOverflow.SUSPEND)val events = _events.asSharedFlow()suspend fun sendEvent(event: Event) { _events.emit(event)} StateFlow와 SharedFlow의 계층 구조는 다음과 같습니다. 마무리StateFlow와 SharedFlow 모두 각각의 특징을 가지고 있어 이러한 Hot Flow들을 적절히 활용하면 직관적이고 간결한 코드를 작성할 수 있습니다. 참고 Reactive Streams on Kotlin: SharedFlow and StateFlow kotlinx.coroutines - SharedFlow kotlinx.coroutines - StateFlow StateFlow 와 SharedFlow - Myungpyo Shim","link":"/2023/01/30/Coroutine-StateFlow%EC%99%80-SharedFlow-%ED%8A%B9%EC%A7%95-%EB%B0%8F-%EC%B0%A8%EC%9D%B4/"},{"title":"Github 블로그 만들기 with Hexo - 1","text":"","link":"/2022/12/15/Github-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0-with-Hexo-1/"},{"title":"Kotlin 1.8.0 업데이트 요약","text":"코틀린 1.8.0 버전이 2022년 12월 28일에 정식으로 출시되었습니다. 새로운 코틀린 버전이 출시되면서 어떤 부분이 변경되었는지 업데이트를 요약해 보았습니다. IDE 지원 kotlin-reflect 성능 개선 최적화 비활성화를 위한 컴파일러 옵션 JVM 컴파일 Target 업데이트 Java에서 Kotlin으로 TimeUnit 전환 Gradle 7.2 &amp; 7.3 Lombok @Builder 어노테이션 지원 코틀린 멀티플랫폼 : 새로운 안드로이드 소스세트 레이아웃 기타 IDE 지원코틀린 1.8.0 플러그인은 아래 IDE 버전에서 사용할 수 있습니다. IDE Supported versions IntelliJ IDEA 2021.3, 2022.1, 2022.2 Android Studio Electric Eel (221), Flamingo (222) kotlin-reflect 성능 개선kotlin-reflect가 JVM target 1.8로 컴파일 된다는 이점을 활용하여 내부 캐시 메커니즘을 Java의 ClassValue로 마이그레이션 하면서 기존에만 캐싱하던 KClass와 더불어 이제는 KType 그리고 KDeclarationContainer까지 캐싱됩니다. 이러한 변경으로 typeOf()가 호출할 때 큰 성능 향상을 가져갈 수 있습니다. 최적화 비활성화를 위한 컴파일러 옵션코틀린 1.8.0에서는 더 나은 디버깅 환경을 위해 최적화 옵션을 비활성화하는 -Xdebug 컴파일러 옵션이 추가되었습니다. 이 옵션을 활성화하면 코루틴의 was optimized out기능이 비활성화 됩니다. 앞으로는 더 많은 최적화를 비활성화 할 수 있는 옵션들이 추가될 예정입니다. was optimized out은 일시 중단 함수를 사용할 때 변수들을 최적화하는 기능입니다. 하지만 최적화된 변수를 볼 수 없어 코드를 디버깅 하기에는 어려움이 따릅니다. -Xdebug 를 통해 이 기능을 비활성화 하면 메모리 누수가 발생할 수 있으므로 이 옵션은 프로덕션에서는 절대 사용해서는 안됩니다. JVM 컴파일 Target 업데이트Kotlin 1.8.0 버전부터 코틀린 컴파일러는 JVM 버전 19를 지원합니다. 기존에 JVM target 1.6에서 컴파일되었던 코틀린 표준 라이브러리(kotlin-stdlib, kotlin-reflect, and kotlin-script-*)가 JVM target 1.8로 컴파일 됩니다. 또한 코틀린 1.8.0에서는 JVM target 1.6 그리고 1.7을 지원하지 않습니다. 결과적으로 이러한 아티팩트들이 kotlin-stdlib로 병합되기 때문에 빌드 스크립트를 더 이상 kotlin-stdlib-jdk7 and kotlin-stdlib-jdk8을 분리해서 선언하지 않아도 됩니다. :blue_book: 빌드 스크립트에서 kotlin-stdlib-jdk7 이나 kotlin-stdlib-jdk8 이 명시적으로 선언되어있는 경우 kotlin-stdlib로 바꿔야 합니다. 서로 다른 버전의 코틀린 표준 라이브러리를 섞어서 사용한다면 클래스가 중복되거나 누락될 가능성이 있습니다. 이를 방지하기 위해 Kotlin Gradle 플러그인을 사용하면 표준 라이브러리 정렬에 도움이 됩니다. Java에서 Kotlin으로 TimeUnit 전환Kotlin 1.6.0에서 실험적이었던 toTimeUnit() 그리고 toDurationUnit()기능들은 kotlin.time 패키지에서 스테이블 되었습니다. 이 함수들은 Java와 Kotlin의 상호운용성을 향상시키며 이제는 Java의 java.util.concurrent.TimeUnit을 Kotlin의 kotlin.time.DurationUnit으로 쉽게 전환할 수 있습니다. 이 함수들은 JVM에서만 지원합니다. Gradle 7.2 &amp; 7.3코틀린 1.8.0은 Gradle 버전 7.2와 7.3을 완전히 지원합니다. Gradle 최소 지원 버전은 6.8.3 이며 Android Gradle 플러그인은 4.1.3 입니다. Gradle 버전을 최신 릴리즈 버전까지 사용할 수 있으나 지원 중단 경고가 표시되거나 새로운 Gradle 기능이 동작하지 않을 수도 있습니다. Lombok @Builder 어노테이션 지원많은 커뮤니티에서 코틀린 Lombok의 @Builder 어노테이션을 지원해달라는 요청이 많았고 1.8.0부터는 해당 어노테이션을 지원합니다. Lombok을 사용하려면 gradle 플러그인을 추가해야 합니다. 1234plugins { kotlin(&quot;plugin.lombok&quot;) version &quot;1.8.0&quot; id(&quot;io.freefair.lombok&quot;) version &quot;5.3.0&quot;} 아직 @SuperBuilder 혹은 @Tolerate 어노테이션을 지원할 계획은 없지만 많은 사람들의 요구가 있을 때 고려해볼 수 있습니다. 코틀린 멀티플랫폼 : 새로운 안드로이드 소스세트 레이아웃코틀린 1.8.0부터는 여러 면에서 혼란스러웠던 디렉터리들의 네이밍 스키마들을 대체하는 새로운 안드로이드 소스세트 레이아웃 도입되었습니다. AndroidTest 디렉터리를 예로 들면 하나는 KotlinSourceSets이었고 다른 하나는 AndroidSourceSets 였습니다. 코틀린의 androidTest는 unitTest 형태를 의미하지만 안드로이드 진영에서는 interationTest를 의미합니다. src/androidTest/java는 UnitTest가 있고 src/androidTest/kotlin는 InstrumentedTest가 있는 혼란스러운 SourceDirectories 레이아웃을 만듭니다. KotlinSourceSets 그리고 AndroidSourceSets 모두 Gradle 구성에 비슷한 네이밍 스키마를 사용하므로 androidTest의 결과 구성들은 androidTestImplementation, androidTestApi, androidTestRuntimeOnly 그리고 androidTestCompileOnly 와 같습니다. KotlinSourceSet 네이밍 스키마 현재 소스 세트 레이아웃 새로운 소스 세트 레이아웃 targetName + AndroidSourceSet.name targetName + AndroidVariantType 현재 소스 세트 레이아웃 새로운 소스 세트 레이아웃 main androidMain androidMain test androidTest androidUnitTest androidTest androidAndroidTest androidInstrumentedTest SourceDirectories 현재 소스 세트 레이아웃 새로운 소스 세트 레이아웃 The layout adds additional /kotlin SourceDirectories src/{AndroidSourceSet.name}/kotlin, src/{KotlinSourceSet.name}/kotlin 현재 소스 세트 레이아웃 새로운 소스 세트 레이아웃 main src/androidMain/kotlin, src/main/kotlin, src/main/java src/androidMain/kotlin, src/main/kotlin, src/main/java test src/androidTest/kotlin, src/test/kotlin, src/test/java src/androidUnitTest/kotlin, src/test/kotlin, src/test/java androidTest src/androidAndroidTest/kotlin, src/androidTest/java src/androidInstrumentedTest/kotlin, src/androidTest/java, src/androidTest/kotlin AndroidManifest.xml 파일 위치 현재 소스 세트 레이아웃 새로운 소스 세트 레이아웃 src/{AndroidSourceSet.name}/…Manifest.xml src/{KotlinSourceSet.name}/…Manifest.xml 현재 소스 세트 레이아웃 새로운 소스 세트 레이아웃 main src/main/AndroidManifest.xml src/androidMain/AndroidManifest.xml debug src/debug/AndroidManifest.xml src/androidDebug/AndroidManifest.xml 기타 Xcode 14.1 지원 Objective-C/Swift 와의 상호운용성 향상 CocoaPods Gradle 플러그인에서 Dynamic frameworks를 기본으로 연결 지금까지 긴 글 읽어 주셔서 감사합니다. :bow: 참고 Kotlin 1.8.0","link":"/2023/01/27/Kotlin-1-8-0-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-%EC%9A%94%EC%95%BD/"},{"title":"Kotlin - Type alias와 Inline class","text":"❓ 이 글은 Kotlin 공식 문서를 번역과 함께 추가 첨언한 글입니다. alias는 사전상의 의미로 가명, ~라는 가명으로 알려진의 뜻으로 정의되어있습니다. 코틀린에서 Type aliase는 제네릭 타입의 컬렉션 쓸 때 이름이 길게 된다면 짧은 이름으로 줄여서 사용할 수 있게 별명을 지어주는 것을 가능하게 해줍니다. 123typealias NodeSet = Set&lt;Network.Node&gt;typealias FileTable&lt;K&gt; = MutableMap&lt;K, MutableList&lt;File&gt;&gt; 또한 고차 함수 형태도 짧은 이름으로 지어서 사용할 수 있습니다 123typealias MyHandler = (Int, String, Any) -&gt; Unittypealias Predicate&lt;T&gt; = (T) -&gt; Boolean 클래스 내부의 Inner class의 정보를 줄일 때도 사용할 수 있습니다. 123456789class A { inner class Inner}class B { inner class Inner}typealias AInner = A.Innertypealias BInner = B.Inner Type aliases는 새로운 타입을 생성하기 위해 사용하는것이 아니라 기본적인 타입들을 동등하게 이해시키기 위해서 사용합니다. 만약 typealias Predicate&lt;T&gt; 를 추가하고 Predicate를 코드에서 사용한다면 코틀린 컴파일러 (Int) -&gt; Boolean으로 확장합니다. 따라서 일반적인 함수 유형을 변수 타입에 맞게 전달할 수 있고 그 반대도 마찬가지로 가능합니다. 1234567891011121314typealias Predicate&lt;T&gt; = (T) -&gt; Booleanfun foo(p: Predicate&lt;Int&gt;) = p(42)fun main() { val f: (Int) -&gt; Boolean = { it &gt; 0 } println(foo(f)) // prints &quot;true&quot; val p: Predicate&lt;Int&gt; = { it &gt; 0 } println(listOf(1, -2).filter(p)) // prints &quot;[1]&quot;}// Result// true// [1] Type Alias는 클래스 혹은 함수 내부에서 정의하는 것은 불가능하며 Top level에서 변수로 정의해야 합니다. Top level에서 선언한 Type alias는 Public이기 때문에 internal로 사용범위를 모듈로 제한한다고 해도 모듈안에서는 누구나 접근 가능하기 때문에 꼭 필요한 곳에 명세하여 사용해야 합니다. Type alias에 대해서 정리하면 유의미한 이름을 정의해서 사용하면 코드의 가독성을 증가시킬 수 있음 반대로 명확하지 않고 명세나 정의되지 않은 typealias는 오히려 사용성을 저하시킬 수 있음 typealias는 Top level에서만 선언이 가능하기 때문에 여러 곳에서 접근이 가능 Inline classesType alias와 같이 언급되는 Inline class가 있습니다. Inline class가 어떤 것인지 살펴보겠습니다. 비즈니스 로직을 작성하기위해 어떤 타입으로 감싸는 Wrapper를 작성하는 경우가 있습니다. 예를 들어 단순히 Price를 표시하기 위해 Int 형태의 Primitive 타입으로 작성할 수도 있지만 도메인을 조금 더 잘 표현하기 위해 의미를 부여하기 위해서 SalePrice 타입으로 표현할 수 있습니다. 1234567data class Item( val salePrice: Int)data class Item( val salePrice: SalePrice)data class SalePrice(val price: Int) 하지만 SalePrice와 같은 Wrapper는 Heap영역에 할당되면서 런타임 오버헤드가 발생합니다. 만약 Wrapping된 대상이 Primitive 타입이라면 보통 받을 수 있는 런타임에 최적화를 받지 못해 런타임 성능을 더 악화시킵니다. 이 문제를 해결하기 위해 코틀린에서는 특별한 클래스인 인라인 클래스를 제공합니다. 인라인 클래스는 value 기반 클래스 하위의 집합으로 어떠한 식별자를 가지지 않고 값만 보유하고 있습니다. 인라인 클래스는 클래스 이름 앞에 value 한정자를 사용해서 선언할 수 있습니다. 1value class Password(private val s: String) JVM 백엔드에서 인라인 클래스 선언은 value 한정자 위에 @JvmInline 어노테이션을 선언해야합니다. :warning: 인라인 클래스의 inline 한정자는 더 이상 사용되지 않습니다. 인라인 클래스는 생성자에서 초기화된 단일 프로퍼티만 가질 수 있습니다. 인라인 클래스의 인스턴스는 런타임시에 단일 프로퍼티로 변경되어 표시됩니다. 123// 실제로 Password 클래스의 인스턴스화는 발생하지 않습니다.// 런타임에는 'securePassword' 는 단순히 String만 가집니다.val securePassword = Password(&quot;Don't try this in production&quot;) 이게 인라인 클래스의 핵심 기능이며 클래스의 데이터를 inlined 한다는 관점에서 inline 함수를 호출하는 방식과 유사해서 해당 방식에 영감을 받아 인라인 클래스라는 이름이 붙여지게 되었습니다. Members인라인 클래스는 일반적인 클래스의 기능들을 제공합니다. init 블록을 가질 수 있고 프로퍼티와 함수 또한 선언이 가능합니다. 내부 변수는 backing field를 가질 수 있지만 인라인 클래스의 프로퍼티는 backing field를 가질 수 없으며 간단한 연산가능한 프로퍼티로만 가져야합니다(lateinit과 delegated 프로퍼티도 안됨) 12345678910111213141516171819@JvmInlinevalue class Name(val s: String) { init { require(s.length &gt; 0) { } } val length: Int get() = s.length fun greet() { println(&quot;Hello, $s&quot;) }}fun main() { val name = Name(&quot;Kotlin&quot;) name.greet() // method `greet` is called as a static method println(name.length) // property getter is called as a static method} Inheritance인라인 클래스는 인터페이스 상속이 가능하지만 항상 final 이어야 하기 때문에 다른 클래스로 확장하거나 상속할 수 없습니다. 12345678910111213interface Printable { fun prettyPrint(): String}@JvmInlinevalue class Name(val s: String) : Printable { override fun prettyPrint(): String = &quot;Let's $s!&quot;}fun main() { val name = Name(&quot;Kotlin&quot;) println(name.prettyPrint()) // Still called as a static method} Representation컴파일러는 생성된 코드에서 인라인 클래스의 wrapper 형태를 유지합니다. 따라서 인라인 클래스는 런타임에 Primitive 타입이나 wrapper 모두 표현할 수 있습니다. 이것은 Kotlin의 Int 클래스가 Primitive 타입인 int 나 Wrapper인 Integer 클래스로 표현하는 방법과 같습니다. 코틀린 컴파일러는 성능이 우수하거나 최적화된 코드를 생성하기 위해 wrapper 대신 기본 타입을 선호하지만 wrapper 형태의 유지를 필요할 때도 있습니다. 일반적으로 인라인 클래스는 다른 유형으로 사용될 때마다 자동으로 boxed, unboxed 되기 때문에 기본 값과 wrapper 모두를 참조 동등성을 비교하는 것은 의미가 없습니다. 123456789101112131415161718192021222324interface I@JvmInlinevalue class Foo(val i: Int) : Ifun asInline(f: Foo) {}fun &lt;T&gt; asGeneric(x: T) {}fun asInterface(i: I) {}fun asNullable(i: Foo?) {}fun &lt;T&gt; id(x: T): T = xfun main() { val f = Foo(42) asInline(f) // unboxed: used as Foo itself asGeneric(f) // boxed: used as generic type T asInterface(f) // boxed: used as type I asNullable(f) // boxed: used as Foo?, which is different from Foo // 'f'가 먼저 boxed('id'로 전달되는 동안)되고 이후에 unboxed('id'에서 반환될 때) // 결국 'c'는 unboxed된(단지 42의 값) f를 가집니다. val c = id(f)} 인라인 클래스는 제네릭 타입 파라미터를 기본 타입으로 가질 수 있습니다. 아래 케이스에서는 컴파일러가 Any?로 맵하거나 일반적으로 타입 파라미터의 상한하는 경우입니다. 1234@JvmInlinevalue class UserId&lt;T&gt;(val value: T)fun compute(s: UserId&lt;String&gt;) {} // compiler generates fun compute-&lt;hashcode&gt;(s: Any?) :warning: 제네릭 인라인 클래스는 실험 기능입니다. 언제든지 버려질 수 있으며 -language-version 1.8 컴파일러 옵션이 요구됩니다. Managling인라인 클래스는 Primitive타입으로 컴파일되므로 시그니처 충돌이라든지 예상하지 못한 오류를 마주할 수 있습니다. 12345678@JvmInlinevalue class UInt(val x: Int)// Represented as 'public final void compute(int x)' on the JVMfun compute(x: Int) { }// Also represented as 'public final void compute(int x)' on the JVM!fun compute(x: UInt) { } 이런 문제를 해결하기 위해 인라인 클래스를 사용하는 함수는 함수 이름안에 정적인 해시코드를 추가하여 public final void compute-hashcode(int x) 처럼 지저분하게 표현됩니다. 📘 mangling 스키마는 1.4.30 부터 변경되었습니다. 컴파일러 플래그에 -Xuse-14-inline-classes-mangling-scheme를 사용하여 컴파일러가 1.4.0 mangling 방식을 사용하여 바이너리 호환성을 유지하도록 합니다. Java 코드에서 호출Java 코드에서도 인라인 클래스를 허용하는 함수를 호출할 수 있습니다. 이렇게 하려면 함수 선언 앞에 @JvmName 어노테이션을 추가해서 mangling을 수동으로 비활성화해야합니다. 1234567@JvmInlinevalue class UInt(val x: Int)fun compute(x: Int) { }@JvmName(&quot;computeUInt&quot;)fun compute(x: UInt) { } Inline classes and delegation인라인 클래스에서 인터페이스로 인라인 프로퍼티 값에 대한 delegate 구현은 허용됩니다. 12345678910111213141516interface MyInterface { fun bar() fun foo() = &quot;foo&quot;}@JvmInlinevalue class MyInterfaceWrapper(val myInterface: MyInterface) : MyInterface by myInterfacefun main() { val my = MyInterfaceWrapper(object : MyInterface { override fun bar() { // body } }) println(my.foo()) // prints &quot;foo&quot;} Inline classes vs type alias인라인 클래스와 type alias는 타입에 대해서 새로운 타입으로 변경하고 런타임에 원래 타입으로 변경되어 사용된다는 점은 동일합니다. 하지만 이 둘의 차이점은 분명히 있습니다. type aliases는 기존 타입에 별칭을 붙여 완벽하게 호환하는 것인 반면 인라인 클래스는 새로운 타입을 생성하는 것으로 기존 타입과 구분되어 호환되지 않습니다. 123456789101112131415161718192021typealias NameTypeAlias = String@JvmInlinevalue class NameInlineClass(val s: String)fun acceptString(s: String) {}fun acceptNameTypeAlias(n: NameTypeAlias) {}fun acceptNameInlineClass(p: NameInlineClass) {}fun main() { val nameAlias: NameTypeAlias = &quot;&quot; val nameInlineClass: NameInlineClass = NameInlineClass(&quot;&quot;) val string: String = &quot;&quot; acceptString(nameAlias) // OK: 기존 타입 대신에 alis를 넘겨주어도 됨 acceptString(nameInlineClass) // Not OK: 기존 타입 대신에 인라인 클래스는 넘길 수 없음 // And vice versa: acceptNameTypeAlias(string) // OK: alias 대신에 기본 타입을 넘길 수 있음 acceptNameInlineClass(string) // Not OK: 기존 타입 대신에 인라인 클래스는 넘길 수 없음} 지금까지 type alias와 Inline class에 대해서 알아보았습니다. 정리하자면 도메인에서 비즈니스 로직을 감싸기 위해 사용하는 Wrapper는 오버헤드가 발생할 수 있으니 Inline class를 활용해서 작성하면 좋을 것 같고 type alias 같은 경우는 복잡한 형태의 중첩된 제너릭을 사용해서 도메인으로서 사용하는 자료구조의 이름이 복잡할 때 컨벤션을 정해서 이름을 줄여 사용하면 유용해 보입니다. 참고 Kotlin - Type aliases Kotlin - Inline classes Taehwan - Kotlin typealias와 inline class를 알아보고 적절한 사용법을 알아보자. 쾌락코딩 - Kotlin Inline class","link":"/2023/01/28/Kotlin-Type-alias%EC%99%80-Inline-class/"},{"title":"Kotlin - 불변성(Immutability)과 가변성(Mutability)","text":"불변성(Immutability)과 가변성(Mutability)불변성이란 무엇일까?함수형 프로그래밍에서는 불변성을 중요하게 생각합니다. 코틀린은 함수형 프로그래밍을 지원하는 언어로 불변성을 강제하지않고 가변을 허용하지만 불변성을 권장하고 있습니다. 불변성(Immutability)이란 함수형 프로그램에서 중요하게 다루는 부분으로 보통의 의미는 상태를 변경하지 않는 것으로 정의됩니다. 그렇다면 상태를 변경하는 것은 프로그램의 변수를 변경하거나 재할당하는 행위라고 볼 수 있지만 더 근본적으로는 컴퓨터에 저장된 메모리의 특정 공간에 저장된 값을 변경하는 행위를 의미합니다. 이런 행위는 어떤 문제가 생기길래 코틀린에서 불변성을 권장할까요? 가변성(Mutability)의 문제불변성과 반대로 가변성은 상태를 가지는 경우를 얘기합니다. 만약 상태를 가지면 어떤 문제점들이 발생할까요? 앞서 상태를 변경하는 행위는 메모리의 저장된 값을 변경하는 행위라고 언급했습니다. 이렇게 메모리에 저장된 하나의 값을 누구든지 변경할 수 있다는 것은 무분별한 상태가 변경이 된다는 것을 의미합니다. 무분별한 상태가 변경이 되는 것은 다음과 같은 문제를 발생 시킬 수 있습니다. 멀티스레드에서 값을 보장하지 못함 값의 예측이 어렵고 변경에 있어서 위험하다 테스트와 디버깅이 어려움 상태 변경 발생 시 처리를 해주어야함 불변성(Immutability)을 지켜야 하는 이유불변성이란 값이나 상태를 변경할 수 없는 것으로 정의됩니다. 불변 객체는 생성 시점 이후 한 번 정의된 상태는 계속 유지하며 변경되지 않으므로 스레드 간 안전성이 보장되며 이를 통해 동기화 문제를 해결할 수 있습니다. 그리고 한 번 생성한 값은 변경되지 않으므로 캐시도 수월합니다. 또한 기존 객체에서 프로퍼티가 변경된 객체를 리턴 받고자 할 때 방어적 복사본을 작성하지 않아도됩니다. 스레드 안전성(thread-safe) 캐시가 쉬움 방어적 복사본이나 깊은 복사를 하지 않아도됨 사이드 이펙트를 줄임 Kotlin에서는 가변성을 어떻게 제한하고 있을까?코틀린에서는 크게 3가지로 가변성을 제한하고 있습니다. 읽기 전용 프로퍼티 val Mutable 컬렉션과 read-only 컬렉션 구분 data class의 copy() Kotlin에서 불변 객체 사용과 데이터의 변경코틀린에서는 value를 의미하는 읽기 전용 프로퍼티인 val 를 이용해 불변 변수를 사용할 수 있습니다. 123456789101112131415class Play { val count = 0 val countStr: String = &quot;Count&quot; get() { return &quot;$field ${++count}&quot; } fun addedCount() { println(&quot;Added Count: $countStr&quot;) } // &quot;Added Count: Count 0&quot; // &quot;Added Count: Count 1&quot;} 그치만 val는 완전한 불변이아닌 불변성에 가깝습니다. 그 이유는 countStr 변수에 backing field를 사용하여 호출할 때 마다 변경된 값을 리턴할 수 있기 때문입니다. 완전한 불변성으로 강제하는 방법은 const val를 사용하여 컴파일 타임 상수를 가지는 것입니다. 코틀린에서 불변성의 종류는 참조 불변성, 불변 값 두 가지가 존재합니다. 불변 값은 const val을 통해 제공합니다. 참조 불변성 같은 경우 val를 제공하여 참조가 할당되었을 때 다시 할당할 수 없게 합니다. Collection의 MutableList를 예로 들어본다면 123456789fun main() { val list = mutableListOf(1, 2, 3) println(list) // [1, 2, 3] list.add(4) println(list) // [1, 2, 3, 4] val anotherList = mutableListOf(4, 5, 6) list = anotherList // 컴파일 에러} 참조 불변성에 의하면 list는 값이 변경되어야 하지 않아야할텐데 변경이 일어났습니다. 이는 val 속성이 불변 참조를 하므로 실제 List의 인스턴스는 변하지 않았고 MutableList의 내부의 값만 변경되었기 때문에 에러가 발생하지 않습니다. 또한 코틀린은 컬렉션에 대해서 읽기 전용(read-only)와 가변 컬렉션을 엄격하게 구분하고 있습니다. 읽기 전용 : Iterable, Collection, List, Set 인터페이스 Mutable : MutableIterable, MutableCollection, MutableSet, MutableList 인터페이스 읽기 전용은 내부에서 값을 변경하는 함수들을 제공하지 않습니다. 만약 데이터를 추가, 삭제, 수정하려는 경우에는 toMutableList() 함수를 이용해서 요소들을 변경 가능한 컬렉션으로 변경하여 사용해야합니다. 만약 list as MutableList와 같이 다운캐스팅을 시도 한다면 코틀린에서 정한 읽기전용 규칙을 무시하기 때문에 이러한 행위는 지양해야 합니다. 또한 코틀린에서 컬렉션을 다룰 때 var와 함께 Mutable Collection을 사용하면 두개의 가변 포인트를 모두 동기화 해주어야 하기 때문에 이렇게 사용해서는 안됩니다. 12345678910111213data class Fruit( val name: String, val price: Int)fun main() { val banana = Fruit(&quot;banana&quot;, 500) val strawberry = banana.copy(name = &quot;strawberry&quot;) println(&quot;banana ${banana.hashCode()} $banana&quot;) println(&quot;strawberry ${strawberry.hashCode()} $strawberry&quot;) //banana -337338577 Fruit(name=banana, price=500) //strawberry 986991237 Fruit(name=strawberry, price=500)} data class의 copy를 통해서 기존 객체의 값을 변경하지 않고 프로퍼티를 변경하여 새로운 값을 할당한 객체를 받아 불변성을 유지할 수 있습니다. 마무리불변성이 항상 장점만 가진다고 생각하지는 않습니다. 가변을 피하기 위해 새로운 객체를 생성하는 것은 비용 증가로 이어지기 때문에 불필요한 인스턴스화나 잦은 복사는 오버헤드로 이어질 수 도있다고 생각합니다. 하지만 불변성이 가지는 장점들이 가변성의 많은 단점들을 해소하기 때문에 코틀린에서도 불변성을 권장했을겁니다. 긴 글 읽어주셔서 감사합니다. 🙇‍♂️ 참고 Kotlin 코틀린(kotlin)과 불변성(immutability) 이펙티브 코틀린 Item1. 가변성을 제한하라","link":"/2023/01/30/Kotlin-%EB%B6%88%EB%B3%80%EC%84%B1-Immutability-%EA%B3%BC-%EA%B0%80%EB%B3%80%EC%84%B1-Mutability/"},{"title":"Kotlin으로 람다 함수와 고차함수란","text":"Kotlin으로 람다 함수(Lambda Function)와 고차 함수(High Order Function)에 대해서 알아보자Lambda Function(람다 함수) 이란?람다 함수는 함수형 프로그래밍 언어에서 사용되는 개념으로 익명 함수라고도 불린다Java8 부터 사용이 가능하며, 가독성을 향상시키고 보일러 플레이트 코드를 줄일 수 있다 Lambda Function(람다 함수) 의 사용 방법기본 사용 방법 1val lambdaName : Type = { argumentList -&gt; codeBody } Type Interface를 활용하는 방법 12val square = { number: Int -&gt; number * number }val nine = square(3) 123val lambdaName = { a: Int, b: String -&gt; &quot;$a $b&quot;} 1개 이상의 타입을 파라미터로 전달 가능하고 리턴 타입을 생략 할 수 있습니다 High Order Function(고차 함수) 란?함수를 인수로 취하거나 함수를 결과로 반환할 수 있는 함수를 말합니다 아래 사용되고 있는 예시를 보겠습니다. 1234567fun square(x: Int, y: Int, block: (result: Int) -&gt; Unit) { block(x * y)}square(4, 4) { result -&gt; // result 16} x, y를 인자를 받고 해당 block이라는 람다식을 invoke 합니다. 선언된 square 함수에서 block 파라미터의 블록에서 결과값을 받을 수 있습니다 고차 함수로 람다함수를 파라미터로 넘겨줄 때 과도하게 사용하면 런타임 오버헤드가 발생합니다.그럴때는 inline 키워드를 사용하여 오버헤드를 방지해야 합니다. Medium 글 Medium 설명글에 inline에 대해서 작성한 글이 있습니다. 참고해 보시길 바랍니다.","link":"/2022/12/15/Ktoin%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9-%E1%84%85%E1%85%A1%E1%86%B7%E1%84%83%E1%85%A1-%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%E1%84%8B%E1%85%AA-%E1%84%80%E1%85%A9%E1%84%8E%E1%85%A1%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%E1%84%85%E1%85%A1%E1%86%AB/"},{"title":"Kotlin 얕은 복사(Shallow Copy)와 깊은 복사(Depp Copy)","text":"안녕하세요. 이번 글에서는 얕은복사(Shallow Copy)와 깊은복사(Deep Copy)에 대해서 알아보려고합니다. 자바나 코틀린으로 개발을 하다보면 객체를 복사할 일이 생기는데 이 때 주의해서 복사하지 않으면 의도치 않은 결과를 마주할 수 있습니다. 객체를 복사하는 방법은 크게 얕은복사(Shallow Copy)와 깊은복사(Deep Copy) 두 가지 방식이 있습니다. 얕은 복사(Shallow Copy)얇은 복사는 원본 객체에 대한 객체를 만들고 원본 객체의 주소값을 참조하는것을 의미합니다. 객체는 인스턴스화 되면서 메모리에 주소를 할당하게 되는데요 이 때 할당된 주소의 값을 참조하게 되는 것이 얕은 복사라고 합니다. 코드로 한번 어떤 의미인지 살펴보겠습니다. 12345678910111213141516171819202122232425262728public class User { int id; String name; public User(int id, String name) { this.id = id; this.name = name; } public void changeName(String name) { this.name = name; } public void changeId(int id) { this.id = id; }}public void main() { User kenneth = new User(1, &quot;kenneth&quot;); User daniel = kenneth; kenneth.changeName(&quot;daniel&quot;); kenneth.changeId(2); System.out.println(kenneth); // User(name='daniel', id=2) System.out.println(daniel); // User(name='daniel', id=2)} 위에 코드에서 는 유저 이름이 각 kenneth와 daniel 이 노출되는것을 기대하지만 모두 daniel이라는 값을 가지고 있는 것을 볼 수 있습니다. 이렇게 된 이유는 daniel은 실제 값을 복사한게 아닌 참조값을 복사했습니다. 12User kenneth = new User(1, &quot;kenneth&quot;); User daniel = kenneth; User인스턴스를 생서하고 daniel 인스턴스는 kenneth의 참조값을 저장합니다. kenneth와 daniel의 주소값이 동일하므로 49cfaae주소값을 동일하게 바라보고있습니다. 12kenneth.changeName(&quot;daniel&quot;);kenneth.changeId(2); 이제 kenneth에 접근하여 이름을 daniel로 변경해보겠습니다. kenneth와 daniel 인스턴스가 참조하는 힙 데이터 내의 실제값이 수정되었습니다 결국 kenneth와 daniel 모두 변경된 값을 동일하게 참조합니다. 하지만 우리는 실제 객체의 값이 복사되는 것을 원합니다. 이런 경우에는 깊은 복사(Deep Copy)를 해야합니다. 깊은복사(Deep Copy)깊은 복사(Deep Copy)는 실제 값을 새로운 메모리 공간에 복사하는 것입니다. 깊은 복사를 하는 방법은 크게 3가지가 있습니다. 복사 생성자 또는 복사 팩터리를 이용 직접 객체를 생성하여 복사 Cloneable을 이용한 clone() 재정의 복사 생성자, 복사 팩터리를 이용 1234567891011121314151617public class User { int id; String name; // 복사 생성자 public User(User user) { this.id = user.id; this.name = user.name; } // 복사 팩터리 public static User newInstance(User user) { User copy = new User(); copy.name = user.name; copy.id = user.id; return copy }} 직접 객체를 생성 12345678User kenneth = new User(1, &quot;kenneth&quot;); User daniel = new User();daniel.setName(kenneth.name);daniel.setId(kenneth.Id);kenneth.changeName(&quot;kenneth 2&quot;)kenneth.changeId(3) Cloneable을 이용한 clone() 재정의 12345678910public class User implements Cloneable { String name; int it; @NonNull @Override protected User clone() throws CloneNotSupportedException { return (User) super.clone(); }} Cloneable을 이용한 복사는 이펙티브 자바에서 권장하지 않는데 그 이유는 final 클래스는 위험이 크지 않지만 그 외에는 성능 최적화 관점에서 문제가 없을 때만 허용해야 하기 때문에 복제는 생성자와 팩터리를 이용하는게 베스트라고 한다. 코틀린에서 data class의 copy()는 깊은 복사일까?코틀린 data class의 copy() 함수는 마치 깊은 복사를 해주는 것처럼 헷갈릴 수 있지만 copy()는 얇은 복사입니다. 이유는 깊은 복사는 객체의 변수들을 전부 깊은 복사를 해주지만 copy() 함수는 data class내의 Primitive 타입을 제외한 커스텀 객체는 깊은 복사를 지원하지 않습니다. 또한 코틀린에서 Immutable한 객체는 처음 할당되고 프로그램이 종료될 때 까지 값이 변경되지 않으므로 깊은 복사와 얇은 복사의 선택권이 없고 경계하지 않아도됩니다. 참고 https://jackjeong.tistory.com/100 https://kotlinlang.org/docs/data-classes.html","link":"/2023/02/09/Kotlin-%EC%96%95%EC%9D%80-%EB%B3%B5%EC%82%AC-Shallow-Copy-%EC%99%80-%EA%B9%8A%EC%9D%80-%EB%B3%B5%EC%82%AC-Depp-Copy/"},{"title":"RxJava - Scan","text":"ScanScan은 Observable이 발행하는 각 항목에 대해서 순차적으로 작성한 함수의 결과를 적용하고 값을 내보냅니다. Scan 연산자는 Reduce와 비슷하지만 조금 다릅니다. Observable에서 발행된 첫번째 아이템은 그대로 결과로 전달하고 그 이후 부터는 중간 결과 값과 최종 결과를 구독자에게 발행합니다. 샘플 코드 ()123456// 1, 2, 3observable .scan { t1, t2 -&gt; println(&quot;Scan $t1 to $t2&quot;) t1 + t2 }.subscribe(::printSubscribe) 12345Result: 1Scan 1 to 2Result: 3Scan 3 to 3Result: 6","link":"/2023/01/12/RxJava-Scan/"},{"title":"Vector와 ArrayList 차이","text":"Vector의 특징현재 Collection 프레임워크에 포함되어 있지만 초기 자바에서는 인터페이스로 정의 되어 있었습니다. 필요에 따라 크기를 동적으로 조절 가능 배열과 같이 Index에 접근 및 제어 가능 동기화(Thread Safe)가 되어 있음 ArrayList의 특징Collection 프레임워크에 포함되어 있는 자료구조입니다. 크기를 동적으로 바꿀 수 있는 동적 배열 배열에서의 조작이 많을 때 유용합니다(특히 Index를 통한 접근) 타입 객체를 참조해서 사용 그럼 본격적으로 차이는?가장 중요한 차이점은 동기화 유무 입니다. Vector의 구조를 보면 element 접근에 관한 함수들은 synchronized 처리가 되어있습니다. 즉 여러 스레드에 접근에도 Thread Safe(스레드 안전)한 특징을 가지고 있습니다. 성능: ArrayList 동기화를 지원하는 Vector 보다 좋은 성능을 가지고 있습니다. 스레드 세이프: Vector는 동기화를 지원하므로 ArrayList에 비해 멀티 스레드에 안전합니다. 배열의 길이 증가: 초기 할당한 배열의 최대길이에 도달했을 때 ArrayList는 50%씩 증가하는 반면 Vector는 2배씩 크기가 증가합니다. 그럼 무엇을 써야하나?Vector는 Java초기에 만들어서 초기 버전의 호환성이 아니라면 많이 쓰지 않습니다. ArrayList를 사용하되 멀티 스레드에 대해 적절한 처리를 해서 사용해 주시면 됩니다.","link":"/2023/01/19/Vector%EC%99%80-ArrayList-%EC%B0%A8%EC%9D%B4/"},{"title":"ViewModel이 화면회전에도 데이터를 유지할 수 있는 이유","text":"안드로이드에서 구성변경(Configuration Change)이 발생할 때 ViewModel 객체는 Activity가 재생성 되더라도 파괴되지 않고 객체가 유지 되는것을 볼 수 있습니다. 여기서의 ViewModel은 MicroSoft에서 제시한 MVVM의 ViewModel 아닌 Android Architecture Component의 ViewModel 입니다. Activity의 마지막 생명주기인 onDestroy()은 파괴되고 사라지기전에 호출되는 생명주기 마지막 오버라이드 함수인 이후 호출되는 ViewModel의 생명주기 중 하나인 onCleared()에서 여러가지 해제하는 작업들을 합니다. 하지만 여기서 하나 의문점은 Activity의 종료가 구성변경과 같은 재생성에 의한 종료인지 finish()를 통한 종료인지 ViewModel은 어떻게 알 수 있을까요? 만약 단순 구성변경으로 발생한 Activity의 종료일 때 ViewModel의 onCleared()에서 여러 작업들을 해제한다면 사용자들은 잘못된 정보를 전달 받을 확률이 높습니다. 이 때문에 Activity가 재생성으로 인한 파괴(Destroy)라는 것을 파악하고 전파해야 합니다. 어떻게 이런 동작들이 이루어지는지 ViewModel과 Activity의 내부 코드들을 차근차근 살펴보려고 합니다. 아래 그림은 Activity와 ViewModel의 라이프사이클을 순서를 나타내는 이미지입니다. 일단, 가장 먼저 ViewModel에서 onCleared()가 호출되는 함수를 따라가보겠습니다. 123456789101112public abstract class ViewModel { @SuppressWarnings(&quot;WeakerAccess&quot;) protected void onCleared() { } @MainThread final void clear() { ///.. onCleared(); }} ViewModel에서 onCleared()는 final 함수인 clear()에서 호출이됩니다. 이 clear()는 누가 호출하는지 따라가보면 ViewModelStore라는 객체에서 호출하는 것을 볼 수 있습니다. ViewModelStore는 ViewModel들을 Map 형태로 저장하기는 코드로 구성 되어있습니다. ViewModelStore의 클래스 내부를 살펴보면 String Key값과 ViewModel Value를 가지는 해시맵을 가지고 있습니다. 1234567891011121314151617181920212223242526272829public class ViewModelStore { private final HashMap&lt;String, ViewModel&gt; mMap = new HashMap&lt;&gt;(); final void put(String key, ViewModel viewModel) { ViewModel oldViewModel = mMap.put(key, viewModel); if (oldViewModel != null) { oldViewModel.onCleared(); } } final ViewModel get(String key) { return mMap.get(key); } Set&lt;String&gt; keys() { return new HashSet&lt;&gt;(mMap.keySet()); } /** * Clears internal storage and notifies ViewModels that they are no longer used. */ public final void clear() { for (ViewModel vm : mMap.values()) { vm.clear(); } mMap.clear(); }} 이 클래스는 단순히 해시맵에 put과get하기 위한 함수들을 제공합니다. 해시맵에 들어가는 키 값은 기본값으로는 androidx.lifecycle.ViewModelProvider.DefaultKey:modelClass.canonicalName로 생성합니다. clear()를 보면 해시맵의 Value들을 재귀하여 ViewModel의 clear()를 호출하고 해시맵을 clear() 하는 것을 볼 수 있습니다. 결국 이 ViewModelStore 가 ViewModel의 clear()를 호출하는 것을 알아냈고 이 함수는 ComponentActivity에서 호출되는 것을 확인할 수 있습니다. 123456789101112131415161718public ComponentActivity() { getLifecycle().addObserver(new LifecycleEventObserver() { @Override public void onStateChanged( @NonNull LifecycleOwner source, @NonNull Lifecycle.Event event ) { if (event == Lifecycle.Event.ON_DESTROY) { // Clear out the available context mContextAwareHelper.clearAvailableContext(); // And clear the ViewModelStore if (!isChangingConfigurations()) { getViewModelStore().clear(); } } } });} ComponentActivity에서는 LifecycleEventObserver를 라이프사이클에 관찰자로 등록하고 onDestroy 와 !isChangingConfigurations()가 두개 모두 만족할 경우 ViewModelStore의 clear()가 호출되어 ViewModel까지 전달되는 것을 볼 수 있습니다. 1234567public class Activity { boolean mChangingConfigurations = false; public boolean isChangingConfigurations() { return mChangingConfigurations; }} isChangingConfigurations()는 Activity 클래스의 내부 멤버변수인 mChangingConfigurations를 리턴해주는 함수입니다. 이제 이 mChangingConfigurations를 true 혹은 false로 변경하는 곳이 어디인지를 찾으면 됩니다. 해답은 ActivityThread에 있었습니다. 이 클래스는 액티비티 매니저의 요청들을 어플리케이션 프로세스에서 메인스레드로 실행할 수 있게 Activity나 Broadcast 그리고 다른 작업들을 스케쥴링하고 실행하는 것을 관리해주는 클래스입니다. 이 클래스에 오버라이드된 activityLocalRelaunch()를 살펴보면 ActivityClientRecord에 기록된 activity에 mChangingConfiguration을 true로 설정해준 것을 확인할 수 있습니다. 12345678@Overridepublic void handleRelaunchActivity( ActivityClientRecord tmp, PendingTransactionActions pendingActions) { ActivityClientRecord r = mActivities.get(tmp.token); r.activity.mChangingConfigurations = true;} 여기까지 mChangingConfigurations의 변수를 통해 getViewModelStore().clear()가 실행여부를 밝혀냈습니다. 하지만 여기서 ViewModel의 생성도 결국 Activity에서 이루어지는데 Activity가 완전히 파괴되고 다시 만들어질 때 ViewModel의 인스턴스를 어떻게 유지할지에 대한 궁금증이 생깁니다. 여기에는 ViewModelStoreOwner에 해답이 있습니다. 1234public interface ViewModelStoreOwner { @NonNull ViewModelStore getViewModelStore();} ViewModelStoreOwner 인터페이스 주석 설명을 보면 이 인터페이스 구현체의 책임은 구성 변경중에도 ViewModelStore를 유지하고 이 범위가 파괴될 때 ViewModelStore.clear()를 호출하는 것이라고 적혀있습니다. 즉, ViewModelStoreOwner는 각 Owner(일반적으로 Activity, Fragment가 해당 됩니다.)들이 구성변경이 일어나서 파괴되고 재생성되어도 인스턴스를 유지하는 역할을 합니다. 만약 Activity나 Fragment같은 Owner들은 완전히 파괴되고 재생성될 여지가 없다면 에서 ViewModelStore객체에 clear()를 호출하여 더이상 ViewModel이 사용되지 않는다는 사실을 전파해야합니다. ViewModelStoreOwner의 구현체인 ComponentActivity의 코드를 확인해보겠습니다. 1234567891011121314151617181920@NonNull@Overridepublic ViewModelStore getViewModelStore() { if (getApplication() == null) { throw new IllegalStateException(&quot;Your activity is not yet attached to the &quot; + &quot;Application instance. You can't request ViewModel before onCreate call.&quot;); } //This is true when invoked for the first time if (mViewModelStore == null) { NonConfigurationInstances nc = (NonConfigurationInstances) getLastNonConfigurationInstance(); if (nc != null) { // Restore the ViewModelStore from NonConfigurationInstances mViewModelStore = nc.viewModelStore; } if (mViewModelStore == null) { mViewModelStore = new ViewModelStore(); } } return mViewModelStore;} 코드를 살펴보면 getLastNonConfigurationInstane()를 호출하여 NoConfigurationInstance라는 클래스를 캐스팅해서 가져온 후 ComponentActivity의 ViewModelStore 멤버변수로서 할당해줍니다. Activity가 구성변경에 의해 재생성될 때 ComponentActivity에 있는 NonConfigurationInstance클래스는 이전 ViewModelState의 인스턴스를 포함하고 있습니다. Activity가 처음 생성될 때 NonConfigurationInstance는 null을 반환하고 그런 경우에는 ViewModelStore를 새로 생성합니다. 조금더 내부 코드를 살펴보겠습니다. 1234567891011121314151617181920212223242526272829303132333435//Activity.java@Nullablepublic Object getLastNonConfigurationInstance() { return mLastNonConfigurationInstances != null ? mLastNonConfigurationInstances.activity : null;}//ComponentActivity.java@Override@Nullable@SuppressWarnings(&quot;deprecation&quot;)public final Object onRetainNonConfigurationInstance() { // Maintain backward compatibility. Object custom = onRetainCustomNonConfigurationInstance(); ViewModelStore viewModelStore = mViewModelStore; if (viewModelStore == null) { // No one called getViewModelStore(), so see if there was an existing // ViewModelStore from our last NonConfigurationInstance NonConfigurationInstances nc = (NonConfigurationInstances) getLastNonConfigurationInstance(); if (nc != null) { viewModelStore = nc.viewModelStore; } } if (viewModelStore == null &amp;&amp; custom == null) { return null; } NonConfigurationInstances nci = new NonConfigurationInstances(); nci.custom = custom; nci.viewModelStore = viewModelStore; return nci;} Activity가 구성변경이 발생하여 재생성될 때 ComponentActivity 의 onRetainNonConfigurationInstance 함수가 호출되고 NonConfigurationInstance(ComponentActivity.java)의 객체를getLastNonConfigurationInstance()를 호출하여 Activity의 mLastNonConfigurationInstances.activity를 반환받는데 이 객체는 안드로이드 시스템에서 재생성된 후의 액티비티를 전달한 것입니다. Activity가 재생성후에 Activity.java클래스에서 mLastNonConfigurationInstances 객체는 attach()에서 lastNonConfigurationInstances를 전달받아 mLastNonConfigurationInstances에 할당합니다. 123456789final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken, IBinder shareableActivityToken) {} 마무리지금까지 ViewModel이 구성변경에도 인스턴스를 유지하는 방법과 onCleared()의 호출 조건을 알아보았습니다. ViewModel의 인스턴스 유지 과정을 살펴보니 Activity에 대한 코드의 이해도도 증가되고 ViewModel의 구성방식들도 이해하게되어 좋았습니다. 안드로이드 개발자라면 ViewModel을 잘 활용하여 구성변경에도 데이터를 유지하여 사용자 경험을 증진시키는게 하나의 임무라고 생각합니다 :smile: 긴글 봐주셔서 감사합니다. 레퍼런스 https://blog.mindorks.com/android-viewmodels-under-the-hood/","link":"/2023/01/08/ViewModel%EC%9D%B4-%ED%99%94%EB%A9%B4%ED%9A%8C%EC%A0%84%EC%97%90%EB%8F%84-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EC%9C%A0%EC%A7%80%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94-%EC%9D%B4%EC%9C%A0/"},{"title":"기본 코루틴(Coroutine Basics)","text":"첫번째 코루틴(Your first coroutine)코루틴은 일시 중단 가능한 계산의 인스턴스입니다. 코드의 블록들이 다른 코드 들과 동시에 동작해야 한다는 점에서는 개념적으로 스레드와 유사합니다. 하지만 코루틴은 나머지 코드와 동시에 작동하는 코드들이 하나의 블럭에서 실행해야 코드의 블럭이 실행될 때 동시적으로 실행할 수 있습니다. 그러나 코루틴은 특정한 스레드에 바운드 되지 않고 한 스레드에서 일시 중단하고 다른 스레드에서 다시 재개할 수 있습니다. 코루틴은 경량 스레드라고 생각할 수 있습니다. 하지만 실제 우리가 사용하는 스레드와는 다르게 만드는 중요한 요소들이 있습니다. 다음 코드를 실행하여 첫번째 코루틴 작업을 확인해봅니다. 1234567891011fun main() = runBlocking { // this: CoroutineScope launch { // launch a new coroutine and continue delay(1000L) // non-blocking delay for 1 second (default time unit is ms) println(&quot;World!&quot;) // print after delay } println(&quot;Hello&quot;) // main coroutine continues while a previous one is delayed}// resultHelloWorld! 다음과 같은 결과가 나오는 걸 볼 수 있습니다. 한번 이 코드가 무엇인지 해부해보겠습니다 launch는 코루틴 빌더입니다. launch는 새로운 코루틴을 실행함과 동시에 나머지 코드들을 독립적으로 계속 작업합니다. 그것이 Hello가 첫번째로 프린트된 이유입니다. delay 는 특별한 일시중단 함수입니다. 코루틴을 특정 시간동안 일시 중단합니다. 코루틴을 일시중단해도 기본스레드가 차단되지는 않으며 다른 코루틴들도 기본스레드를 사용하여 코루틴을 실행하할 수 있습니다. runBlocking은 fun main() 과 같은 기본적인 코루틴이 아닌 세계와 runBlocking { ... } 중괄호 안에 있는 코루틴 코드들을 연결하는 코루틴 빌더입니다. runBlocking 코드를 작성해보면 IDE에서 중괄호 바로 뒤에 CoroutineScope라는 힌트가 표시됩니다. launch는 CoroutineScope에서만 선언이 가능하기 때문에 만약 깜빡하고 runBlocking을 코드에서 제거한다면 launch를 호출할 때 에러가 발생합니다. 1Unresolved reference: launch runBlocking 은 의미는 runBlocking { ... } 내부의 모든 코루틴들이 실행이 완료 될 때까지 이를 실행하는 스레드(메인스레드라고 가정)는 차단된다는 것을 의미합니다. 스레드는 차단하는 것은 스레드의 비용이 비싸기 때문에 비효율적이지만 실제코드에서는 앱의 최상위 레벨에서 runBlcoking 자주 사용되는 것을 볼 수 있습니다. 구조화된 동시성(Structured concurrency)코루틴 구조화된 동시성을 원칙을 따릅니다. 즉, 구조화된 동시성이란 새로운 코루틴은 오직 코루틴의 수명을 제한하는 특정한 CoroutineScope에서만 실행될 수 있다는 것을 의미합니다. 위의 예제에서는 runBlocking 해당하는 스코프를 설정하고 World!는 몇초뒤에 프린트 된 것을 볼 수 있습니다. 실제 앱에서는 많은 양의 코루틴을 실행해야합니다. 구조화된 동시성은 손실이나 릭을 발생하지 않게 보장합니다. 외부 범위는 모든 하위 코루틴이 완료될 때까지 완료할 수 없습니다. 또한 구조화된 동시성은은 코드에서 발생한 모든 에러가 올바르게 보고되고 손실이 발생하지 않게 합니다. 함수 추출 리팩토링(Extract function refactoring)launch { … } 내부의 코드 블록을 별도의 함수로 추출해보겠습니다. 만약 코드에서 “함수 추출”이라는 리팩토링을 수행한다면 suspend 수정자와 함께 새로운 함수를 만들 수 있습니다. 이건 당신의 첫번째 중단 함수 입니다. 중단 함수는 코루틴 내부에서 일반적인 함수처럼 사용합니다 하지만 일반적인 함수와 다른 점은 코루틴을 일시중지하기 위해 다른 코루틴 함수의 기능들(deplay 함수 같은) 추가 기능들이 존재한다는 것입니다. 12345678910111213fun main() = runBlocking { // this: CoroutineScope launch { doWorld() } println(&quot;Hello&quot;)}// this is your first suspending functionsuspend fun doWorld() { delay(1000L) println(&quot;World!&quot;)}// resultHelloWorld! 스코프 빌더(Scope builder)코루틴스코프 빌더를 사용하여 다른 빌더에서 제공되는 코루틴 스코프외에도 자신만의 스코프를 선언할 수 있습니다. 그리고 코루틴 스코프를 생성한 후 해당 스코프내의 생성된 자식 작업들이 완료되기 전까지는 스코프가 완료되지 않습니다. 1234567891011121314fun main() = runBlocking { doWorld()}suspend fun doWorld() = coroutineScope { // this: CoroutineScope launch { delay(1000L) println(&quot;World!&quot;) } println(&quot;Hello&quot;)}// resultHelloWorld! runBlocking 그리고 coroutineScope 빌더들은 둘다 바디와 모든 자식들이 작업이 완료되기까지 기다리는 것으로 유사하게 보이지만 가장 큰 차이점은 runBlocking 함수가 대기를 위해 현재 스레드를 _차단_한다면 coroutineScope는 단순히 일시중단하고 다른 용도를 위해 기본 스레드를 해제합니다. 그 차이 때문에 runBlocking은 일반 함수이고 coroutineScope는 정지함수 입니다. coroutineScope를 어떠한 중단함수로서 사용할 수 있습니다. 예를 들어 Hello와 World의 동시적인 로그 출력을 suspend fun doWorld() 로 옮길 수 있습니다. 스코프 빌더 그리고 동시성(Scope builder and concurrency )coroutineScope 빌더는 여러 동시 작업을 수행하기 위해 정지 함수 내에서 사용할 수 있습니다 1234567891011121314151617181920212223// Sequentially executes doWorld followed by &quot;Done&quot;fun main() = runBlocking { doWorld() println(&quot;Done&quot;)}// Concurrently executes both sectionssuspend fun doWorld() = coroutineScope { // this: CoroutineScope launch { delay(2000L) println(&quot;World 2&quot;) } launch { delay(1000L) println(&quot;World 1&quot;) } println(&quot;Hello&quot;)}// resultHelloWorld 1World 2Done launch { ... } 블록 내부에 두 개의 코드들은 동시적으로 실행되며 World 1이 먼저 프린트 된 후 1초 후에 World 2의 프린트가 시작되고 2초 뒤에 프린트합니다. coroutineScope doWorld 코루틴 스코프에 있는 doWorld의 함수는 두 개의 작업이 모두 완료된 후에만 완료됩니다. 그래서 doWorld는 모든 작업이 완료된 후 Done 문자열이 인쇄되도록 허용합니다 1234HelloWorld 1World 2Done 명시적 작업(An explicit job)launch 코루틴 빌더는 Job 객체를 리턴합니다. Job은 실행된 코루틴을 핸들링하고 작업이 완전히 끝날때까지 명시적으로 기다리는 용도로 사용할 수 있습니다. 예를들어 자식 코루틴들이 완료되기전까지 기다린 후에 “Done” 문자열을 출력할 수 있습니다. 1234567891011val job = launch { // launch a new coroutine and keep a reference to its Job delay(1000L) println(&quot;World!&quot;)}println(&quot;Hello&quot;)job.join() // wait until child coroutine completesprintln(&quot;Done&quot;) // resultHelloWorld!Done 코루틴은 가볍습니다(Coroutines are light-weight)코루틴은 JVM 스레드에서 리소스 집약이 더 적습니다. 스레드를 사용할 때 JVM의 가용 메모리를 소진하는 코드는 리소 제한에 도달하지 않고 콜튄을 사용하여 표현할 수 있습니다. 스레드에서 JVM의 가용 메모리를 소진하는 코드는 코루틴을 사용하는것으로 리소스 제한에 도달하지 않을 수 있습니다. 예를들어 다음 코드는 100000개의 서로 다른 코루틴을 시작하여 각각 5초를 기다린 다음 마침표(‘.’)를 프린트하는 코드가 있습니다. 이 코드는 매우 적은 메모리를 사용합니다. 12345678910import kotlinx.coroutines.*fun main() = runBlocking { repeat(100_000) { // launch a lot of coroutines launch { delay(5000L) print(&quot;.&quot;) } }} 해당 코드를 스레드에서 비교하고 싶으신 경우 runBlocking과 launch를 thread로 교체하고 delay 함수도 Thread.sleep으로 교체해줍니다. 만약 해당 코드를 실행한다면 많은 메모리를 소비하여 OOM(out-of-memoery)에러가 발생할 수 있습니다.","link":"/2023/01/08/coroutine/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/12/18/hello-world/"},{"title":"kotlin-sequence","text":"Kotlin standard library는 Collection과 함께 또 다른 유형인 Sequences(Sequence&lt;T&gt;) 를 포함하고 있습니다. 컬렉션과는 달리 시퀀스는 엘리먼트를 포함하지 않으며 반복하는 동안 엘리먼트를 생성합니다. 시퀀스는 Iterable과 동일한 기능을 제공하지만 여러 단계 처리에 대한 다른 접근방식을 구현합니다. Iterable은 여러 과정을 처리할 때 각 단계를 완료하고 그 결과인 중간 컬렉션을 반환합니다. 시퀀스는 여러 과정의 처리에서 가능한 Lazily(나중에)하게 처리합니다. 이 의미는 시퀀스는 여러 단계의 처리는 바로 실행하지 않고 전체 단계가 처리된 결과가 요청되었을 때 실제 시퀀스 연산이 일어나면서 Lazily(나중에)하게 처리됩니다. 동작 실행 순서도 다르다고 할 수 있습니다. Sequence는 모든 단일 요소에 대해 처리를 One-By-One 형태로 수행하는 반면 Iterable 은 전체 컬렉션의 각 단계를 완료하고 그 다음 단계로 진행합니다. 따라서 시퀀스를 사용하면 중간 단계의 결과에 대한 처리를 피할 수 있습니다. 그러므로 전체 컬렉션의 체이닝 동작에서 퍼포먼스 향상을 기대할 수 있습니다. 그러나 이런 시퀀스의 Lazy 특성은 오히려 간단한 계산이나 작은 컬렉션을 처리할 때 불필요한 오버헤드가 발생할 수 있습니다. 이런 이유로 Sequence와 Iterable 사이에서 어떤것이 해당 케이스에서 더 효율적인지를 고려해야합니다. ConstructFrom elements시퀀스를 만들기 위해서는 sequenceOf() 함수를 호출하고 인자들을 나열하면 됩니다. 1val numbersSequence = sequenceOf(&quot;four&quot;, &quot;three&quot;, &quot;two&quot;, &quot;one&quot;) From an IterableIterable객체(List와 Set등)를 asSequence()를 호출해서 시퀀스로 만들 수 있습니다. 12val numbers = listOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;)val numbersSequence = numbers.asSequence() From a Function시퀀스의 요소들을 계산 할 수 있는 방식인 generateSequence()함수와 함께 구축하는 방법도 있습니다. 선택적으로 첫번째 인자를 명시적으로 선언할 수 있습니다. 이런 시퀀스 생성은 null을 반환하면 중지됩니다. 아래 예제를 보면 무한한 시퀀스가 있습니다. 12345val oddNumbers = generateSequence(1) { it + 2 } // `it` is the previous element//println(oddNumbers.take(5).toList()) // Result : [1, 3, 5, 7, 9]println(oddNumbers.count()) // error: the sequence is infinite// Result : Evaluation stopped while it's taking too long️ generateSequence()를 사용할 때 유한한 시퀀스를 만들기 위해서는 마지막 요소 다음에 null을 반환해야 합니다. 12val oddNumbersLessThan10 = generateSequence(1) { if (it &lt; 8) it + 2 else null }println(oddNumbersLessThan10.count()) // Result: 5 From chunk마지막으로 시퀀스를 임의의 크기의 덩어리로 생성할 수 있는 기능이 있습니다. 이 기능은 람다 함수내에서 호출할 수 있는 yield() 그리고 yieldAll() 함수입니다. 이 함수는 시퀀스 소비자에게 요소들을 반환하고 소비자가 다음 요소를 요청할 때 까지 sequence() 실행을 일시중단 합니다. yield()는 단일 요소를 인자로 가지고 yieldAll()은 Iterable객체를 인자로 가지고 Iterator나 다른 Sequence도 가질 수 있습니다. yieldAll에 인자로 들어가는 Sequence는 무한할 수 있지만 모든 후속 호출은 실행되지 않기 때문에 마지막에만 호출해야 합니다. 123456val oddNumbers = sequence { yield(1) yieldAll(listOf(3, 5)) yieldAll(generateSequence(7) { it + 2 })}println(oddNumbers.take(5).toList()) Sequence operations시퀀스 동작은 상태요구에 따라서 그룹별로 분류될 수 있습니다. map()이나 filter()과 같은 스테이트리스(Stateless) 동작은 상태나 각 요소들간의 의존적인 과정을 요구하지 않지만 take() 나 drop()처럼 적은 양을 가진 상수의 상태는 요구할 수 있습니다. 스테이트풀(Stateful) 동작은 시퀀스에서 비례하는 요소들의 숫자만큼 상당한 양의 상태가 필요합니다. 시퀀스 동작이 Lazliy하게 생성된 다른 시퀀스를 리턴하면 그것을 itermediate라 하고 다른 동작은 terminal이라고 합니다.terminal의 수행 동작의 예로는 toList() 또는 sum()이 있습니다. 시퀀스 요소들은 오직 terminal이라는 동작으로만 얻어질 수 있습니다. 시퀀스는 여러번의 Iteration이 가능하지만 일부 시퀀스의 구현은 한번만 반복으로 되도록 제한되어 있습니다. 해당 내용은 문화되어있습니다. Sequence processing exampleIterable과 Sequnce의 차이를 예제로 살펴보겠습니다. Iterable123456789101112131415161718192021222324val words = &quot;The quick brown fox jumps over the lazy dog&quot;.split(&quot; &quot;)val lengthsList = words.filter { println(&quot;filter: $it&quot;); it.length &gt; 3 } .map { println(&quot;length: ${it.length}&quot;); it.length } .take(4)println(&quot;Lengths of first 4 words longer than 3 chars:&quot;)println(lengthsList)// Result// filter: The// filter: quick// filter: brown// filter: fox// filter: jumps// filter: over// filter: the// filter: lazy// filter: dog// length: 5// length: 5// length: 5// length: 4// length: 4// Lengths of first 4 words longer than 3 chars:// [5, 5, 5, 4] 위의 예제를 보면 단어 리스트에서 길이가 3을 초과하는 filter()와 필터링된 문자열 길이를 map() 이 순서대로 호출되는걸 볼 수 있습니다. 순차적으로 filter의 모든 요소들이 수행되고 리턴된 결과로 map이 수행됩니다. Sequence123456789101112131415161718192021222324val words = &quot;The quick brown fox jumps over the lazy dog&quot;.split(&quot; &quot;)//convert the List to a Sequenceval wordsSequence = words.asSequence()val lengthsSequence = wordsSequence.filter { println(&quot;filter: $it&quot;); it.length &gt; 3 } .map { println(&quot;length: ${it.length}&quot;); it.length } .take(4)println(&quot;Lengths of first 4 words longer than 3 chars&quot;)// terminal operation: obtaining the result as a Listprintln(lengthsSequence.toList())// Result// Lengths of first 4 words longer than 3 chars// filter: The// filter: quick// length: 5// filter: brown// length: 5// filter: fox// filter: jumps// length: 5// filter: over// length: 4// [5, 5, 5, 4] 코드의 결과물을 보면 프린트가 먼저 출력된 것을 통해 filter()와 map() 함수들이 시퀀스를 리스트로 치환할 때 호출되면서 시퀀스의 시작이 실제로 필요로 할 때 시작되는 것을 알 수 있습니다. 또한 map()은 filter()에서 요소를 리턴하자 마자 실행됩니다. 그리고 take(4)로 4개의 요소만 필요하기 때문에 시퀀스 처리가 만족하는 개수가 4개가 되었을 때 수행은 정지된다.","link":"/2023/01/14/kotlin-sequence/"},{"title":"kotlin 동등성(Equality), 동일성(Identify)","text":"코틀린에서는 두 객체를 비교하는타입에는 2가지가 있습니다. 동등성, Structural equality (==) 동일성, Referential equality (===) 동일성은 객체가 참조하는 주소값을 비교하고, 동등성은 객체가 가지는 정보를 비교합니다. Java에서는 동일성인 ==가 코틀린의 동일성인 ===와 같은 것을 의미하고 Java 동등성인 equals는 코틀린의 동등성인 ==를 의미합니다. Kotlin Java 동등성(equality) == equals 동일성(Identify) === == 동등성 비교(Structural equality)코틀린에서는 == 연산자나 반대인 != 연산자로 구조적 동등성을 확인 할 수 있습니다. 1a?.equals(b) ?: (b === null) 위 코드는 a가 null이 아닐 때 equals(Any?)함수를 호출하고 a가 null이 아닐 때 b의 레퍼런스가 null과 같은지에 대한 코드입니다. a == null 코드는 자동적으로 a === null로 변환해주기 때문에 null을 명시적으로 ==로 비교하는 것은 의미가 없습니다. equals(other: Any?): Boolean) 함수를 오버라이딩해서 커스텀 equals를 구현할 수 있습니다. equals(other: Foo) 함수와 같은 이름과 시그니처를 가진 함수는 == 및 != 연산자를 사용한 동등성 검사에 영향을 주지 않습니다. 또한 동등성 비교는 Comparable&lt;...&gt; 같은 인터페이스를 정의해서 비교할 필요가 없습니다. 오직 커스텀 equals(Any?)만 구현해서 동작할 수 있게 하면 됩니다 동일성 비교(Referential equality)동일성 비교는 ===연산자와 그 반대인 !==로 동일성 검사를 할 수 있습니다. a===b가 true를 리턴할 때는 a와 b가 가리키는 주소 값이 동일 하다는 것을 의미합니다. 런타임시 primitive타입(Int, String, Float..)의 값의 경우 ===은 ==와 동일합니다. Floating-point 숫자 비교피연산 함수로 알려진 Float, Dobule(null 혹은 not null)은 IEEE 754 표준에 맞는 부동 소수점 산술을 따라야합니다. 아래와 같은 기준을 따르지 않는다면 동등성 비교가 사용됩니다. Nan은 NaN자신과 동등한 것으로 비교가 가능하다 NaN은 POSITIVE_INFINITY를 포함해 다른 어떤 것보다 크다 -0.0은 0.0 보다 작다 참고Kotlin Docs - Equality","link":"/2023/01/19/kotlin-%EB%8F%99%EB%93%B1%EC%84%B1-Equality-%EB%8F%99%EC%9D%BC%EC%84%B1-Identify/"},{"title":"메서드 시그니처(Method signature)란","text":"메서드 시그니처(Method signature)란 무엇일까? 메서드 시그니처는 자바에서 프로그래머가 디자인한 메서드 구조를 의미하며 메서드 이름과 파라미터리스트로 구성됩니다. 작성된 코드는 Java 컴파일러에서 오버로딩된 함수들은 메서드 시그니처를 통해 식별합니다. 같은 이름으로 선언하고 다른 파라미터 리스트(Signature)를 가진 것을 **메서드 오버로딩(Method Overloading)**이라고 부릅니다. 123456public int square(int x, int y) { ///}public double square(double x, double y) { ///} 하나의 클래스 안에서는 2개의 같은 시그니처를 가질 수 없습니다. 만약 두개의 같은 시그니처 메서드를 선언한다면 컴파일 에러가 발생합니다. 또한 메서드 시그니처는 메서드의 리턴타입을 포함하지 않습니다.","link":"/2023/01/14/%EB%A9%94%EC%84%9C%EB%93%9C-%EC%8B%9C%EA%B7%B8%EB%8B%88%EC%B2%98-Method-signature-%EB%9E%80/"},{"title":"싱글톤 패턴 - Singleton Pattern","text":"싱글톤 패턴이번글에서는 디자인 패턴 중 하나인 싱글톤 패턴에 대해서 알아봅니다. 싱글톤 패턴은 객체 지향 소프트웨어에서 반복되는 문제를 해결하기 위해 잘 설명해진 GoF 디자인 패턴 중 하나입니다. 싱글톤 패턴은 클래스의 인스턴스화를 단일 인스턴스로 제한하는 패턴입니다. 싱글톤 패턴의 특징 오직 하나의 객체 인스턴스를 가진다 인스턴스에 접근하기 위한 쉬운 방법을 제공한다 인스턴스화를 컨트롤한다 (ex.클래스 생성자를 숨김) 싱글톤 패턴의 장점싱글톤 패턴을 사용하여 인스턴스를 한 개로만 가져가면 아래와 같은 이점이 있습니다. 메모리 비용 절감 : 객체를 생성할 때 마다 메모리를 할당 받는데 한번의 최초 한번의 new를 통해 객체를 생성한다면 고정된 메모리 영역의 사용으로 메모리 비용을 절감할 수 있다 데이터 공유 : 싱글톤 인스턴스는 전역으로 사용되는 인스턴스이기 때문에 다른 클래스의 인스턴스들과 데이터를 공유할 수 있다 싱글톤 패턴의 단점싱글톤 패턴만의 장점도 분명하지만 반대로 안티패턴이라고 불릴만큼 단점도 많이 있습니다. 테스트하기 어려움 : 많은 데이터를 공유할 수록 다른 클래스들 간의 결합도(Coupling)이 높아지고 개방-폐쇄원칙(OCP)을 위배하면서 테스트하기가 어려워짐 멀티 스레드 처리 : 멀티 스레드 환경에서 여러 인스턴스가 생성되는 것을 방지하기 위한 동기화 처리를 위해 syncronized 키워드를 사용해야하고 이는 많은 양의 코드를 작성을 요구함 SOLID 원칙 위반(SRP, DIP, OCP) : 싱글톤은 Primary Function과 하나의 인스턴스만 생성 두 가지 책임이 있기 때문에 SRP를 위반하고 의존관계상 클라이언트가 구현체에 의존하면서 DIP를 위반하고 자연스럽게 OCP도 위반할 가능성이 높다. 구현 코드Java123456789101112131415161718192021222324252627public class Coin { private static final int ADD_MORE_COIN = 10; private int coin; private static Coin instance = new Coin(); // eagerly loads the singleton private Coin() { // private to prevent anyone else from instantiating } public static Coin getInstance() { return instance; } public int getCoin() { return coin; } public void addMoreCoin() { coin += ADD_MORE_COIN; } public void deductCoin() { coin--; }} Kotlin123456789101112131415object Coin { private var coin: Int = 0 fun getCoin():Int { return coin } fun addCoin() { coin += 10 } fun deductCoin() { coin-- }} 멀티스레드 환경에서 싱글톤 생성지연 초기화(Lazy initialization)멀티 스레드에서 하나의 싱글톤 객체에 접근할 때 경쟁 상태(Race Condition)이 발생하여 여러개의 인스턴스가 생성될 수 있어 자바에서는 synchronized로 감싸서 지연 초기화를 더블체킹과함께 스레드 세이프하게 생성해야한다. 123456789101112131415161718public class Singleton { private static volatile Singleton instance = null; private Singleton() {} public static Singleton getInstance() { if (instance == null) { synchronized(Singleton.class) { if (instance == null) { instance = new Singleton(); } } } return instance; }} 완벽한 싱글톤을 만들기 위해앞서 제시한 싱글톤을 생성한 방법은 두가지 문제점이 있다 직렬화와 역직렬화 리플렉션싱글톤 클래스를 직렬화와 역직렬화 할 때 인스턴스가 새로 생성되어 싱글톤의 단일 인스턴스를 위반한다. 그리고 리플렉션을 이용하여 런타임에 싱글톤 private 생성자에 접근하여 새로운 인스턴스를 생성할 수 있다. 이 두가지 문제는 Enum을 통해 해결할 수 있다 123456789101112enum EnumSingleton { INSTANCE; String name; public String getName() { return name; } public void setName(String name) { this.name = name; }}// EnumSingleton singleton = EnumSingleton.INSTANCE; Enum은 직렬화와 역직렬화가 가능하기 때문에 별도의 Serializable을 구현하지 않아도 되고 리플렉션을 시도하려고 하면 NoSuchMethodException 이 발생하기 때문에 외부에서 싱글톤 인스턴스를 생성하는 것은 불가능하므로 완벽한 싱글톤 형태라고 불린다. 결론싱글톤은 이점이 있는 패턴이지만 앱 전역의 상태 관리를 하는데 있어서 안티패턴으로 간주된다. 이로 인해 싱글톤에 대한 잠재적인 종속성이 도입되어 실제 코드를 분석하기 위한 어려움과 크고 리팩토링에 대한 비용도 증가한다. 그리고 SOLID 원칙중 SRP, DIP, OCP를 위반 할 수 있고 이로인해 테스트하기 어렵다. 참고 SingletonVsJustCreateOne 싱글턴 패턴 - 위키백과 Singleton pattern - Wikipedia","link":"/2023/01/17/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4-Singleton-Pattern/"},{"title":"동시성(Concurrency)과 병렬성(Parallelism)","text":"동시성(Concurrency)동시성(Concurrency)은 Task들이 빠르게 전환하면서 실행되어 동시에 실행되는 것처럼 보이는 것입니다. 싱글 코어에서도 여러 작업은 동시적(Concurrent)으로 실행되며 Task간의 Context Switch가 발생하면서 여러 작업들을 동시에 실행하는 것처럼 보이게합니다. 하지만 동시성은 싱글 코어에서만 실행되는 것을 의미하지 않고 실제로는 멀티 코어에서 실행되는 상황이 더 많습니다. 즉, 동시성은 독립적인 작업을 작은 단위의 연산으로 나누어 시간 분할 형태로 연산하고 논리적으로 동시에 실행하는 것처럼 보이게하여 유휴 시간(Idle Time)을 최소화 하는 구조나 개념을 의미합니다. 📘 유휴시간이란? 컴퓨터가 작동 가능한데도 작업을 하지 않는 시간을 의미합니다. 동시성은 싱글 코어에서도 Concurrent하게 동작하는 Task에서 동기화 문제가 발생합니다. 공유된 자원을 서로 접근하려고 할 때 예상되지 않은 결과가 생길 수 있으므로 이때는 동기화 기법을 사용해주어야합니다. 병렬성(Parallelism)병렬성(Parallelism)은 물리적인 시간에 작업을 동시에 수행하는 것 입니다. 동시성과는 다르게 병렬성은 여러 작업들을 코어, 프로세스, 컴퓨터등으로 동시에 수행할 수 있으며 꼭 멀티 코어 한 개 이상의 스레드가 동시에 수행하는 것에만 한정하는 것은 아닙니다. 병렬성은 메모리 손상, 누수가 발생할 수 있습니다. 동시성(Concurrency) vs 병렬성(Parallelism)동시성과 병렬성을 비교 정리하자면 다음과 같다. 동시성 병렬성 동시에 실행되는 것 같이 보이는 것 실제로 동시에 여러 작업이 처리되는 것 싱글 코어에서 멀티 쓰레드(Multi thread)를 동작 시키는 방식 멀티 코어에서 멀티 쓰레드(Multi thread)를 동작시키는 방식 한번에 많은 것을 처리 한번에 많은 일을 처리 논리적인 개념 물리적인 개념 병렬성은 동시성에 포함되는 개념입니다. 또한 멀티 코어와 멀티 스레드에서 병렬성으로 작업하는 게 항상 성능상 이점이 있는 것은 아닙니다. I/O 요청 후 기다리는 작업이 많은 경우를 처리할 때 때로는 단일코어에서 동시성으로 처리 할 때 효율적일 수 있습니다. 동시성 여러 작업을 동시에 수행하므로 경합 상태(Race Condition), 데드락(Deadlock), **기아(Starvation)**과 같은 문제가 발생할 수 있으니 주의하여 개발해야한다. 참고 https://yeonyeon.tistory.com/270 https://seamless.tistory.com/42 https://seohs.tistory.com/461 https://www.baeldung.com/cs/concurrency-vs-parallelism https://inhyeokyoo.github.io/python/multiprocessing/ https://www.baeldung.com/cs/concurrency-vs-parallelism","link":"/2023/02/05/%EB%8F%99%EC%8B%9C%EC%84%B1-Concurrency-%EA%B3%BC-%EB%B3%91%EB%A0%AC%EC%84%B1-Parallelism/"},{"title":"kotlin default가 final인 이유","text":"평상시에 코틀린 파일을 디컴파일하면서 final로 선언되어있는 코드를 보면서 의문만 가지고 이유에 대해서 찾아보지 못하다가 이번 기회에 코틀린에서 default가 final인 이유에 대해서 찾아보았습니다. 제가 생각했을 때는 크게 두가지 이유가 있습니다. 첫번째는 코틀린은 함수형 프로그래밍에서 아이디어를 얻어왔고 가변을 사용했을 때 발생하는 문제점들을 줄이기 위해 불변을 사용합니다. 그래서 모든 클래스들이 기본값으로 final로 선언되어 있는 이유기도 합니다. 두번째는 상속에대한 문제입니다. 코틀린 공식 문서에 상속을 설명하는 부분을 보면 다음과 같은 문구가 있습니다. By default, Kotlin classes are final – they can’t be inherited. To make a class inheritable, mark it with the open keyword: 코틀린 클래스는 기본적으로 final이며 이는 상속이 불가능하게 합니다. 만약 상속이 가능하게 하려면 open키워드를 써야합니다. 라고 설명되어있습니다. 객체지향 관점에서 상속은 개발자들이 아직까지도 올바르게 사용하지 못하는 실수들을 하곤합니다. 무분별한 상속은 객체지향의 의도나 목적과는 반대로 설계할 가능성이 있습니다. 스택오버플로에서 상속보다 구성을 선호하는 원칙에 대해서 오래전 부터 논의한 내용이 있습니다. 그래서 제가 생각하기에는 코틀린은 클래스에 대해서 기본값을 final로 설정을하고 개발자들이 어떠한 문제를 마주했을 때 이 문제를 해결하기 위해서 상속을 사용하는 것 보다 더 나은 방법으로 문제를 해결할 수 있게 생각해보라는 의미로도 해석해 볼 수 있을 것 같습니다. 실제 글 작성 기준인 2023년 1월 28일 기준으로 코틀린 discuss의 Classes final by default 글에서 178명의 투표로 final이 52%, open이 48%로 비슷한 비율로 투표가 유지되고 있습니다. final 키워드는 프로퍼티 값을 Immutable하게 만들거나 클래스나 메서드를 상속이나 오버라이드 하지 못하게 만드는 특징이 있습니다. 그렇기 때문에 런타임에 다형성을 체크하지 않아 성능상의 약간의 이점을 가져갈 수 도 있습니다. 참고 Why are Kotlin classes final by default instead of open? Kotlin 디폴트가 final인 이유 Kotlin discuss - Classes final by default","link":"/2023/01/28/kotlin-default%EA%B0%80-final%EC%9D%B8-%EC%9D%B4%EC%9C%A0/"},{"title":"안드로이드 테스트 전용 모듈에서 효과적인 테스트하기","text":"이 글은 Shubham Garg님의 글을 번역한 글입니다. 안드로이드 앱을 다른 모듈로 모듈화하는 것은 코드 유지보수 및 빌드 성능에 이점이 있는지는 모두 알고 있습니다. 따라서 이 글에서는 계측 테스트에서도 동일하게 이 이점을 가져갈 수 있는지에 대해서 얘기해보려고합니다. 안드로이드 라이브러리 모듈과 앱 모듈은 디바이스에서 실행되는 테스트를 작성할 수 있는 androidTest와 JVM에서 로컬로 실행되는 test(unitTest)소스 세트가 있습니다. Robolectric같은 프레임워크를 사용하거나 안드로이드 프레임워크 의존성이 요구 될 때마다 더 빠르고 쉽게 실행하기 위해서 Mocks/Stubs 를 사용하거나 모든 테스트를 JVM에서 작성하고 싶을 때가 있습니다. 하지만 앱에서는 JVM머신으로 컴파일되지 않은 네이티브 라이브러리를 가질 수 있고 실제 디바이스에서 동작하는 테스트를 작성하고 싶을 때는 androidTest 소스 세트에서 작성해야 합니다. androidTest 소스 세트에서 테스트 코드를 작성함으로 팀내에서 개발자와 QA 모두 앱의 다양한 시나리오를 자동화 할 수 있습니다. 스크린샷 테스트, 네트워크 테스트, E2E 워크플로 테스트,퍼포먼스 테스트, 기타 등으로 구성된 앱 모듈에서 설정된 androidTest 소스 세트는 수백개에서 수천 개의 테스트로 인해 크기를 증가시킬 수 있고 이로 인해 새로운 테스트를 위한 안드로이드 테스트 APK를 생성하는 것 자체가 일반 APK 생성 시간보다 더 많은 시간이 걸립니다. Hilt나 Dagger 같은 플러그인을 사용한다면 더 상황이 나빠질 수 있습니다. 해당 테스트가 외부 요인 없이 로컬에서 작동해야하는지, 테스트가 특정 장치나 종속성에 의존하는지에 대한 결정하는 것은 어려울 수 있습니다. 어노테이션 효과적으로 관리하기 위해 새로운 어노테이션을 도입해야 할 수도 있습니다. 이것은 androidTest 코드가 시작할 때 관리하기 어려운 이유입니다. 테스트 코드를 모듈로 분리테스트코드를 유지보수하기 더 쉽게 만드는 방법은 androidTest 코드를 다른 gradle 모듈로 분리하는 것 입니다. 분리하는 방법 중 하나는 별도의 라이브러리 모듈을 만들어서 앱 모듈에 의존성을 포함하는 것입니다. 하지만 이렇게 하는 것은 생각보다 간단하지 않고 Manifest 머지 이슈를 마주할 수도 있습니다. 또한 main과 test 소스 세트가 필요하지 않은 새로운 라이브러리 모듈을 만들어야합니다. 안드로이드 테스트 모듈들이 분리되는 모습입니다. 이 모듈은 오직 계측 테스트만을 포함하고 앱 이나 다른 라이브러리 모듈을 의존하고 있는 특수 모듈입니다. 안드로이드 테스트 모듈 만들기안드로이드 테스트 만을 위한 모듈을 만들기 위해서는 다음과 같은 단계를 따라야합니다. 12345plugins { // This is a test only module. // All the tests inside this would run as Android Instrumentation Tests. id 'com.android.test'} 프로젝트에서 새로운 모듈을 만들고 모듈들의 build.gradle 파일에 ‘com.android.test’ 플러그인을 작성한다 새로운 모듈을 만들 때 안드로이드 스튜디오의 템플릿을 사용하고 라이브러리 모듈을 시작점으로 build.gradle 파일에서 com.android.library를 com.android.test 플러그인으로 교체해줍니다. 테스트할 프로젝트를 지정합니다 1234567android { // Here I am targeting the app module. targetProjectPath ':app' .... // If your app module has different flavors, you will have to declare the same here.} dependencies 블록에 일반적으로 프로젝트에서 사용하는 테스트 라이브러리 항목들을 정의합니다. 12345678910dependencies { implementation 'androidx.core:core-ktx:1.7.0' implementation 'androidx.appcompat:appcompat:1.5.1' implementation 'com.google.android.material:material:1.7.0' implementation 'junit:junit:4.13.2' implementation 'androidx.test.ext:junit:1.1.5' implementation 'androidx.test.espresso:espresso-core:3.5.1' implementation project(':app')} 테스트-Only 모듈에 첫번 째 테스트를 생성합니다. 모든 테스트 코드는 androidTest 소스 세트가 아닌 main 소스 세트 안에 있어야 합니다. 1234567891011class ExampleAppInstrumentedTest { @get:Rule val activityScenarioRule = ActivityScenarioRule(MainActivity::class.java) @Test fun testAppModuleActivity() { Espresso.onView(ViewMatchers.withId(com.example.testonlymodule.R.id.main_activity_view)) .check(ViewAssertions.matches(ViewMatchers.isDisplayed())) }} 계측 테스트를 Gradle 커맨드를 통해 실행해볼 수 있습니다.(moduleName은 실제 모듈의 이름으로 변경해야 합니다.) 1./gradlew :{moduleName}:connectedDebugAndroidTest 지금까지가 계측 테스트를 위해 테스트-Only 모듈을 설정하는 방법입니다. 전체 구현된 예제를 보려면 아래 저장소를 참고하세요. https://github.com/shubhamgarg1/TestOnlyModule Jacoco를 사용해서 앱의 모듈들에서 코드 커버리지를 생성할 수 있고 이런 테스트들을 헤드리스 에뮬레이터를 사용해서 실행할 수 있습니다(최소 AGP 버전 7.3.1) 보너스 : 다른 테스트 모듈간의 코드 공유테스트 모듈간에 코드를 공유하는 방법 모든 테스트 모듈들이 포함된 shared test 모듈을 생성하는것 입니다. shared test 모듈은 안드로이드가 테스트-Only 모듈이 다른 모듈에 포함하는 것을 허용하지 않으므로 라이브러리 모듈이어야 합니다. unit test와 android Test 소스세트들 사이에서 코드를 공유할 때와 동일한 개념으로 사용됩니다. 이전에는 2개의 소스세트에 공통 패키지를 포함하여 사용할 수 있었지만 Android Studio Chipmunk에서는 더 이상 불가능합니다. 네트워크 테스트와 퍼포먼스 테스트 모듈간의 공유가 가능한 유틸리티가 있다고 가정했을 때 Share Test Utility 모듈을 만들어서 공유할 수 있습니다. 결론com.android.test 플러그인을 사용하여 테스트 코드를 정리하고 더 유지보수가 쉽고 유연하게 도와주는 것을 알 수 있습니다. 이런 분리된 형태는 모든 커밋 후에 일부 테스트 모듈을 실행할지, 매일 한 번 테스트 모듈을 실행할지에 대한 결정을 도와줍니다.","link":"/2023/01/18/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%A0%84%EC%9A%A9-%EB%AA%A8%EB%93%88%EC%97%90%EC%84%9C-%ED%9A%A8%EA%B3%BC%EC%A0%81%EC%9D%B8-%ED%85%8C%EC%8A%A4%ED%8A%B8%ED%95%98%EA%B8%B0/"},{"title":"자료구조 - Collection","text":"Java Collection FrameworkJava Collection Framework란 일반적으로 재사용 가능한 컬렉션 데이터 구조를 구현하는 인터페이스 집합입니다. CollectionCollection은 여러 원소(Element)를 담을 수 있는 자료구조를 뜻합니다. 아래는 Collection.java 인터페이스를 정의한 모습입니다. 1public interface Collection&lt;E&gt; extends java.lang.Iterable&lt;E&gt; 아래는 Collection의 다이어그램 구조입니다. Collection Methods대표적인 Collection의 메서드들입니다. int size() : 컬렉션의 총 개수를 반환 boolean add(E e) : 컬렉션에 요소 추가 boolean addAll(Collection&lt;? extends E&gt;) : 컬렉션의 모든 요소를 해당 컬렉션에 추가 boolean remove(Object o) : 컬렉션에 요소 삭제 boolean removeAll(Collection&lt;? extends E&gt;) : 컬렉션의 모든 요소를 해당 컬렉션에 추가 void clear() : 컬렉션의 모든 요소 삭제 boolean contains(Object o) : 컬렉션이 전달받은 객체를 포함하는지 boolean equals(Object o) : 컬렉션과 전달된 오브젝트가 같은지 boolean isEmpty() : 컬렉션이 비어 있는지 Object [] toArray() : 해컬렉션의 모든 요소를 Object 타입의 배열로 반환 Collection 의 3가지 유형Collection을 상속받는 인터페이스 크게 3가지 입니다. Set List Queue List (Interface)List 인터페이스는 순서대로 엘리먼트들을 나열한 컬렉션이며 중복 요소를 포함 가능하고 인덱스로 모든 엘리먼트에 접근 가능한게 특징이입니다. List 인터페이스를 상속받아 구현된 대표적인 클래스는 ArrayList, LinkedList, Vector, Stack 이 있습니다. Set (Interface)Set 인터페이스는 엘리먼트의 집합을 표현한 컬렉션이며 중복 요소를 포함할 수 없고 iterator 또는 foreach를 이용하여 탐색합니다.Set 인터페이스로 구현된 클래스는 **HashSet, LinkedHashSet, TreeSet ** 이 있습니다. Queue (Interface)Queue는 먼저 집어 넣은 데이터가 먼저 나오는 FIFO (First In First Out)구조로 저장하는 형식을 말합니다. 기본 컬렉션 작업 외에도 Queue는 삽입, 추출 및 검사 작업을 제공한다. Quque 인터페이스로 구현된 클래스는 PriorityQueue 가 있습니다.","link":"/2022/12/27/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-Collection/"},{"title":"중재자 패턴(Mediator Pattern)","text":"중재자 패턴(Mediator Pattern)이란**중재자 패턴(Mediator Pattern)**은 객체간의 상호작용을 캡슐화하는 디자인 패턴으로 프로그램의 실행중 행위를 바꾸는 방법으로 Behavior Pattern에 속하게됩니다. 객체 지향 프로그래밍에서 프로그램은 일반적으로 비즈니스 로직이나 계산 처리로 분류된 수 많은 클래스들로 구성되어있고 이런 클래스간의 상호작용하는 커뮤니케이션이 많아질수록 유지보수나 리팩토링은 더 어려워집니다. 또한 하나의 클래스 코드에 변경이 발생하면서 다른 코드에도 영향을 미치게합니다. 중재자 패턴(Mediator Pattern)은 중재자라는 객체안에서 서로 다른 객체들을 캡슐화하여 객체들이 더 이상 직접적으로 상호작용하지않고 중재자를 통해서만 커뮤니케이션하도록 합니다. 이런 방법은 객체간의 커뮤니케이션에서 의존성을 줄이며 클래스간 느슨한 결합을 만듭니다. 목적과 사용 시점중재자 패턴은 서로 상호작용하는 오브젝트들을 캡슐화함으로써 느슨한 결합을 유지하기 위해 사용합니다. 만약 객체들 사이의 M : N 의 관계가 형성되어 복잡한 상호작용을 하고 있다면 이것을 M : 1 관계로 바꿔주어 상호작용을 원활하게 합니다. 즉, 해당 패턴은 객체 간의 많은 의존관계를 가지거나 상호작용이 복잡해 질 때 사용합니다. 구조 Mediator : Colleague 객체간의 커뮤니케이션을 위한 인터페이스 정의 Colleague : Mediator를 통해 다른 Colleague와 커뮤니케이션을 위한 인터페이스 정의 ConcreteMediator : Mediator 구현체로 Colleague들간의 상호 커뮤니케이션을 위해 Colleague들을 가지고 있으며 커뮤니케이션을 조정함 ConcreteColleague : Colleague 인터페이스 구현체 예제 1234interface Mediator { fun addUser(user: User) fun sendMessage(user: User, msg: String)} 12345interface User { val mediator: Mediator fun receive(msg: String) fun send(msg: String)} 123456789101112131415161718192021222324class ManUser( override val mediator: Mediator) : User { override fun receive(msg: String) { println(&quot;Man got msg: $msg&quot;) } override fun send(msg: String) { mediator.sendMessage(this, msg) }}class WomanUser( override val mediator: Mediator) : User { override fun receive(msg: String) { println(&quot;Woman got msg: $msg&quot;) } override fun send(msg: String) { mediator.sendMessage(this, msg) }} 1234567891011121314class UserMessageMediator : Mediator { private val userList = arrayListOf&lt;User&gt;() override fun addUser(user: User) { userList.add(user) } override fun sendMessage(user: User, msg: String) { userList.forEach { if (it != user) it.receive(msg) } }} 12345678910111213fun main() { val mediator = UserMessageMediator() val man = ManUser(mediator) val woman = WomanUser(mediator) mediator.addUser(man) mediator.addUser(woman) man.send(&quot;Hi, how are you?&quot;) woman.send(&quot;I am good!&quot;)}// Woman got msg: Hi, how are you?// Man got msg: I am good! 옵저버 패턴과의 차이옵저버 패턴은 1개의 발행자에 N개의 구독자가 존재하여 옵저버가 발행을 담당하고 중개자 패턴은 M개의 퍼블리셔와 N개의 구독자 사이에서 1개의 중개자를 통해 통신합니다. 옵저버 패턴은 재사용성은 좋지만 중개자 패턴은 애플리케이션의 로직에 맞추어 개발하기 때문에 재사용성 어렵습니다. 참고 [Design Pattern] 중재자 패턴 (Mediator Pattern) [디자인패턴] Mediator Pattern (중재자 패턴)","link":"/2023/02/02/%EC%A4%91%EC%9E%AC%EC%9E%90-%ED%8C%A8%ED%84%B4-Mediator-Pattern/"},{"title":"커맨드 패턴(Command Pattern)","text":"Command 패턴 이란?커맨드 패턴(Command pattern)이란 요청을 객체의 형태로 캡슐화하여 사용자가 보낸 요청을 나중에 이용할 수 있도록 매서드 이름, 매개변수 등 요청에 필요한 정보를 저장 또는 로깅, 취소할 수 있게 하는 패턴이다. 커맨드 패턴에 사용되는 4가지 주요 용어가 있다 명령(Command): 수신자의 정보 + 행동 수신자(Receiver): 행동을 하는 객체 발동자(Invoker): 커맨드를 저장하는 객체 클라이언트(Client): 커맨드 객체를 저장하고 발동하여 수신자에게 전달 안드로이드에서는 Thread 와 Runnable 이 대표적인 커맨드 패턴사례라고 볼 수 있다 Command 패턴 사용해 보기필자는 자동차를 좋아합니다. 뚜껑이 열리는 차를 부르는 방식이 각자 다른거 아시나요? 로드스터, 까브리올레, 컨버터블 등이 있습니다. 벤츠 모델은 까브리올레로 명칭하고 있고 포드 같은 미국 계열의 차는 컨버터블로 불리고 있습니다. 어떤 리모컨으로 자동차의 뚜껑을 열고 닫을 때 벤츠나 포드의 리모컨을 나누지 않고 하나의 리모컨으로 기능을 구현합니다. 예시는 다음과 같습니다. 자동차를 컨트롤하는 리모컨이 있음 차종에 관계 없이 차 뚜껑을 열고 닫을 수 있어야 함 위의 구현을 Command 패턴으로 구현해 보겠습니다. 먼저 뚜껑을 열고 닫는 Command Interface를 작성합니다. 123interface Command { fun openRoof()} 벤츠와 포드 자동차의 객체를 만듭니다. 두 자동차는 명칭과 동작하는 방식이 다르기 때문에 함수명이 다릅니다. 12345class BenzCar { fun openCabriolet() { println(&quot;Benz: Open Cabriolet&quot;) }} 12345class FordCar { fun openConvertible() { println(&quot;Ford: Open Convertible&quot;) }} 이제 Command를 Implement한 객체를 BenzCommand를 생성합니다. 1234567class BenzCommand( private val benzCar: BenzCar) : Command { override fun openRoof() { benzCar.openCabriolet() }} 1234567class FordCommand( private val fordCar: FordCar) : Command { override fun openRoof() { fordCar.openConvertible() }} 자 이제 실제로 만든 Command 패턴을 이용해 잘 동작되는지 확인해보겠습니다 1234567891011class RemoteController( private var command: Command? = null) { fun setCommand(command: Command) { this.command = command } fun openRoof() { command?.openRoof() }} Command를 이용해 차량을 컨트롤하는 RemoteController 클래스를 생성합니다. 테스트코드로 잘 동작되는지 확인해보겠습니다. 123456789101112131415class CommandUnitTest { private val remote: RemoteController = RemoteController() @Test fun testBenzCar() { remote.setCommand(BenzCommand(BenzCar())) remote.openRoof() } @Test fun testFordCar() { remote.setCommand(FordCommand(FordCar())) remote.openRoof() }} RemoteContrller 인스턴스를 생성하고 리모컨에 할당할 차량의 커맨드 인스턴스를 할당해줍니다.그리고 입력된 커맨드 인스턴스를 바탕으로 RemoteController의 open()을 실행해봅니다. 12Ford: Open ConvertibleBenz: Open Cabriolet 각 차량에 맞게 함수가 호출되었습니다. 앞서 말한 4가지 용어 중 각 해당 되는 클래스입니다. 명령(Command): Command 수신자(Receiver): BenzCommand, FordCommand 발동자(Invoker): RemoteController 클라이언트(Client): TestCode 장단점장점 시스템의 결합도를 낮춤 기존 코드를 수정하지 않고 새 커맨드를 이용하여 추가할 수 있음 명령 호출자와 수신자간의 의존성이 없음 단점 명령에 대한 클래스가 점점 늘어남 마무리커맨드 패턴을 활용하여 큐(Queue)에 저장하여 execute() 만 실행하여 작업큐 관련 작업에 사용 할 수 있습니다.","link":"/2023/01/19/%EC%BB%A4%EB%A7%A8%EB%93%9C-%ED%8C%A8%ED%84%B4-Command-Pattern/"},{"title":"페이징 교체 알고리즘(Paging Replacement Algorithm)","text":"페이징 교체 알고리즘 이란?페이지 교체 알고리즘(Paging Replacement Algorithm)은 페이징 기법으로 메모리를 관리하는 운영체제에서 페이지 부재(Page Fault)가 발생하여 새로운 페이지를 할당하기 위해 현재 할당된 페이지 중 어느 것과 교체할지를 결정하는 방법이다. 페이지 부재(Page Fault)는 실행중인 프로그램이 가상 메모리에 맵핑되었지만 실제 물리적 메모리에 로드되지 않은 메모리 페이지에 접근할 때 오류가 발생합니다. 물리적 메모리는 가상 메모리보다 작기 때문에 이러한 오류가 발생할 가능성이 높습니다. 이때 기존 페이지를 희생(Victim Page)하여 새로운 페이지를 교체하는 것이 페이징 교체 알고리즘입니다. 📘 Info 프레임: 물리 메모리를 일정 크기로 나눈 블록 페이지 : 가상 메모리를 일정한 크기로 나눈 블록 FIFO(First In First Out) 알고리즘 가장 먼저 메모리에 올라온 페이지를 가장 먼저 내보내는 알고리즘 구현은 간단하지만 성능에는 이점이 없음 들어온 시간을 저장 순서대로 저장하거나 큐를 이용해 저장 초기화 코드에 적절 할 수 있다 Belady’s anomaly 현상이 발생할 수 있다 Belady’s anomaly란 페이지 프레임이 증가되어도 페이지 부재(Page Fault)가 줄어들지 않고 늘어나는 현상. FIFO알고리즘에서 3개의 슬롯에서 3, 2, 1, 0, 3, 2, 4, 3, 2, 1, 0, 4가 수행될 때 9번의 페이지 부재가 나타나지만 슬롯을 4개로 늘린다면 페이지 부재가 10개로 오히려 늘어난다. OPT(Optimal) 알고리즘 가장 오랫동안 사용하지 않을 페이지를 교체 페이지 부재(Page Fault)가 알고리즘 중 가장 적으나 구현이 어렵다. 프로세스가 앞으로 사용할 페이지를 알아야함 LRU(Least Recently Uesd) 알고리즘 가장 오랫동안 사용하지 않은 페이지를 교체 최적 알고리즘과 비슷한 효과 많은 운영체제가 선택하는 성능이 좋은 알고리즘 기록을 TimeStamping에 오버헤드가 존재한다 MRU(Most Recently Used) 알고리즘 가장 참조 횟수가 많은 페이지를 교체하는 알고리즘 Belady’s anomaly 현상이 일어날 수 있다 참고 gyoogle / tech-interview-for-developer https://doh-an.tistory.com/28","link":"/2023/01/19/%ED%8E%98%EC%9D%B4%EC%A7%95-%EA%B5%90%EC%B2%B4-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Paging-Replacement-Algorithm/"}],"tags":[{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"Compose","slug":"Compose","link":"/tags/Compose/"},{"name":"Coroutine","slug":"Coroutine","link":"/tags/Coroutine/"},{"name":"Flow","slug":"Flow","link":"/tags/Flow/"},{"name":"Kotlin","slug":"Kotlin","link":"/tags/Kotlin/"},{"name":"RxJava","slug":"RxJava","link":"/tags/RxJava/"},{"name":"CS","slug":"CS","link":"/tags/CS/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"categories","slug":"categories","link":"/tags/categories/"},{"name":"Design Pattern","slug":"Design-Pattern","link":"/tags/Design-Pattern/"}],"categories":[{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"CS","slug":"CS","link":"/categories/CS/"},{"name":"Compose","slug":"Android/Compose","link":"/categories/Android/Compose/"},{"name":"Coroutine","slug":"Coroutine","link":"/categories/Coroutine/"},{"name":"Kotlin","slug":"Kotlin","link":"/categories/Kotlin/"},{"name":"RxJava","slug":"RxJava","link":"/categories/RxJava/"},{"name":"Flow","slug":"Coroutine/Flow","link":"/categories/Coroutine/Flow/"},{"name":"Data Structure","slug":"CS/Data-Structure","link":"/categories/CS/Data-Structure/"},{"name":"Coroutine","slug":"Kotlin/Coroutine","link":"/categories/Kotlin/Coroutine/"},{"name":"Design Pattern","slug":"Design-Pattern","link":"/categories/Design-Pattern/"},{"name":"Transforming","slug":"RxJava/Transforming","link":"/categories/RxJava/Transforming/"},{"name":"Creational","slug":"Design-Pattern/Creational","link":"/categories/Design-Pattern/Creational/"},{"name":"android","slug":"android","link":"/categories/android/"},{"name":"Behavioral","slug":"Design-Pattern/Behavioral","link":"/categories/Design-Pattern/Behavioral/"}],"pages":[{"title":"categories","text":"","link":"/categories/index.html"}]}