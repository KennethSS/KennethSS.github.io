<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>케니스의 개발 블로그</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="케니스의 개발 블로그"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="케니스의 개발 블로그"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="케니스의 개발 블로그"><meta property="og:url" content="http://example.com/"><meta property="og:site_name" content="케니스의 개발 블로그"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:author" content="John Doe"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"케니스의 개발 블로그","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"John Doe"},"publisher":{"@type":"Organization","name":"케니스의 개발 블로그","logo":{"@type":"ImageObject","url":"http://example.com/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="케니스의 개발 블로그" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item is-active" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/KennethSS"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-01-17T05:07:10.000Z" title="2023. 1. 17. 오후 2:07:10">2023-01-17</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-01-17T05:07:51.272Z" title="2023. 1. 17. 오후 2:07:51">2023-01-17</time></span><span class="level-item"><a class="link-muted" href="/categories/Design-Pattern/">Design Pattern</a></span><span class="level-item">7 minutes read (About 989 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/01/17/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4-Singleton-Pattern/">싱글톤 패턴 - Singleton Pattern</a></h1><div class="content"><h2 id="싱글톤-패턴"><a href="#싱글톤-패턴" class="headerlink" title="싱글톤 패턴"></a>싱글톤 패턴</h2><p>이번글에서는 디자인 패턴 중 하나인 싱글톤 패턴에 대해서 알아봅니다. </p>
<p>싱글톤 패턴은 객체 지향 소프트웨어에서 반복되는 문제를 해결하기 위해 잘 설명해진 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Design_Patterns">GoF 디자인 패턴</a> 중 하나입니다. 싱글톤 패턴은 클래스의 인스턴스화를 <strong>단일 인스턴스</strong>로 제한하는 패턴입니다. </p>
<h2 id="싱글톤-패턴의-특징"><a href="#싱글톤-패턴의-특징" class="headerlink" title="싱글톤 패턴의 특징"></a>싱글톤 패턴의 특징</h2><ul>
<li>오직 하나의 객체 인스턴스를 가진다</li>
<li>인스턴스에 접근하기 위한 쉬운 방법을 제공한다</li>
<li>인스턴스화를 컨트롤한다 (ex.클래스 생성자를 숨김)</li>
</ul>
<h4 id="싱글톤-패턴의-장점"><a href="#싱글톤-패턴의-장점" class="headerlink" title="싱글톤 패턴의 장점"></a>싱글톤 패턴의 장점</h4><p>싱글톤 패턴을 사용하여 인스턴스를 한 개로만 가져가면 아래와 같은 이점이 있습니다.</p>
<ul>
<li><strong>메모리 비용 절감</strong> : 객체를 생성할 때 마다 메모리를 할당 받는데 한번의 최초 한번의 new를 통해 객체를 생성한다면 고정된 메모리 영역의 사용으로 메모리 비용을 절감할 수 있다</li>
<li><strong>데이터 공유</strong> : 싱글톤 인스턴스는 전역으로 사용되는 인스턴스이기 때문에 다른 클래스의 인스턴스들과 데이터를 공유할 수 있다</li>
</ul>
<h4 id="싱글톤-패턴의-단점"><a href="#싱글톤-패턴의-단점" class="headerlink" title="싱글톤 패턴의 단점"></a>싱글톤 패턴의 단점</h4><p>싱글톤 패턴만의 장점도 분명하지만 반대로 안티패턴이라고 불릴만큼 단점도 많이 있습니다.</p>
<ul>
<li><strong>테스트하기 어려움</strong> : 많은 데이터를 공유할 수록 다른 클래스들 간의 결합도(Coupling)이 높아지고 개방-폐쇄원칙(OCP)을 위배하면서 테스트하기가 어려워짐</li>
<li><strong>멀티 스레드 처리</strong> : 멀티 스레드 환경에서 여러 인스턴스가 생성되는 것을 방지하기 위한 동기화 처리를 위해 syncronized 키워드를 사용해야하고 이는 많은 양의 코드를 작성을 요구함</li>
<li><strong>SOLID 원칙 위반(SRP, DIP, OCP)</strong> : 싱글톤은 Primary Function과 하나의 인스턴스만 생성 두 가지 책임이 있기 때문에 SRP를 위반하고 의존관계상 클라이언트가 구현체에 의존하면서 DIP를 위반하고 자연스럽게 OCP도 위반할 가능성이 높다.</li>
</ul>
<h2 id="구현-코드"><a href="#구현-코드" class="headerlink" title="구현 코드"></a>구현 코드</h2><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Coin</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ADD_MORE_COIN</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> coin;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Coin</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Coin</span>(); <span class="comment">// eagerly loads the singleton</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Coin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// private to prevent anyone else from instantiating</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Coin <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCoin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> coin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addMoreCoin</span><span class="params">()</span> &#123;</span><br><span class="line">        coin += ADD_MORE_COIN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deductCoin</span><span class="params">()</span> &#123;</span><br><span class="line">        coin--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a>Kotlin</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Coin &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> coin: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getCoin</span><span class="params">()</span></span>:<span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> coin</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addCoin</span><span class="params">()</span></span> &#123;</span><br><span class="line">        coin += <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">deductCoin</span><span class="params">()</span></span> &#123;</span><br><span class="line">        coin--</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="멀티스레드-환경에서-싱글톤-생성"><a href="#멀티스레드-환경에서-싱글톤-생성" class="headerlink" title="멀티스레드 환경에서 싱글톤 생성"></a>멀티스레드 환경에서 싱글톤 생성</h3><h4 id="지연-초기화-Lazy-initialization"><a href="#지연-초기화-Lazy-initialization" class="headerlink" title="지연 초기화(Lazy initialization)"></a>지연 초기화(Lazy initialization)</h4><p>멀티 스레드에서 하나의 싱글톤 객체에 접근할 때 경쟁 상태(Race Condition)이 발생하여 여러개의 인스턴스가 생성될 수 있어 자바에서는 synchronized로 감싸서 지연 초기화를 더블체킹과함께 스레드 세이프하게 생성해야한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>싱글톤은 이점이 있는 패턴이지만 앱 전역의 상태 관리를 하는데 있어서 안티패턴으로 간주된다. 이로 인해 싱글톤에 대한 잠재적인 종속성이 도입되어 실제 코드를 분석하기 위한 어려움과 크고 리팩토링에 대한 비용도 증가한다. 그리고 SOLID 원칙중 SRP, DIP, OCP를 위반 할 수 있고 이로인해 테스트하기 어렵다. </p>
<h3 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h3><ul>
<li><a target="_blank" rel="noopener" href="http://www.butunclebob.com/ArticleS.UncleBob.SingletonVsJustCreateOne">SingletonVsJustCreateOne</a></li>
<li><a target="_blank" rel="noopener" href="https://ko.wikipedia.org/wiki/%EC%8B%B1%EA%B8%80%ED%84%B4_%ED%8C%A8%ED%84%B4">싱글턴 패턴 - 위키백과</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Singleton_pattern">Singleton pattern - Wikipedia</a></li>
</ul>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-01-14T14:18:27.000Z" title="2023. 1. 14. 오후 11:18:27">2023-01-14</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-01-14T14:18:44.546Z" title="2023. 1. 14. 오후 11:18:44">2023-01-14</time></span><span class="level-item">2 minutes read (About 242 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/01/14/%EB%A9%94%EC%84%9C%EB%93%9C-%EC%8B%9C%EA%B7%B8%EB%8B%88%EC%B2%98-Method-signature-%EB%9E%80/">메서드 시그니처(Method signature)란</a></h1><div class="content"><p>메서드 시그니처(Method signature)란 무엇일까?</p>
<p>메서드 시그니처는 자바에서 프로그래머가 디자인한 메서드 구조를 의미하며 <strong>메서드 이름</strong>과 <strong>파라미터리스트로</strong> 구성됩니다. 작성된 코드는  Java 컴파일러에서 오버로딩된 함수들은 메서드 시그니처를 통해 식별합니다. </p>
<blockquote>
<p>같은 이름으로 선언하고 다른 파라미터 리스트(Signature)를 가진 것을 **메서드 오버로딩(Method Overloading)**이라고 부릅니다.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">square</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> &#123;</span><br><span class="line">	<span class="comment">///</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>하나의 클래스 안에서는 2개의 같은 시그니처를 가질 수 없습니다. 만약 두개의 같은 시그니처 메서드를  선언한다면 컴파일 에러가 발생합니다. 또한 메서드 시그니처는 메서드의 리턴타입을 포함하지 않습니다.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-01-13T18:35:38.000Z" title="2023. 1. 14. 오전 3:35:38">2023-01-14</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-01-13T18:36:47.434Z" title="2023. 1. 14. 오전 3:36:47">2023-01-14</time></span><span class="level-item">11 minutes read (About 1600 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/01/14/kotlin-sequence/">kotlin-sequence</a></h1><div class="content"><p>Kotlin standard library는 Collection과 함께 또 다른 유형인 <em>Sequences</em><code>(Sequence&lt;T&gt;)</code> 를 포함하고 있습니다. 컬렉션과는 달리 시퀀스는 엘리먼트를 포함하지 않으며 반복하는 동안 엘리먼트를 생성합니다. 시퀀스는 <code>Iterable</code>과 동일한 기능을 제공하지만 여러 단계 처리에 대한 다른 접근방식을 구현합니다.</p>
<p><code>Iterable</code>은  여러 과정을 처리할 때 각 단계를 완료하고 그 결과인 중간 컬렉션을 반환합니다. 시퀀스는 여러 과정의 처리에서 가능한 Lazily(나중에)하게 처리합니다. 이 의미는 시퀀스는 여러 단계의 처리는 바로 실행하지 않고 전체 단계가 처리된 결과가 요청되었을 때 실제 시퀀스 연산이 일어나면서 Lazily(나중에)하게 처리됩니다.</p>
<p>동작 실행 순서도 다르다고 할 수 있습니다. <code>Sequence</code>는 모든 단일 요소에 대해 처리를 One-By-One 형태로 수행하는 반면 <code>Iterable</code> 은 전체 컬렉션의 각 단계를 완료하고 그 다음 단계로 진행합니다.</p>
<p>따라서 시퀀스를 사용하면 중간 단계의 결과에 대한 처리를 피할 수 있습니다. 그러므로 전체 컬렉션의 체이닝 동작에서 퍼포먼스 향상을 기대할 수 있습니다. 그러나 이런 시퀀스의 Lazy 특성은 오히려 간단한 계산이나 작은 컬렉션을 처리할 때 불필요한 오버헤드가 발생할 수 있습니다. 이런 이유로 <code>Sequence</code>와 <code>Iterable</code> 사이에서 어떤것이 해당 케이스에서 더 효율적인지를 고려해야합니다.</p>
<h1 id="Construct"><a href="#Construct" class="headerlink" title="Construct"></a>Construct</h1><h4 id="From-elements"><a href="#From-elements" class="headerlink" title="From elements"></a>From elements</h4><p>시퀀스를 만들기 위해서는 <code>sequenceOf()</code> 함수를 호출하고 인자들을 나열하면 됩니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> numbersSequence = sequenceOf(<span class="string">&quot;four&quot;</span>, <span class="string">&quot;three&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;one&quot;</span>)</span><br></pre></td></tr></table></figure>



<h4 id="From-an-Iterable"><a href="#From-an-Iterable" class="headerlink" title="From an Iterable"></a>From an Iterable</h4><p><code>Iterable</code>객체(<code>List</code>와  <code>Set</code>등)를 <code>asSequence()</code>를 호출해서 시퀀스로 만들 수 있습니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> numbers = listOf(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>, <span class="string">&quot;four&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> numbersSequence = numbers.asSequence()</span><br></pre></td></tr></table></figure>

<h4 id="From-a-Function"><a href="#From-a-Function" class="headerlink" title="From a Function"></a>From a Function</h4><p>시퀀스의 요소들을 계산 할 수 있는 방식인 <code>generateSequence()</code>함수와 함께 구축하는 방법도 있습니다. 선택적으로 첫번째 인자를 명시적으로 선언할 수 있습니다. 이런 시퀀스 생성은 <code>null</code>을 반환하면 중지됩니다. 아래 예제를 보면 무한한 시퀀스가 있습니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> oddNumbers = generateSequence(<span class="number">1</span>) &#123; it + <span class="number">2</span> &#125; <span class="comment">// `it` is the previous element</span></span><br><span class="line"><span class="comment">//println(oddNumbers.take(5).toList()) // Result : [1, 3, 5, 7, 9]</span></span><br><span class="line"></span><br><span class="line">println(oddNumbers.count())     <span class="comment">// error: the sequence is infinite</span></span><br><span class="line"><span class="comment">// Result : Evaluation stopped while it&#x27;s taking too long️</span></span><br></pre></td></tr></table></figure>

<p> <code>generateSequence()</code>를 사용할 때 유한한 시퀀스를 만들기 위해서는 마지막 요소 다음에 null을 반환해야 합니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> oddNumbersLessThan10 = generateSequence(<span class="number">1</span>) &#123; <span class="keyword">if</span> (it &lt; <span class="number">8</span>) it + <span class="number">2</span> <span class="keyword">else</span> <span class="literal">null</span> &#125;</span><br><span class="line">println(oddNumbersLessThan10.count()) <span class="comment">// Result: 5</span></span><br></pre></td></tr></table></figure>

<h3 id="From-chunk"><a href="#From-chunk" class="headerlink" title="From chunk"></a>From chunk</h3><p>마지막으로 시퀀스를 임의의 크기의 덩어리로 생성할 수 있는 기능이 있습니다. 이 기능은 람다 함수내에서 호출할 수 있는 <code>yield()</code> 그리고 <code>yieldAll()</code> 함수입니다. 이 함수는 시퀀스 소비자에게 요소들을 반환하고 소비자가 다음 요소를 요청할 때 까지 <code>sequence()</code> 실행을 일시중단 합니다. <code>yield()</code>는 단일 요소를 인자로 가지고 <code>yieldAll()</code>은 <code>Iterable</code>객체를 인자로 가지고 <code>Iterator</code>나 다른 <code>Sequence</code>도 가질 수 있습니다. <code>yieldAll</code>에 인자로 들어가는 <code>Sequence</code>는 무한할 수 있지만 모든 후속 호출은 실행되지 않기 때문에 마지막에만 호출해야 합니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> oddNumbers = sequence &#123;</span><br><span class="line">    yield(<span class="number">1</span>)</span><br><span class="line">    yieldAll(listOf(<span class="number">3</span>, <span class="number">5</span>))</span><br><span class="line">    yieldAll(generateSequence(<span class="number">7</span>) &#123; it + <span class="number">2</span> &#125;)</span><br><span class="line">&#125;</span><br><span class="line">println(oddNumbers.take(<span class="number">5</span>).toList())</span><br></pre></td></tr></table></figure>



<h2 id="Sequence-operations"><a href="#Sequence-operations" class="headerlink" title="Sequence operations"></a>Sequence operations</h2><p>시퀀스 동작은 상태요구에 따라서 그룹별로 분류될 수 있습니다. </p>
<ul>
<li><code>map()</code>이나 <code>filter()</code>과 같은 스테이트리스(Stateless) 동작은 상태나 각 요소들간의 의존적인 과정을 요구하지 않지만 <code>take()</code> 나 <code>drop()</code>처럼 적은 양을 가진 상수의 상태는 요구할 수 있습니다.</li>
<li>스테이트풀(Stateful) 동작은 시퀀스에서 비례하는 요소들의 숫자만큼 상당한 양의 상태가 필요합니다.</li>
</ul>
<p>시퀀스 동작이 Lazliy하게 생성된 다른 시퀀스를 리턴하면 그것을 <code>itermediate</code>라 하고 다른 동작은 <code>terminal</code>이라고 합니다.<code>terminal</code>의 수행 동작의 예로는 <code>toList()</code> 또는 <code>sum()</code>이 있습니다. 시퀀스 요소들은 오직 <code>terminal</code>이라는 동작으로만 얻어질 수 있습니다. </p>
<p>시퀀스는 여러번의 Iteration이 가능하지만 일부 시퀀스의 구현은 한번만 반복으로 되도록 제한되어 있습니다. 해당 내용은 문화되어있습니다.</p>
<h2 id="Sequence-processing-example"><a href="#Sequence-processing-example" class="headerlink" title="Sequence processing example"></a>Sequence processing example</h2><p><code>Iterable</code>과 <code>Sequnce</code>의 차이를 예제로 살펴보겠습니다.</p>
<h4 id="Iterable"><a href="#Iterable" class="headerlink" title="Iterable"></a>Iterable</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> words = <span class="string">&quot;The quick brown fox jumps over the lazy dog&quot;</span>.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="keyword">val</span> lengthsList = words.filter &#123; println(<span class="string">&quot;filter: <span class="variable">$it</span>&quot;</span>); it.length &gt; <span class="number">3</span> &#125;</span><br><span class="line">    .map &#123; println(<span class="string">&quot;length: <span class="subst">$&#123;it.length&#125;</span>&quot;</span>); it.length &#125;</span><br><span class="line">    .take(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">println(<span class="string">&quot;Lengths of first 4 words longer than 3 chars:&quot;</span>)</span><br><span class="line">println(lengthsList)</span><br><span class="line"><span class="comment">// Result</span></span><br><span class="line"><span class="comment">// filter: The</span></span><br><span class="line"><span class="comment">// filter: quick</span></span><br><span class="line"><span class="comment">// filter: brown</span></span><br><span class="line"><span class="comment">// filter: fox</span></span><br><span class="line"><span class="comment">// filter: jumps</span></span><br><span class="line"><span class="comment">// filter: over</span></span><br><span class="line"><span class="comment">// filter: the</span></span><br><span class="line"><span class="comment">// filter: lazy</span></span><br><span class="line"><span class="comment">// filter: dog</span></span><br><span class="line"><span class="comment">// length: 5</span></span><br><span class="line"><span class="comment">// length: 5</span></span><br><span class="line"><span class="comment">// length: 5</span></span><br><span class="line"><span class="comment">// length: 4</span></span><br><span class="line"><span class="comment">// length: 4</span></span><br><span class="line"><span class="comment">// Lengths of first 4 words longer than 3 chars:</span></span><br><span class="line"><span class="comment">// [5, 5, 5, 4]</span></span><br></pre></td></tr></table></figure>

<p>위의 예제를 보면 단어 리스트에서 길이가 3을 초과하는 <code>filter()</code>와 필터링된 문자열 길이를 <code>map()</code> 이 순서대로 호출되는걸 볼 수 있습니다. 순차적으로 filter의 모든 요소들이 수행되고 리턴된 결과로 map이 수행됩니다.</p>
<p><img src="https://kotlinlang.org/docs/images/list-processing.png" alt="image"></p>
<h4 id="Sequence"><a href="#Sequence" class="headerlink" title="Sequence"></a>Sequence</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> words = <span class="string">&quot;The quick brown fox jumps over the lazy dog&quot;</span>.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="comment">//convert the List to a Sequence</span></span><br><span class="line"><span class="keyword">val</span> wordsSequence = words.asSequence()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> lengthsSequence = wordsSequence.filter &#123; println(<span class="string">&quot;filter: <span class="variable">$it</span>&quot;</span>); it.length &gt; <span class="number">3</span> &#125;</span><br><span class="line">    .map &#123; println(<span class="string">&quot;length: <span class="subst">$&#123;it.length&#125;</span>&quot;</span>); it.length &#125;</span><br><span class="line">    .take(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">println(<span class="string">&quot;Lengths of first 4 words longer than 3 chars&quot;</span>)</span><br><span class="line"><span class="comment">// terminal operation: obtaining the result as a List</span></span><br><span class="line">println(lengthsSequence.toList())</span><br><span class="line"><span class="comment">// Result</span></span><br><span class="line"><span class="comment">// Lengths of first 4 words longer than 3 chars</span></span><br><span class="line"><span class="comment">// filter: The</span></span><br><span class="line"><span class="comment">// filter: quick</span></span><br><span class="line"><span class="comment">// length: 5</span></span><br><span class="line"><span class="comment">// filter: brown</span></span><br><span class="line"><span class="comment">// length: 5</span></span><br><span class="line"><span class="comment">// filter: fox</span></span><br><span class="line"><span class="comment">// filter: jumps</span></span><br><span class="line"><span class="comment">// length: 5</span></span><br><span class="line"><span class="comment">// filter: over</span></span><br><span class="line"><span class="comment">// length: 4</span></span><br><span class="line"><span class="comment">// [5, 5, 5, 4]</span></span><br></pre></td></tr></table></figure>

<p>코드의 결과물을 보면 프린트가 먼저 출력된 것을 통해  <code>filter()</code>와 <code>map()</code> 함수들이 시퀀스를 리스트로 치환할 때 호출되면서 시퀀스의 시작이 실제로 필요로 할 때 시작되는 것을 알 수 있습니다. 또한 <code>map()</code>은 <code>filter()</code>에서 요소를 리턴하자 마자 실행됩니다. 그리고 <code>take(4)</code>로 4개의 요소만 필요하기 때문에 시퀀스 처리가 만족하는 개수가 4개가 되었을 때 수행은 정지된다.</p>
<p><img src="https://kotlinlang.org/docs/images/sequence-processing.png" alt="image"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-01-12T01:24:26.000Z" title="2023. 1. 12. 오전 10:24:26">2023-01-12</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-01-12T01:34:26.394Z" title="2023. 1. 12. 오전 10:34:26">2023-01-12</time></span><span class="level-item"><a class="link-muted" href="/categories/RxJava/">RxJava</a><span> / </span><a class="link-muted" href="/categories/RxJava/Transforming/">Transforming</a></span><span class="level-item">a minute read (About 143 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/01/12/RxJava-Scan/">RxJava - Scan</a></h1><div class="content"><h2 id="Scan"><a href="#Scan" class="headerlink" title="Scan"></a>Scan</h2><p><strong>Scan</strong>은 Observable이 발행하는 각 항목에 대해서 순차적으로 작성한 함수의 결과를 적용하고 값을 내보냅니다. </p>
<p><img src="https://reactivex.io/documentation/operators/images/scan.png" alt="Scan"></p>
<p><strong>Scan</strong> 연산자는 <strong>Reduce</strong>와 비슷하지만 조금 다릅니다. Observable에서 발행된 첫번째 아이템은 그대로 결과로 전달하고 그 이후 부터는 중간 결과 값과 최종 결과를 구독자에게 발행합니다.</p>
<h3 id="샘플-코드"><a href="#샘플-코드" class="headerlink" title="샘플 코드 ()"></a>샘플 코드 ()</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1, 2, 3</span></span><br><span class="line">observable</span><br><span class="line">    .scan &#123; t1, t2 -&gt;</span><br><span class="line">        println(<span class="string">&quot;Scan <span class="variable">$t1</span> to <span class="variable">$t2</span>&quot;</span>)</span><br><span class="line">        t1 + t2</span><br><span class="line">    &#125;.subscribe(::printSubscribe)</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Result: 1</span><br><span class="line">Scan 1 to 2</span><br><span class="line">Result: 3</span><br><span class="line">Scan 3 to 3</span><br><span class="line">Result: 6</span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-01-08T14:00:56.000Z" title="2023. 1. 8. 오후 11:00:56">2023-01-08</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-01-11T05:39:18.592Z" title="2023. 1. 11. 오후 2:39:18">2023-01-11</time></span><span class="level-item">13 minutes read (About 1952 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/01/08/ViewModel%EC%9D%B4-%ED%99%94%EB%A9%B4%ED%9A%8C%EC%A0%84%EC%97%90%EB%8F%84-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EC%9C%A0%EC%A7%80%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94-%EC%9D%B4%EC%9C%A0/">ViewModel이 화면회전에도 데이터를 유지할 수 있는 이유</a></h1><div class="content"><p>안드로이드에서 구성변경(Configuration Change)이 발생할 때 ViewModel 객체는 Activity가 재생성 되더라도 파괴되지 않고 객체가 유지 되는것을 볼 수 있습니다. </p>
<blockquote>
<p>여기서의 ViewModel은 MicroSoft에서 제시한 MVVM의 ViewModel 아닌 Android Architecture Component의 ViewModel 입니다.</p>
</blockquote>
<p>Activity의 마지막 생명주기인 onDestroy()은 파괴되고 사라지기전에 호출되는 생명주기 마지막 오버라이드 함수인 이후 호출되는 ViewModel의 생명주기 중 하나인 onCleared()에서 여러가지 해제하는 작업들을 합니다.</p>
<p>하지만 여기서 하나 의문점은 Activity의 종료가 구성변경과 같은 재생성에 의한 종료인지 finish()를 통한 종료인지 ViewModel은 어떻게 알 수 있을까요?</p>
<p>만약 단순 구성변경으로 발생한 Activity의 종료일 때 ViewModel의 onCleared()에서 여러 작업들을 해제한다면 사용자들은 잘못된 정보를 전달 받을 확률이 높습니다. 이 때문에 Activity가 재생성으로 인한 파괴(Destroy)라는 것을 파악하고 전파해야 합니다. 어떻게 이런 동작들이 이루어지는지 ViewModel과 Activity의 내부 코드들을 차근차근 살펴보려고 합니다.</p>
<p>아래 그림은 Activity와 ViewModel의 라이프사이클을 순서를 나타내는 이미지입니다.</p>
<p><img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-viewmodel/img/18e67dc79f89d8a.png?hl=ko" alt="img"></p>
<p>일단, 가장 먼저 ViewModel에서 onCleared()가 호출되는 함수를 따라가보겠습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ViewModel</span> &#123; </span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;WeakerAccess&quot;)</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCleared</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">///..</span></span><br><span class="line">      onCleared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ViewModel에서 onCleared()는 final 함수인 clear()에서 호출이됩니다. 이 clear()는 누가 호출하는지 따라가보면 ViewModelStore라는 객체에서 호출하는 것을 볼 수 있습니다.</p>
<p><strong>ViewModelStore</strong>는 ViewModel들을 Map 형태로 저장하기는 코드로 구성 되어있습니다. ViewModelStore의 클래스 내부를 살펴보면 String Key값과 ViewModel Value를 가지는 해시맵을 가지고 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ViewModelStore</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, ViewModel&gt; mMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, ViewModel viewModel)</span> &#123;</span><br><span class="line">        <span class="type">ViewModel</span> <span class="variable">oldViewModel</span> <span class="operator">=</span> mMap.put(key, viewModel);</span><br><span class="line">        <span class="keyword">if</span> (oldViewModel != <span class="literal">null</span>) &#123;</span><br><span class="line">            oldViewModel.onCleared();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ViewModel <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;String&gt; <span class="title function_">keys</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(mMap.keySet());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Clears internal storage and notifies ViewModels that they are no longer used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (ViewModel vm : mMap.values()) &#123;</span><br><span class="line">            vm.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        mMap.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이 클래스는 단순히 해시맵에 <code>put</code>과<code>get</code>하기 위한 함수들을 제공합니다. 해시맵에 들어가는 키 값은 기본값으로는 <code>androidx.lifecycle.ViewModelProvider.DefaultKey:modelClass.canonicalName</code>로 생성합니다.</p>
<p><code>clear()</code>를 보면 해시맵의 Value들을 재귀하여 ViewModel의 <code>clear()</code>를 호출하고 해시맵을 <code>clear()</code> 하는 것을 볼 수 있습니다. 결국 이 <code>ViewModelStore</code> 가 ViewModel의 <code>clear()</code>를 호출하는 것을 알아냈고 이 함수는 <code>ComponentActivity</code>에서 호출되는 것을 확인할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ComponentActivity</span><span class="params">()</span> &#123;</span><br><span class="line">  getLifecycle().addObserver(<span class="keyword">new</span> <span class="title class_">LifecycleEventObserver</span>() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStateChanged</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> LifecycleOwner source,</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> Lifecycle.Event event</span></span><br><span class="line"><span class="params">      )</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (event == Lifecycle.Event.ON_DESTROY) &#123;</span><br><span class="line">              <span class="comment">// Clear out the available context</span></span><br><span class="line">              mContextAwareHelper.clearAvailableContext();</span><br><span class="line">              <span class="comment">// And clear the ViewModelStore</span></span><br><span class="line">              <span class="keyword">if</span> (!isChangingConfigurations()) &#123;</span><br><span class="line">                  getViewModelStore().clear();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ComponentActivity</code>에서는 <code>LifecycleEventObserver</code>를 라이프사이클에 관찰자로 등록하고 <code>onDestroy</code> 와 <code>!isChangingConfigurations()</code>가 두개 모두 만족할 경우 <code>ViewModelStore</code>의 <code>clear()</code>가 호출되어 ViewModel까지 전달되는 것을 볼 수 있습니다. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Activity</span> &#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">mChangingConfigurations</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isChangingConfigurations</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mChangingConfigurations;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>isChangingConfigurations()</code>는 <code>Activity</code> 클래스의 내부 멤버변수인 <code>mChangingConfigurations</code>를 리턴해주는 함수입니다. 이제 이 <code>mChangingConfigurations</code>를 <code>true</code> 혹은 <code>false</code>로 변경하는 곳이 어디인지를 찾으면 됩니다.</p>
<p>해답은 <code>ActivityThread</code>에 있었습니다. 이 클래스는 액티비티 매니저의 요청들을 어플리케이션 프로세스에서 메인스레드로 실행할 수 있게 Activity나 Broadcast 그리고 다른 작업들을 스케쥴링하고 실행하는 것을 관리해주는 클래스입니다.</p>
<p>이 클래스에 오버라이드된 <code>activityLocalRelaunch()</code>를 살펴보면 <code>ActivityClientRecord</code>에 기록된 activity에 <code>mChangingConfiguration</code>을 <code>true</code>로 설정해준 것을 확인할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRelaunchActivity</span><span class="params">(</span></span><br><span class="line"><span class="params">  ActivityClientRecord tmp,</span></span><br><span class="line"><span class="params">  PendingTransactionActions pendingActions</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">  <span class="type">ActivityClientRecord</span> <span class="variable">r</span> <span class="operator">=</span> mActivities.get(tmp.token);</span><br><span class="line">  r.activity.mChangingConfigurations = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>여기까지 mChangingConfigurations의 변수를 통해 getViewModelStore().clear()가 실행여부를 밝혀냈습니다. 하지만  여기서 ViewModel의 생성도 결국 Activity에서 이루어지는데 Activity가 완전히 파괴되고 다시 만들어질 때 ViewModel의 인스턴스를 어떻게 유지할지에 대한 궁금증이 생깁니다. 여기에는 ViewModelStoreOwner에 해답이 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ViewModelStoreOwner</span> &#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    ViewModelStore <span class="title function_">getViewModelStore</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ViewModelStoreOwner 인터페이스 주석 설명을 보면 이 인터페이스 구현체의 책임은 구성 변경중에도 ViewModelStore를 유지하고 이 범위가 파괴될 때 <code>ViewModelStore.clear()</code>를 호출하는 것이라고 적혀있습니다.</p>
<p>즉, ViewModelStoreOwner는 각 Owner(일반적으로 Activity, Fragment가 해당 됩니다.)들이 구성변경이 일어나서 파괴되고 재생성되어도 인스턴스를 유지하는 역할을 합니다. 만약 Activity나 Fragment같은 Owner들은 완전히 파괴되고 재생성될 여지가 없다면 에서 ViewModelStore객체에 clear()를 호출하여 더이상 ViewModel이 사용되지 않는다는 사실을 전파해야합니다.</p>
<p>ViewModelStoreOwner의 구현체인 <code>ComponentActivity</code>의 코드를 확인해보겠습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ViewModelStore <span class="title function_">getViewModelStore</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (getApplication() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Your activity is not yet attached to the &quot;</span></span><br><span class="line">                + <span class="string">&quot;Application instance. You can&#x27;t request ViewModel before onCreate call.&quot;</span>);</span><br><span class="line">    &#125;    <span class="comment">//This is true when invoked for the first time</span></span><br><span class="line">    <span class="keyword">if</span> (mViewModelStore == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">NonConfigurationInstances</span> <span class="variable">nc</span> <span class="operator">=</span></span><br><span class="line">                (NonConfigurationInstances) getLastNonConfigurationInstance();</span><br><span class="line">        <span class="keyword">if</span> (nc != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Restore the ViewModelStore from NonConfigurationInstances</span></span><br><span class="line">            mViewModelStore = nc.viewModelStore;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mViewModelStore == <span class="literal">null</span>) &#123;</span><br><span class="line">            mViewModelStore = <span class="keyword">new</span> <span class="title class_">ViewModelStore</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mViewModelStore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>코드를 살펴보면 <code>getLastNonConfigurationInstane()</code>를 호출하여  <code>NoConfigurationInstance</code>라는 클래스를 캐스팅해서 가져온 후 <code>ComponentActivity</code>의 ViewModelStore 멤버변수로서 할당해줍니다. Activity가 구성변경에 의해 재생성될 때  ComponentActivity에 있는 <code>NonConfigurationInstance</code>클래스는 이전 <code>ViewModelState</code>의 인스턴스를 포함하고 있습니다.  Activity가 처음 생성될 때 <code>NonConfigurationInstance</code>는 null을 반환하고 그런 경우에는 <code>ViewModelStore</code>를 새로 생성합니다.</p>
<p>조금더 내부 코드를 살펴보겠습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Activity.java</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getLastNonConfigurationInstance</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> mLastNonConfigurationInstances != <span class="literal">null</span></span><br><span class="line">    ? mLastNonConfigurationInstances.activity : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ComponentActivity.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">onRetainNonConfigurationInstance</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// Maintain backward compatibility.</span></span><br><span class="line">  <span class="type">Object</span> <span class="variable">custom</span> <span class="operator">=</span> onRetainCustomNonConfigurationInstance();</span><br><span class="line"></span><br><span class="line">  <span class="type">ViewModelStore</span> <span class="variable">viewModelStore</span> <span class="operator">=</span> mViewModelStore;</span><br><span class="line">  <span class="keyword">if</span> (viewModelStore == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// No one called getViewModelStore(), so see if there was an existing</span></span><br><span class="line">    <span class="comment">// ViewModelStore from our last NonConfigurationInstance</span></span><br><span class="line">    <span class="type">NonConfigurationInstances</span> <span class="variable">nc</span> <span class="operator">=</span></span><br><span class="line">      (NonConfigurationInstances) getLastNonConfigurationInstance();</span><br><span class="line">    <span class="keyword">if</span> (nc != <span class="literal">null</span>) &#123;</span><br><span class="line">      viewModelStore = nc.viewModelStore;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (viewModelStore == <span class="literal">null</span> &amp;&amp; custom == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">NonConfigurationInstances</span> <span class="variable">nci</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NonConfigurationInstances</span>();</span><br><span class="line">  nci.custom = custom;</span><br><span class="line">  nci.viewModelStore = viewModelStore;</span><br><span class="line">  <span class="keyword">return</span> nci;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Activity가 구성변경이 발생하여 재생성될 때 ComponentActivity 의 <code>onRetainNonConfigurationInstance</code> 함수가 호출되고 <code>NonConfigurationInstance(ComponentActivity.java)</code>의 객체를<code>getLastNonConfigurationInstance()</code>를 호출하여 Activity의 mLastNonConfigurationInstances.activity를 반환받는데 이 객체는 안드로이드 시스템에서 재생성된 후의 액티비티를 전달한 것입니다.</p>
<p>Activity가 재생성후에 <code>Activity.java</code>클래스에서 mLastNonConfigurationInstances 객체는 <code>attach()</code>에서 lastNonConfigurationInstances를 전달받아 mLastNonConfigurationInstances에 할당합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(Context context, ActivityThread aThread,</span></span><br><span class="line"><span class="params">            Instrumentation instr, IBinder token, <span class="type">int</span> ident,</span></span><br><span class="line"><span class="params">            Application application, Intent intent, ActivityInfo info,</span></span><br><span class="line"><span class="params">            CharSequence title, Activity parent, String id,</span></span><br><span class="line"><span class="params">            NonConfigurationInstances lastNonConfigurationInstances,</span></span><br><span class="line"><span class="params">            Configuration config, String referrer, IVoiceInteractor voiceInteractor,</span></span><br><span class="line"><span class="params">            Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken,</span></span><br><span class="line"><span class="params">            IBinder shareableActivityToken)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h1><p>지금까지 ViewModel이 구성변경에도 인스턴스를 유지하는 방법과 <code>onCleared()</code>의 호출 조건을 알아보았습니다. </p>
<p>ViewModel의 인스턴스 유지 과정을 살펴보니 Activity에 대한 코드의 이해도도 증가되고 ViewModel의 구성방식들도 이해하게되어 좋았습니다. 안드로이드 개발자라면 ViewModel을 잘 활용하여 구성변경에도 데이터를 유지하여 사용자 경험을 증진시키는게 하나의 임무라고 생각합니다 :smile:  긴글 봐주셔서 감사합니다.</p>
<h2 id="레퍼런스"><a href="#레퍼런스" class="headerlink" title="레퍼런스"></a>레퍼런스</h2><ul>
<li><a target="_blank" rel="noopener" href="https://blog.mindorks.com/android-viewmodels-under-the-hood/">https://blog.mindorks.com/android-viewmodels-under-the-hood/</a></li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-01-08T03:13:44.000Z" title="2023. 1. 8. 오후 12:13:44">2023-01-08</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-01-12T01:20:03.543Z" title="2023. 1. 12. 오전 10:20:03">2023-01-12</time></span><span class="level-item"><a class="link-muted" href="/categories/Coroutine/">Coroutine</a></span><span class="level-item">14 minutes read (About 2110 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/01/08/coroutine/">기본 코루틴(Coroutine Basics)</a></h1><div class="content"><h2 id="첫번째-코루틴-Your-first-coroutine"><a href="#첫번째-코루틴-Your-first-coroutine" class="headerlink" title="첫번째 코루틴(Your first coroutine)"></a>첫번째 코루틴(Your first coroutine)</h2><p>코루틴은 일시 중단 가능한 계산의 인스턴스입니다. 코드의 블록들이 다른 코드 들과 동시에 동작해야 한다는 점에서는 개념적으로 스레드와 유사합니다. 하지만 코루틴은 </p>
<p>나머지 코드와 동시에 작동하는 코드들이 하나의 블럭에서 실행해야  코드의 블럭이 실행될 때 동시적으로 실행할 수 있습니다. 그러나 코루틴은 특정한 스레드에 바운드 되지 않고 한 스레드에서 일시 중단하고 다른 스레드에서 다시 재개할 수 있습니다.</p>
<p>코루틴은 경량 스레드라고 생각할 수 있습니다. 하지만 실제 우리가 사용하는 스레드와는 다르게 만드는 중요한 요소들이 있습니다.</p>
<p>다음 코드를 실행하여 첫번째 코루틴 작업을 확인해봅니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123; <span class="comment">// this: CoroutineScope</span></span><br><span class="line">    launch &#123; <span class="comment">// launch a new coroutine and continue</span></span><br><span class="line">        delay(<span class="number">1000L</span>) <span class="comment">// non-blocking delay for 1 second (default time unit is ms)</span></span><br><span class="line">        println(<span class="string">&quot;World!&quot;</span>) <span class="comment">// print after delay</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Hello&quot;</span>) <span class="comment">// main coroutine continues while a previous one is delayed</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// result</span></span><br><span class="line">Hello</span><br><span class="line">World!</span><br></pre></td></tr></table></figure>

<p>다음과 같은 결과가 나오는 걸 볼 수 있습니다.</p>
<p>한번 이 코드가 무엇인지 해부해보겠습니다</p>
<p><code>launch</code>는 코루틴 빌더입니다. <code>launch</code>는 새로운 코루틴을 실행함과 동시에 나머지 코드들을 독립적으로 계속 작업합니다. 그것이 <code>Hello</code>가 첫번째로 프린트된 이유입니다.</p>
<p><code>delay</code> 는 특별한 일시중단 함수입니다. 코루틴을 특정 시간동안 일시 중단합니다. 코루틴을 일시중단해도 기본스레드가 차단되지는 않으며 다른 코루틴들도 기본스레드를 사용하여 코루틴을 실행하할 수 있습니다.</p>
<p><code>runBlocking</code>은  <code>fun main()</code> 과 같은 기본적인 코루틴이 아닌 세계와  <code>runBlocking &#123; ... &#125;</code> 중괄호 안에 있는 코루틴 코드들을 연결하는 코루틴 빌더입니다. <code>runBlocking</code> 코드를 작성해보면 IDE에서 중괄호 바로 뒤에 CoroutineScope라는 힌트가 표시됩니다.</p>
<p><code>launch</code>는 CoroutineScope에서만 선언이 가능하기 때문에 만약 깜빡하고 <code>runBlocking</code>을 코드에서 제거한다면  <code>launch</code>를 호출할 때 에러가 발생합니다. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unresolved reference: launch</span><br></pre></td></tr></table></figure>

<p><code>runBlocking</code> 은 의미는 <code>runBlocking &#123; ... &#125;</code> 내부의 모든 코루틴들이 실행이 완료 될 때까지 이를 실행하는 스레드(메인스레드라고 가정)는 차단된다는 것을 의미합니다. 스레드는 차단하는 것은 스레드의 비용이 비싸기 때문에 비효율적이지만 실제코드에서는 앱의 최상위 레벨에서 runBlcoking 자주 사용되는 것을 볼 수 있습니다.</p>
<h3 id="구조화된-동시성-Structured-concurrency"><a href="#구조화된-동시성-Structured-concurrency" class="headerlink" title="구조화된 동시성(Structured concurrency)"></a>구조화된 동시성(Structured concurrency)</h3><p>코루틴 <strong>구조화된 동시성</strong>을 원칙을 따릅니다. 즉, 구조화된 동시성이란 새로운 코루틴은 오직 코루틴의 수명을 제한하는 특정한 <a target="_blank" rel="noopener" href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/">CoroutineScope</a>에서만 실행될 수 있다는 것을 의미합니다. 위의 예제에서는 <code>runBlocking</code> 해당하는 스코프를 설정하고 World!는 몇초뒤에 프린트 된 것을 볼 수 있습니다.</p>
<p>실제 앱에서는 많은 양의 코루틴을 실행해야합니다. 구조화된 동시성은 손실이나 릭을 발생하지 않게 보장합니다. 외부 범위는 모든 하위 코루틴이 완료될 때까지 완료할 수 없습니다. 또한 구조화된 동시성은은 코드에서 발생한 모든 에러가 올바르게 보고되고 손실이 발생하지 않게 합니다.</p>
<hr>
<h2 id="함수-추출-리팩토링-Extract-function-refactoring"><a href="#함수-추출-리팩토링-Extract-function-refactoring" class="headerlink" title="함수 추출 리팩토링(Extract function refactoring)"></a>함수 추출 리팩토링(Extract function refactoring)</h2><p>launch { … } 내부의 코드 블록을 별도의 함수로 추출해보겠습니다. 만약 코드에서 “함수 추출”이라는 리팩토링을 수행한다면 <code>suspend</code> 수정자와 함께 새로운 함수를 만들 수 있습니다. 이건 당신의 첫번째 <em>중단 함수</em> 입니다. 중단 함수는 코루틴 내부에서 일반적인 함수처럼 사용합니다 하지만 일반적인 함수와 다른 점은 코루틴을 일시중지하기 위해 다른 코루틴 함수의 기능들(deplay 함수 같은) 추가 기능들이 존재한다는 것입니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123; <span class="comment">// this: CoroutineScope</span></span><br><span class="line">    launch &#123; doWorld() &#125;</span><br><span class="line">    println(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this is your first suspending function</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWorld</span><span class="params">()</span></span> &#123;</span><br><span class="line">    delay(<span class="number">1000L</span>)</span><br><span class="line">    println(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// result</span></span><br><span class="line">Hello</span><br><span class="line">World!</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="스코프-빌더-Scope-builder"><a href="#스코프-빌더-Scope-builder" class="headerlink" title="스코프 빌더(Scope builder)"></a>스코프 빌더(Scope builder)</h2><p>코루틴스코프 빌더를 사용하여 다른 빌더에서 제공되는 코루틴 스코프외에도 자신만의 스코프를 선언할 수 있습니다. 그리고 코루틴 스코프를 생성한 후 해당 스코프내의 생성된 자식 작업들이 완료되기 전까지는 스코프가 완료되지 않습니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    doWorld()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWorld</span><span class="params">()</span></span> = coroutineScope &#123;  <span class="comment">// this: CoroutineScope</span></span><br><span class="line">    launch &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// result</span></span><br><span class="line">Hello</span><br><span class="line">World!</span><br></pre></td></tr></table></figure>

<p><code>runBlocking</code> 그리고 <code>coroutineScope</code> 빌더들은 둘다 바디와 모든 자식들이 작업이 완료되기까지 기다리는 것으로 유사하게 보이지만 가장 큰 차이점은 <code>runBlocking</code> 함수가 대기를 위해 현재 스레드를 _차단_한다면 <code>coroutineScope</code>는 단순히 일시중단하고 다른 용도를 위해 기본 스레드를 해제합니다. 그 차이 때문에 <code>runBlocking</code>은 일반 함수이고 <code>coroutineScope</code>는 정지함수 입니다.</p>
<p><code>coroutineScope</code>를 어떠한 중단함수로서 사용할 수 있습니다. 예를 들어 Hello와 World의 동시적인 로그 출력을 <code>suspend fun doWorld()</code> 로 옮길 수 있습니다.</p>
<hr>
<h2 id="스코프-빌더-그리고-동시성-Scope-builder-and-concurrency"><a href="#스코프-빌더-그리고-동시성-Scope-builder-and-concurrency" class="headerlink" title="스코프 빌더 그리고 동시성(Scope builder and concurrency﻿)"></a>스코프 빌더 그리고 동시성(Scope builder and concurrency﻿)</h2><p><code>coroutineScope</code> 빌더는 여러 동시 작업을 수행하기 위해 정지 함수 내에서 사용할 수 있습니다</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sequentially executes doWorld followed by &quot;Done&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    doWorld()</span><br><span class="line">    println(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concurrently executes both sections</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWorld</span><span class="params">()</span></span> = coroutineScope &#123; <span class="comment">// this: CoroutineScope</span></span><br><span class="line">    launch &#123;</span><br><span class="line">        delay(<span class="number">2000L</span>)</span><br><span class="line">        println(<span class="string">&quot;World 2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    launch &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;World 1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// result</span></span><br><span class="line">Hello</span><br><span class="line">World <span class="number">1</span></span><br><span class="line">World <span class="number">2</span></span><br><span class="line">Done</span><br></pre></td></tr></table></figure>

<p><code>launch &#123; ... &#125;</code> 블록 내부에 두 개의 코드들은 동시적으로 실행되며 <code>World 1</code>이 먼저 프린트 된 후 1초 후에 <code>World  2</code>의 프린트가 시작되고 2초 뒤에 프린트합니다. <code>coroutineScope</code> <code>doWorld</code> </p>
<p>코루틴 스코프에 있는 <code>doWorld</code>의 함수는 두 개의 작업이 모두 완료된 후에만 완료됩니다. 그래서 <code>doWorld</code>는 모든 작업이 완료된 후 Done 문자열이 인쇄되도록 허용합니다</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Hello</span><br><span class="line">World 1</span><br><span class="line">World 2</span><br><span class="line">Done</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="명시적-작업-An-explicit-job"><a href="#명시적-작업-An-explicit-job" class="headerlink" title="명시적 작업(An explicit job)"></a>명시적 작업(An explicit job)</h2><p><code>launch</code> 코루틴 빌더는 <code>Job</code> 객체를 리턴합니다. <code>Job</code>은 실행된 코루틴을 핸들링하고 작업이 완전히 끝날때까지 명시적으로 기다리는 용도로 사용할 수 있습니다. 예를들어 자식 코루틴들이 완료되기전까지 기다린 후에 “Done” 문자열을 출력할 수 있습니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> job = launch &#123; <span class="comment">// launch a new coroutine and keep a reference to its Job</span></span><br><span class="line">    delay(<span class="number">1000L</span>)</span><br><span class="line">    println(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">job.join() <span class="comment">// wait until child coroutine completes</span></span><br><span class="line">println(<span class="string">&quot;Done&quot;</span>) </span><br><span class="line"><span class="comment">// result</span></span><br><span class="line">Hello</span><br><span class="line">World!</span><br><span class="line">Done</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="코루틴은-가볍습니다-Coroutines-are-light-weight"><a href="#코루틴은-가볍습니다-Coroutines-are-light-weight" class="headerlink" title="코루틴은 가볍습니다(Coroutines are light-weight)"></a>코루틴은 가볍습니다(Coroutines are light-weight)</h2><p>코루틴은 JVM 스레드에서 리소스 집약이 더 적습니다. 스레드를 사용할 때 JVM의 가용 메모리를 소진하는 코드는 리소 제한에 도달하지 않고 콜튄을 사용하여 표현할 수 있습니다.</p>
<p>스레드에서 JVM의 가용 메모리를 소진하는 코드는 코루틴을 사용하는것으로 리소스 제한에 도달하지 않을 수 있습니다. 예를들어 다음 코드는 100000개의 서로 다른 코루틴을 시작하여 각각 5초를 기다린 다음 마침표(‘.’)를 프린트하는 코드가 있습니다. 이 코드는 매우 적은 메모리를 사용합니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    repeat(<span class="number">100_000</span>) &#123; <span class="comment">// launch a lot of coroutines</span></span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(<span class="number">5000L</span>)</span><br><span class="line">            print(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>해당 코드를 스레드에서 비교하고 싶으신 경우 <code>runBlocking</code>과 <code>launch</code>를 <code>thread</code>로 교체하고 <code>delay</code> 함수도 <code>Thread.sleep</code>으로 교체해줍니다. 만약 해당 코드를 실행한다면 많은 메모리를 소비하여 OOM(out-of-memoery)에러가 발생할 수 있습니다.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-12-26T17:16:28.000Z" title="2022. 12. 27. 오전 2:16:28">2022-12-27</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-12-26T17:16:47.921Z" title="2022. 12. 27. 오전 2:16:47">2022-12-27</time></span><span class="level-item">4 minutes read (About 628 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/12/27/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-Collection/">자료구조 - Collection</a></h1><div class="content"><h3 id="Java-Collection-Framework"><a href="#Java-Collection-Framework" class="headerlink" title="Java Collection Framework"></a>Java Collection Framework</h3><p>Java Collection Framework란 일반적으로 재사용 가능한 컬렉션 데이터 구조를 구현하는 인터페이스 집합입니다.</p>
<h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><p>Collection은 여러 원소(Element)를 담을 수 있는 자료구조를 뜻합니다.</p>
<p>아래는 Collection.java 인터페이스를 정의한 모습입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Collection</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">java</span>.lang.Iterable&lt;E&gt;</span><br></pre></td></tr></table></figure>

<p>아래는 Collection의 다이어그램 구조입니다.<br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/ab/Java.util.Collection_hierarchy.svg/1920px-Java.util.Collection_hierarchy.svg.png" alt="Collection"></p>
<h3 id="Collection-Methods"><a href="#Collection-Methods" class="headerlink" title="Collection Methods"></a>Collection Methods</h3><p>대표적인 Collection의 메서드들입니다.</p>
<ul>
<li>int size() : 컬렉션의 총 개수를 반환</li>
<li>boolean add(E e) : 컬렉션에 요소 추가</li>
<li>boolean addAll(Collection&lt;? extends E&gt;) : 컬렉션의 모든 요소를 해당 컬렉션에 추가</li>
<li>boolean remove(Object o) : 컬렉션에 요소 삭제</li>
<li>boolean removeAll(Collection&lt;? extends E&gt;) : 컬렉션의 모든 요소를 해당 컬렉션에 추가</li>
<li>void clear() : 컬렉션의 모든 요소 삭제</li>
<li>boolean contains(Object o) : 컬렉션이 전달받은 객체를 포함하는지</li>
<li>boolean equals(Object o) : 컬렉션과 전달된 오브젝트가 같은지</li>
<li>boolean isEmpty() : 컬렉션이 비어 있는지</li>
<li>Object [] toArray() : 해컬렉션의 모든 요소를 Object 타입의 배열로 반환</li>
</ul>
<h3 id="Collection-의-3가지-유형"><a href="#Collection-의-3가지-유형" class="headerlink" title="Collection 의 3가지 유형"></a>Collection 의 3가지 유형</h3><p><code>Collection</code>을 상속받는 인터페이스 크게 3가지 입니다.</p>
<ul>
<li>Set</li>
<li>List</li>
<li>Queue</li>
</ul>
<h3 id="List-Interface"><a href="#List-Interface" class="headerlink" title="List (Interface)"></a>List (Interface)</h3><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/9/docs/api/java/util/List.html">List</a> 인터페이스는 순서대로 엘리먼트들을 나열한 컬렉션이며 중복 요소를 포함 가능하고 인덱스로 모든 엘리먼트에 접근 가능한게 특징이입니다. List 인터페이스를 상속받아 구현된 대표적인 클래스는 <strong>ArrayList, LinkedList, Vector, Stack</strong> 이 있습니다.</p>
<h3 id="Set-Interface"><a href="#Set-Interface" class="headerlink" title="Set (Interface)"></a>Set (Interface)</h3><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/9/docs/api/java/util/Set.html">Set</a> 인터페이스는 엘리먼트의 집합을 표현한 컬렉션이며 중복 요소를 포함할 수 없고 iterator 또는 foreach를 이용하여 탐색합니다.<br>Set 인터페이스로 구현된 클래스는 **HashSet, LinkedHashSet, TreeSet ** 이 있습니다.</p>
<h3 id="Queue-Interface"><a href="#Queue-Interface" class="headerlink" title="Queue (Interface)"></a>Queue (Interface)</h3><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/9/docs/api/java/util/Queue.html">Queue</a>는 먼저 집어 넣은 <a target="_blank" rel="noopener" href="https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0">데이터</a>가 먼저 나오는 <a target="_blank" rel="noopener" href="https://ko.wikipedia.org/wiki/FIFO">FIFO</a> (First In First Out)구조로 저장하는 형식을 말합니다. 기본 컬렉션 작업 외에도 Queue는 삽입, 추출 및 검사 작업을 제공한다. Quque 인터페이스로 구현된 클래스는 <strong>PriorityQueue</strong> 가 있습니다.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-12-18T03:35:22.115Z" title="2022. 12. 18. 오후 12:35:22">2022-12-18</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-12-18T03:35:22.115Z" title="2022. 12. 18. 오후 12:35:22">2022-12-18</time></span><span class="level-item">a minute read (About 123 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/12/18/hello-world/">Hello World</a></h1><div class="content"><p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-12-15T05:19:19.000Z" title="2022. 12. 15. 오후 2:19:19">2022-12-15</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-12-19T12:29:09.694Z" title="2022. 12. 19. 오후 9:29:09">2022-12-19</time></span><span class="level-item">a few seconds read (About 7 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/12/15/Github-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0-with-Hexo-1/">Github 블로그 만들기 with Hexo - 1</a></h1><div class="content">
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-12-15T05:18:40.000Z" title="2022. 12. 15. 오후 2:18:40">2022-12-15</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-01-08T03:11:35.824Z" title="2023. 1. 8. 오후 12:11:35">2023-01-08</time></span><span class="level-item"><a class="link-muted" href="/categories/Kotlin/">Kotlin</a></span><span class="level-item">3 minutes read (About 423 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/12/15/Ktoin%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9-%E1%84%85%E1%85%A1%E1%86%B7%E1%84%83%E1%85%A1-%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%E1%84%8B%E1%85%AA-%E1%84%80%E1%85%A9%E1%84%8E%E1%85%A1%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%E1%84%85%E1%85%A1%E1%86%AB/">Kotlin으로 람다 함수와 고차함수란</a></h1><div class="content"><h2 id="Kotlin으로-람다-함수-Lambda-Function-와-고차-함수-High-Order-Function-에-대해서-알아보자"><a href="#Kotlin으로-람다-함수-Lambda-Function-와-고차-함수-High-Order-Function-에-대해서-알아보자" class="headerlink" title="Kotlin으로 람다 함수(Lambda Function)와  고차 함수(High Order Function)에 대해서 알아보자"></a>Kotlin으로 람다 함수(Lambda Function)와  고차 함수(High Order Function)에 대해서 알아보자</h2><h3 id="Lambda-Function-람다-함수-이란"><a href="#Lambda-Function-람다-함수-이란" class="headerlink" title="Lambda Function(람다 함수) 이란?"></a>Lambda Function(람다 함수) 이란?</h3><p>람다 함수는 함수형 프로그래밍 언어에서 사용되는 개념으로 <strong>익명 함수</strong>라고도 불린다<br>Java8 부터 사용이 가능하며, 가독성을 향상시키고 보일러 플레이트 코드를 줄일 수 있다</p>
<h3 id="Lambda-Function-람다-함수-의-사용-방법"><a href="#Lambda-Function-람다-함수-의-사용-방법" class="headerlink" title="Lambda Function(람다 함수) 의 사용 방법"></a>Lambda Function(람다 함수) 의 사용 방법</h3><p><strong>기본 사용 방법</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> lambdaName : Type = &#123; argumentList -&gt; codeBody &#125;</span><br></pre></td></tr></table></figure>

<p><strong>Type Interface를 활용하는 방법</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> square = &#123; number: <span class="built_in">Int</span> -&gt; number * number &#125;</span><br><span class="line"><span class="keyword">val</span> nine = square(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>





<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> lambdaName = &#123; a: <span class="built_in">Int</span>, b: String -&gt; </span><br><span class="line">	<span class="string">&quot;<span class="variable">$a</span> <span class="variable">$b</span>&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1개 이상의 타입을 파라미터로 전달 가능하고 리턴 타입을 생략 할 수 있습니다</p>
<hr>
<h3 id="High-Order-Function-고차-함수-란"><a href="#High-Order-Function-고차-함수-란" class="headerlink" title="High Order Function(고차 함수) 란?"></a>High Order Function(고차 함수) 란?</h3><p>함수를 인수로 취하거나 함수를 결과로 반환할 수 있는 함수를 말합니다</p>
<p>아래 사용되고 있는 예시를 보겠습니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">square</span><span class="params">(x: <span class="type">Int</span>, y: <span class="type">Int</span>, block: (<span class="type">result</span>: <span class="type">Int</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">        block(x * y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">square(<span class="number">4</span>, <span class="number">4</span>) &#123; result -&gt;</span><br><span class="line">	<span class="comment">// result 16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>x, y를 인자를 받고 해당 block이라는 람다식을 invoke 합니다.</li>
<li>선언된 square 함수에서 block 파라미터의 블록에서 결과값을 받을 수 있습니다</li>
</ul>
<p>고차 함수로 람다함수를 파라미터로 넘겨줄 때 과도하게 사용하면 런타임 오버헤드가 발생합니다.<br>그럴때는 inline 키워드를 사용하여 오버헤드를 방지해야 합니다.</p>
<p><a target="_blank" rel="noopener" href="https://kennethss.medium.com/kotlin-%EA%B3%A0%EC%B0%A8%ED%95%A8%EC%88%98%EC%99%80-inline-noinline-crossinline-reified-960f1f1511c2">Medium 글</a></p>
<p>Medium 설명글에 inline에 대해서 작성한 글이 있습니다. 참고해 보시길 바랍니다.</p>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Your name"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Your name</p><p class="is-size-6 is-block">Your title</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Your location</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">10</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">5</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">3</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/KennethSS" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/KennethSS"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Coroutine/"><span class="level-start"><span class="level-item">Coroutine</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Design-Pattern/"><span class="level-start"><span class="level-item">Design Pattern</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Kotlin/"><span class="level-start"><span class="level-item">Kotlin</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/RxJava/"><span class="level-start"><span class="level-item">RxJava</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/RxJava/Transforming/"><span class="level-start"><span class="level-item">Transforming</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-01-17T05:07:10.000Z">2023-01-17</time></p><p class="title"><a href="/2023/01/17/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4-Singleton-Pattern/">싱글톤 패턴 - Singleton Pattern</a></p><p class="categories"><a href="/categories/Design-Pattern/">Design Pattern</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-01-14T14:18:27.000Z">2023-01-14</time></p><p class="title"><a href="/2023/01/14/%EB%A9%94%EC%84%9C%EB%93%9C-%EC%8B%9C%EA%B7%B8%EB%8B%88%EC%B2%98-Method-signature-%EB%9E%80/">메서드 시그니처(Method signature)란</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-01-13T18:35:38.000Z">2023-01-14</time></p><p class="title"><a href="/2023/01/14/kotlin-sequence/">kotlin-sequence</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-01-12T01:24:26.000Z">2023-01-12</time></p><p class="title"><a href="/2023/01/12/RxJava-Scan/">RxJava - Scan</a></p><p class="categories"><a href="/categories/RxJava/">RxJava</a> / <a href="/categories/RxJava/Transforming/">Transforming</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-01-08T14:00:56.000Z">2023-01-08</time></p><p class="title"><a href="/2023/01/08/ViewModel%EC%9D%B4-%ED%99%94%EB%A9%B4%ED%9A%8C%EC%A0%84%EC%97%90%EB%8F%84-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EC%9C%A0%EC%A7%80%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94-%EC%9D%B4%EC%9C%A0/">ViewModel이 화면회전에도 데이터를 유지할 수 있는 이유</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/01/"><span class="level-start"><span class="level-item">January 2023</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/12/"><span class="level-start"><span class="level-item">December 2022</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/RxJava/"><span class="tag">RxJava</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/categories/"><span class="tag">categories</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/java/"><span class="tag">java</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe for updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="케니스의 개발 블로그" height="28"></a><p class="is-size-7"><span>&copy; 2023 John Doe</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/KennethSS"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>