<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>케니스의 개발 블로그</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="케니스의 개발 블로그"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="케니스의 개발 블로그"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="케니스의 개발 블로그"><meta property="og:url" content="http://example.com/"><meta property="og:site_name" content="케니스의 개발 블로그"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:author" content="John Doe"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"케니스의 개발 블로그","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"John Doe"},"publisher":{"@type":"Organization","name":"케니스의 개발 블로그","logo":{"@type":"ImageObject","url":"http://example.com/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="케니스의 개발 블로그" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item is-active" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/KennethSS"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-9-tablet is-9-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-02-09T15:15:04.000Z" title="2023. 2. 10. 오전 12:15:04">2023-02-10</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-02-09T15:15:24.978Z" title="2023. 2. 10. 오전 12:15:24">2023-02-10</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">7 minutes read (About 1048 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/02/10/Android-TextView-%EC%9E%90%EB%8F%99-%ED%81%AC%EA%B8%B0-%EC%A1%B0%EC%A0%88/">Android - TextView 자동 크기 조절</a></h1><div class="content"><p><img src="https://cdn-images-1.medium.com/max/1600/0*5xsLyS4PZCrnJIVK"><br>Photo by Mel Poole on Unsplash</p>
<h2 id="요구사항"><a href="#요구사항" class="headerlink" title="요구사항"></a>요구사항</h2><p>안드로이드 개발을 하다가보면 하나의 다음과같은 요구사항이 생기는 상황이 생깁니다. </p>
<blockquote>
<p> <code>TextView</code> 안에 2줄일 때는 <code>14sp</code>, 텍스트가 만약에 길어질 때는 3줄로 제한하면서 <code>12sp</code>로 변경</p>
</blockquote>
<p>이런 요구사항을 어떻게 해결할 수 있을까요? 글자 수 초과 시 텍스트 사이즈를 변경하는 코드를 만들거나 Canvas를 이용해 글자의 범위가 넘어가면 측정하는 로직을 따로 작성할 수 있지만 단순한 동작을 위해 너무 많은 작업이나 코드를 생산하게 되는 일이 발생합니다. </p>
<p>다행히 안드로이드에서는 Android 8.0(API 26)이상을 사용한다면 <code>TextView</code>에 해당 기능을 지원하고 있습니다. 그 이전 버전은 <code>AppCompat</code>을 사용하여 다루어야하고 최소 버전은 4.0(API 14) 이상입니다.</p>
<p>그럼 실제로 어떠한 상황에서 쓰여야하는지 살펴보겠습니다.</p>
<img src="https://velog.velcdn.com/images/wlsrhkd4023/post/0935f427-a858-41b4-b22d-e83701042bb9/image.png" width="60%" height="30%">

<p>위 사진은 <strong>29cm</strong>의 상품리스트 화면입니다. 상품의 설명으로 커피잔 세트… 으로 간단하게 설명이 되어 있지만 이 <code>TextView</code>에 더 많은 텍스트를 넣기위해 3줄을 허용하게 변경하는 요구사항이 발생할 수 있습니다.</p>
<p>이 경우에 기존 2줄의 높이는 유지하면서 3줄의 조금 더 작은 텍스트사이즈의 설명이 들어가게 하려면 안드로이드에서 제공하는 자동 크기 조절기능을 이용해 해결할 수 있습니다.</p>
</br>

<p>TextView 자동 크기 조절은 크게 3가지로 나누어 작업할 수 있습니다.</p>
<ul>
<li>기본 : autoSizeTextType만 지정한 방법</li>
<li>세부사항 : 텍스트의 최소, 최대, 단위를 구성한 방법</li>
<li>미리 정의한 크기 : 텍스트 크기의 배열을 이용한 방법</li>
</ul>
</br>

<p> ⚠️ 텍스트 크기 조절 기능을 이용한다면 TextView의 width, height 속성을 <code>wrap_content</code> 로 지정해서는 안됩니다. </p>
</br>

<h2 id="기본"><a href="#기본" class="headerlink" title="기본"></a>기본</h2><p>기본을 정의하는 방법은 간단합니다. xml에서 autoSizeTextType을 uniform으로 지정하거나 프로그래매틱 방법으로는 <code>TextView</code>의 setAutoSizeTextTypeWithDefaults(int autoSizeTextType) 함수를 호출해서 적용할 수 있습니다.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;200dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:autoSizeTextType</span>=<span class="string">&quot;uniform&quot;</span> /&gt;</span> </span><br></pre></td></tr></table></figure>

<blockquote>
<p>📘 기본값으로 적용되는 텍스트 사이즈는 최소(12sp), 최대(112sp), 단위(1px)로 지정됩니다.</p>
</blockquote>
</br>

<h2 id="세부사항"><a href="#세부사항" class="headerlink" title="세부사항"></a>세부사항</h2><p>세부사항을 정의하는 방법은 기본값을 지정하는 방법에 더해서 최소, 최대, 단위를 추가해 구성하는 방법입니다.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;200dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:autoSizeTextType</span>=<span class="string">&quot;uniform&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:autoSizeMinTextSize</span>=<span class="string">&quot;12sp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:autoSizeMaxTextSize</span>=<span class="string">&quot;100sp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:autoSizeStepGranularity</span>=<span class="string">&quot;2sp&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>각 옵션들에 대한 설명</strong></p>
<ul>
<li>autoSizeMinTextSize : 텍스트 사이즈가 조절될 때 최소 사이즈</li>
<li>autoSizeMaxTextSize : 텍스트 사이즈가 조절될 때 최대 사이즈</li>
<li>autoSizeStepGranularity : 텍스트 사이즈 조절 시 사이 단계의 크기</li>
</ul>
</br>

<h2 id="미리-정의한-크기"><a href="#미리-정의한-크기" class="headerlink" title="미리 정의한 크기"></a>미리 정의한 크기</h2><p>최소, 최대값등을 정의하지 않고도 텍스트 크기 조절을 지정한 사이즈 리스트에만 한정하는 방법이 있습니다.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">array</span> <span class="attr">name</span>=<span class="string">&quot;autosize_text_sizes&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span>&gt;</span>10sp<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span>&gt;</span>12sp<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span>&gt;</span>20sp<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span>&gt;</span>40sp<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span>&gt;</span>100sp<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>텍스트 크기 변경의 범위를 배열의 형태로 지정합니다.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;200dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:autoSizeTextType</span>=<span class="string">&quot;uniform&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:autoSizePresetSizes</span>=<span class="string">&quot;@array/autosize_text_sizes&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>autoSizePresetSizes에 배열을 지정합니다. </p>
</br>

<h2 id="적용해보기"><a href="#적용해보기" class="headerlink" title="적용해보기"></a>적용해보기</h2><p>아까의 요구사항을 위의 내용들을 이용해 적용해보겠습니다.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:id</span>=<span class="string">&quot;@+id/content&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:layout_height</span>=<span class="string">&quot;64dp&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:autoSizeTextType</span>=<span class="string">&quot;uniform&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:autoSizeMaxTextSize</span>=<span class="string">&quot;16sp&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:autoSizeMinTextSize</span>=<span class="string">&quot;8sp&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:autoSizeStepGranularity</span>=<span class="string">&quot;1sp&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">...</span></span></span><br><span class="line"><span class="tag">  /&gt;</span></span><br></pre></td></tr></table></figure>

<p>UI에서 어색하지 않을 정도의 범주로 최대를 16sp, 최소를 8sp로 지정하고 최대한 영역을 활용할 수 있게 단계를 1sp로 지정했습니다.</p>
</br>

<table>
<thead>
<tr>
<th><img src="https://velog.velcdn.com/images/wlsrhkd4023/post/fccceb9b-76a2-4f58-bbbe-1dc09d478505/image.png"></th>
<th><img src="https://velog.velcdn.com/images/wlsrhkd4023/post/e70c8cdc-66b1-4724-a497-aecefeea2c3b/image.png"></th>
<th><img src="https://velog.velcdn.com/images/wlsrhkd4023/post/9ff67eca-4101-4e11-bb03-722b797d7a65/image.png"></th>
</tr>
</thead>
<tbody><tr>
<td>적용전</td>
<td>적용후(최소)</td>
<td>적용후(최대)</td>
</tr>
</tbody></table>
<p>이제 기존 높이에 변화없이 최소, 최대 값을 유지하면서 유연하게 텍스트를 표현할 수 있습니다.</p>
<p>긴 글 읽어주셔서 감사합니다. 🙇‍♂️</p>
<h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul>
<li><a target="_blank" rel="noopener" href="https://developer.android.com/develop/ui/views/text-and-emoji/autosizing-textview">https://developer.android.com/develop/ui/views/text-and-emoji/autosizing-textview</a></li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-02-09T11:37:50.000Z" title="2023. 2. 9. 오후 8:37:50">2023-02-09</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-02-09T11:38:38.164Z" title="2023. 2. 9. 오후 8:38:38">2023-02-09</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">2 minutes read (About 316 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/02/09/Android-is-translated-here-but-not-found-in-default-locale-%EC%9D%B4%EC%8A%88/">Android - is translated here but not found in default locale 이슈</a></h1><div class="content"><p><img src="https://cdn-images-1.medium.com/max/1600/0*untxKXSKCdW04L9I" alt="img">Photo by <a target="_blank" rel="noopener" href="https://unsplash.com/@davidmarcu?utm_source=medium&utm_medium=referral">David Marcu</a> on <a target="_blank" rel="noopener" href="https://unsplash.com/?utm_source=medium&utm_medium=referral">Unsplash</a></p>
<h2 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h2><p>안드로이드에서 string 리소스에 텍스트를 추가하는데 다음과 같은 에러를 발생시킬 때가 있습니다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;sample_text&quot; is translated here but not found in default locale</span><br></pre></td></tr></table></figure>



<h2 id="원인"><a href="#원인" class="headerlink" title="원인"></a>원인</h2><p>해당 린트에러는 번역을 제공하지 않는 Locale에서 문자열을 조회하게 된다면 충돌을 발생할 수 있으니 주의하라는 내용인데요. 어느새 부터 가끔씩 value&#x2F;strings.xml 파일에서 선언하면 발생했습니다. </p>
<p><img src="https://velog.velcdn.com/images/wlsrhkd4023/post/ee4f2fd8-8131-4a07-8149-92f872d575bb/image.png"></p>
<p>현지화 작업을 하지 않는다면 보통은 이 문구를 신경쓰지 않아도 되지만 에러가 신경쓰여서 해결해보려고합니다.</p>
<h2 id="해결-방법들"><a href="#해결-방법들" class="headerlink" title="해결 방법들"></a>해결 방법들</h2><ol>
<li>Android Studio - Preferences - Inspections - Extra translation에서 Severity를 Error가 아닌 다른 형태로 바꾸어 린트 경고를 변경합니다.</li>
</ol>
<p><img src="https://velog.velcdn.com/images/wlsrhkd4023/post/bce94487-16c4-4d09-a8c1-5325fe7f6d5b/image.png"><br><img src="https://velog.velcdn.com/images/wlsrhkd4023/post/743b9648-00ab-45ed-90d8-aef1391a13ad/image.png"></p>
<ol start="2">
<li>간혹 Clean Project 후 에러가 사라지는 경우도 있습니다.</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-02-08T17:31:51.000Z" title="2023. 2. 9. 오전 2:31:51">2023-02-09</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-02-08T17:32:16.392Z" title="2023. 2. 9. 오전 2:32:16">2023-02-09</time></span><span class="level-item"><a class="link-muted" href="/categories/Kotlin/">Kotlin</a></span><span class="level-item">7 minutes read (About 1118 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/02/09/Kotlin-%EC%96%95%EC%9D%80-%EB%B3%B5%EC%82%AC-Shallow-Copy-%EC%99%80-%EA%B9%8A%EC%9D%80-%EB%B3%B5%EC%82%AC-Depp-Copy/">Kotlin 얕은 복사(Shallow Copy)와 깊은 복사(Depp Copy)</a></h1><div class="content"><p>안녕하세요. 이번 글에서는 얕은복사(Shallow Copy)와 깊은복사(Deep Copy)에 대해서 알아보려고합니다.</p>
</br>

<p>자바나 코틀린으로 개발을 하다보면 객체를 복사할 일이 생기는데 이 때 주의해서 복사하지 않으면 의도치 않은 결과를 마주할 수 있습니다. 객체를 복사하는 방법은 크게 얕은복사(Shallow Copy)와 깊은복사(Deep Copy) 두 가지 방식이 있습니다.</p>
</br>

<h3 id="얕은-복사-Shallow-Copy"><a href="#얕은-복사-Shallow-Copy" class="headerlink" title="얕은 복사(Shallow Copy)"></a>얕은 복사(Shallow Copy)</h3><p>얇은 복사는 원본 객체에 대한 객체를 만들고 원본 객체의 주소값을 참조하는것을 의미합니다. 객체는 인스턴스화 되면서 메모리에 주소를 할당하게 되는데요 이 때 할당된 주소의 값을 참조하게 되는 것이 얕은 복사라고 합니다. 코드로 한번 어떤 의미인지 살펴보겠습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="type">int</span> id;</span><br><span class="line">  String name;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.id = id;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.id = id;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">User</span> <span class="variable">kenneth</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;kenneth&quot;</span>);  </span><br><span class="line">  <span class="type">User</span> <span class="variable">daniel</span> <span class="operator">=</span> kenneth;</span><br><span class="line">  kenneth.changeName(<span class="string">&quot;daniel&quot;</span>);</span><br><span class="line">  kenneth.changeId(<span class="number">2</span>);</span><br><span class="line">  </span><br><span class="line">  System.out.println(kenneth); <span class="comment">// User(name=&#x27;daniel&#x27;, id=2)</span></span><br><span class="line">  System.out.println(daniel); <span class="comment">// User(name=&#x27;daniel&#x27;, id=2)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>

<p>위에 코드에서 는 유저 이름이 각  <code>kenneth</code>와 <code>daniel</code> 이 노출되는것을 기대하지만 모두 <code>daniel</code>이라는 값을 가지고 있는 것을 볼 수 있습니다. 이렇게 된 이유는 daniel은 실제 값을 복사한게 아닌 참조값을 복사했습니다.</p>
<p><img src="https://velog.velcdn.com/images/wlsrhkd4023/post/4b59909f-135f-44ef-ba65-a90db66b29f9/image.jpg"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">kenneth</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;kenneth&quot;</span>);  </span><br><span class="line"><span class="type">User</span> <span class="variable">daniel</span> <span class="operator">=</span> kenneth;</span><br></pre></td></tr></table></figure>

<p>User인스턴스를 생서하고 daniel 인스턴스는 kenneth의 참조값을 저장합니다. kenneth와 daniel의 주소값이 동일하므로 <code>49cfaae</code>주소값을 동일하게 바라보고있습니다.</p>
</br>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kenneth.changeName(<span class="string">&quot;daniel&quot;</span>);</span><br><span class="line">kenneth.changeId(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>이제 kenneth에 접근하여 이름을 daniel로 변경해보겠습니다. </p>
<p><img src="https://velog.velcdn.com/images/wlsrhkd4023/post/2af0986a-051d-4277-a514-8a755ba1b9a3/image.jpg"></p>
<p>kenneth와 daniel 인스턴스가 참조하는 힙 데이터 내의 실제값이 수정되었습니다 결국 kenneth와 daniel 모두 변경된 값을 동일하게 참조합니다. 하지만 우리는 실제 객체의 값이 복사되는 것을 원합니다. 이런 경우에는 깊은 복사(Deep Copy)를 해야합니다.</p>
</br>

<h3 id="깊은복사-Deep-Copy"><a href="#깊은복사-Deep-Copy" class="headerlink" title="깊은복사(Deep Copy)"></a>깊은복사(Deep Copy)</h3><p>깊은 복사(Deep Copy)는 실제 값을 새로운 메모리 공간에 복사하는 것입니다. </p>
<p>깊은 복사를 하는 방법은 크게 3가지가 있습니다.</p>
<ul>
<li>복사 생성자 또는 복사 팩터리를 이용</li>
<li>직접 객체를 생성하여 복사</li>
<li>Cloneable을 이용한 clone() 재정의</li>
</ul>
<p><img src="https://velog.velcdn.com/images/wlsrhkd4023/post/0dc0fec8-7cd3-4799-9365-b403b188d916/image.jpg"></p>
</br>

<p><strong>복사 생성자, 복사 팩터리를 이용</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="type">int</span> id;</span><br><span class="line">  String name;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 복사 생성자</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.id = user.id;</span><br><span class="line">    <span class="built_in">this</span>.name = user.name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 복사 팩터리</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> User <span class="title function_">newInstance</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">copy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    copy.name = user.name;</span><br><span class="line">    copy.id = user.id;</span><br><span class="line">    <span class="keyword">return</span> copy</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>

<p><strong>직접 객체를 생성</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">kenneth</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;kenneth&quot;</span>);  </span><br><span class="line"><span class="type">User</span> <span class="variable">daniel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"></span><br><span class="line">daniel.setName(kenneth.name);</span><br><span class="line">daniel.setId(kenneth.Id);</span><br><span class="line"></span><br><span class="line">kenneth.changeName(<span class="string">&quot;kenneth 2&quot;</span>)</span><br><span class="line">kenneth.changeId(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

</br>

<p><strong>Cloneable을 이용한 clone() 재정의</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> it;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> User <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> (User) <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Cloneable을 이용한 복사는 이펙티브 자바에서 권장하지 않는데 그 이유는 final 클래스는 위험이 크지 않지만 그 외에는 성능 최적화 관점에서 문제가 없을 때만 허용해야 하기 때문에 복제는 생성자와 팩터리를 이용하는게 베스트라고 한다.</p>
</br>

<h2 id="코틀린에서-data-class의-copy-는-깊은-복사일까"><a href="#코틀린에서-data-class의-copy-는-깊은-복사일까" class="headerlink" title="코틀린에서 data class의 copy()는 깊은 복사일까?"></a>코틀린에서 data class의 copy()는 깊은 복사일까?</h2><p>코틀린 data class의 <code>copy()</code> 함수는 마치 깊은 복사를 해주는 것처럼 헷갈릴 수 있지만 <code>copy()</code>는 얇은 복사입니다. 이유는 깊은 복사는 객체의 변수들을 전부 깊은 복사를 해주지만 <code>copy()</code> 함수는 data class내의 Primitive 타입을 제외한 커스텀 객체는 깊은 복사를 지원하지 않습니다.</p>
</br>

<p>또한 코틀린에서 Immutable한 객체는 처음 할당되고 프로그램이 종료될 때 까지 값이 변경되지 않으므로 깊은 복사와 얇은 복사의 선택권이 없고 경계하지 않아도됩니다.</p>
<h3 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h3><ul>
<li><a target="_blank" rel="noopener" href="https://jackjeong.tistory.com/100">https://jackjeong.tistory.com/100</a></li>
<li><a target="_blank" rel="noopener" href="https://kotlinlang.org/docs/data-classes.html">https://kotlinlang.org/docs/data-classes.html</a></li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-02-04T16:46:13.000Z" title="2023. 2. 5. 오전 1:46:13">2023-02-05</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-02-04T17:50:36.219Z" title="2023. 2. 5. 오전 2:50:36">2023-02-05</time></span><span class="level-item"><a class="link-muted" href="/categories/CS/">CS</a></span><span class="level-item">5 minutes read (About 810 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/02/05/%EB%8F%99%EC%8B%9C%EC%84%B1-Concurrency-%EA%B3%BC-%EB%B3%91%EB%A0%AC%EC%84%B1-Parallelism/">동시성(Concurrency)과 병렬성(Parallelism)</a></h1><div class="content"><h3 id="동시성-Concurrency"><a href="#동시성-Concurrency" class="headerlink" title="동시성(Concurrency)"></a>동시성(Concurrency)</h3><p>동시성(Concurrency)은 Task들이 빠르게 전환하면서 실행되어 동시에 실행되는 것처럼 보이는 것입니다. 싱글 코어에서도 여러 작업은 동시적(Concurrent)으로 실행되며 Task간의 Context Switch가 발생하면서 여러 작업들을 동시에 실행하는 것처럼 보이게합니다. 하지만 동시성은 싱글 코어에서만 실행되는 것을 의미하지 않고 실제로는 멀티 코어에서 실행되는 상황이 더 많습니다. </p>
<p>즉, 동시성은 독립적인 작업을 작은 단위의 연산으로 나누어 시간 분할 형태로 연산하고 논리적으로 동시에 실행하는 것처럼 보이게하여 유휴 시간(Idle Time)을 최소화 하는 구조나 개념을 의미합니다.</p>
<blockquote>
<p>📘 유휴시간이란? 컴퓨터가 작동 가능한데도 작업을 하지 않는 시간을 의미합니다.</p>
</blockquote>
<p>동시성은 싱글 코어에서도 Concurrent하게 동작하는 Task에서 동기화 문제가 발생합니다. 공유된 자원을 서로 접근하려고 할 때 예상되지 않은 결과가 생길 수 있으므로 이때는 동기화 기법을 사용해주어야합니다.</p>
<p><img src="https://www.baeldung.com/wp-content/uploads/sites/4/2022/01/concurrency_-1024x593-1.png"></p>
</br>

<h3 id="병렬성-Parallelism"><a href="#병렬성-Parallelism" class="headerlink" title="병렬성(Parallelism)"></a>병렬성(Parallelism)</h3><p>병렬성(Parallelism)은 물리적인 시간에 작업을 동시에 수행하는 것 입니다. 동시성과는 다르게 병렬성은 여러 작업들을 코어, 프로세스, 컴퓨터등으로 동시에 수행할 수 있으며 꼭 멀티 코어 한 개 이상의 스레드가 동시에 수행하는 것에만 한정하는 것은 아닙니다. 병렬성은 메모리 손상, 누수가 발생할 수 있습니다. </p>
</br>

<h3 id="동시성-Concurrency-vs-병렬성-Parallelism"><a href="#동시성-Concurrency-vs-병렬성-Parallelism" class="headerlink" title="동시성(Concurrency) vs 병렬성(Parallelism)"></a>동시성(Concurrency) vs 병렬성(Parallelism)</h3><p>동시성과 병렬성을 비교 정리하자면 다음과 같다.</p>
<table>
<thead>
<tr>
<th>동시성</th>
<th>병렬성</th>
</tr>
</thead>
<tbody><tr>
<td>동시에 실행되는 것 같이 보이는 것</td>
<td>실제로 동시에 여러 작업이 처리되는 것</td>
</tr>
<tr>
<td>싱글 코어에서 멀티 쓰레드(Multi thread)를 동작 시키는 방식</td>
<td>멀티 코어에서 멀티 쓰레드(Multi thread)를 동작시키는 방식</td>
</tr>
<tr>
<td>한번에 많은 것을 처리</td>
<td>한번에 많은 일을 처리</td>
</tr>
<tr>
<td>논리적인 개념</td>
<td>물리적인 개념</td>
</tr>
</tbody></table>
<p>병렬성은 동시성에 포함되는 개념입니다. 또한 멀티 코어와 멀티 스레드에서 병렬성으로 작업하는 게 항상 성능상 이점이 있는 것은 아닙니다. I&#x2F;O 요청 후 기다리는 작업이 많은 경우를 처리할 때 때로는 단일코어에서 동시성으로 처리 할 때 효율적일 수 있습니다. 동시성 여러 작업을 동시에 수행하므로 <strong>경합 상태(Race Condition)</strong>, <strong>데드락(Deadlock),</strong> **기아(Starvation)**과 같은 문제가 발생할 수 있으니 주의하여 개발해야한다.</p>
<p><img src="https://t1.daumcdn.net/cfile/tistory/99AD02405FBBB94910"></p>
</br>

<h3 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://yeonyeon.tistory.com/270">https://yeonyeon.tistory.com/270</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://seamless.tistory.com/42">https://seamless.tistory.com/42</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://seohs.tistory.com/461">https://seohs.tistory.com/461</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.baeldung.com/cs/concurrency-vs-parallelism">https://www.baeldung.com/cs/concurrency-vs-parallelism</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://inhyeokyoo.github.io/python/multiprocessing/">https://inhyeokyoo.github.io/python/multiprocessing/</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.baeldung.com/cs/concurrency-vs-parallelism">https://www.baeldung.com/cs/concurrency-vs-parallelism</a></p>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-02-02T13:01:26.000Z" title="2023. 2. 2. 오후 10:01:26">2023-02-02</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-02-02T13:02:06.552Z" title="2023. 2. 2. 오후 10:02:06">2023-02-02</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a><span> / </span><a class="link-muted" href="/categories/Android/Compose/">Compose</a></span><span class="level-item">14 minutes read (About 2078 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/02/02/Compose-hiltViewModel-%EA%B3%BC-viewModel-%EC%B0%A8%EC%9D%B4/">Compose - hiltViewModel()과 viewModel() 차이</a></h1><div class="content"><h2 id="들어가며"><a href="#들어가며" class="headerlink" title="들어가며"></a>들어가며</h2><p>최근 컴포즈 스터디모임에서 논의된 내용으로 컴포즈에서 ViewModel을 생성할 때 <code>viewModel()</code>을 이용한 생성과  <code>hiltViewModel()</code>을 이용한 생성이 구체적으로 어떻게 다른지에 대한 논의가 있었습니다. ViewModel을 생성하는 두개의 방법이 어떤 차이가 있는지 알아보겠습니다.</p>
</br>

<h3 id="설정"><a href="#설정" class="headerlink" title="설정"></a>설정</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  	implementation(<span class="string">&quot;androidx.navigation:navigation-compose:2.5.3&quot;</span>)</span><br><span class="line">    implementation(<span class="string">&quot;androidx.hilt:hilt-navigation-compose:1.0.0&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>

<hr>
</br>

<h2 id="ViewModel-생성"><a href="#ViewModel-생성" class="headerlink" title="ViewModel 생성"></a>ViewModel 생성</h2><p>기존 안드로이드에서 일반적으로 액티비티나 프래그먼트를 이용해 화면 단위를 구성했습니다. 각 컴포넌트에서 ViewModel 생성은 <code>viewModels()</code>와 같은 확장함수를 이용해 간단하게 구현할 수 있습니다. </p>
<p>이렇게 만들어진 ViewModel은 생성된 컴포넌트의 생명주기에 따라 컴포넌트가 완전히 파괴된 이후에 ViewModel도 자연스럽게 소멸됩니다.</p>
</br>

<p>그렇다면 컴포즈에서는 어떻게 생성할 수 있을까요? 컴포즈에서는 ViewModel을 생성하는 함수을 제공합니다. </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line">MainScreen(</span><br><span class="line">	viewModel: MainViewModel = viewModel()</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

</br>

<p>내부적인 코드는 다음과 같습니다. </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> androidx.lifecycle.viewmodel.compose</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> VM : ViewModel&gt;</span> <span class="title">viewModel</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    viewModelStoreOwner: <span class="type">ViewModelStoreOwner</span> = checkNotNull(LocalViewModelStoreOwner.current)</span></span> &#123;</span><br><span class="line">        <span class="string">&quot;No ViewModelStoreOwner was provided via LocalViewModelStoreOwner&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    key: String? = <span class="literal">null</span>,</span><br><span class="line">    factory: ViewModelProvider.Factory? = <span class="literal">null</span>,</span><br><span class="line">    extras: CreationExtras = <span class="keyword">if</span> (viewModelStoreOwner <span class="keyword">is</span> HasDefaultViewModelProviderFactory) &#123;</span><br><span class="line">        viewModelStoreOwner.defaultViewModelCreationExtras</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        CreationExtras.Empty</span><br><span class="line">    &#125;</span><br><span class="line">): VM = viewModel(VM::<span class="keyword">class</span>.java, viewModelStoreOwner, key, factory, extras)</span><br></pre></td></tr></table></figure>

</br>

<p>컴포저블에서 생성한 ViewModel의 <code>ViewModelStoreOwner</code>의 기본값은 <code>LocalViewModelStoreOwner</code>가 제공해주는데 <code>NavHost</code> 컴포저블 범위가 아니라면 <code>ViewTreeViewModelStoreOwner.get()</code> 함수에 View 파라미터를 전달하여 얻은 <code>ViewModelStoreOwner</code>를 리턴합니다. </p>
</br>

<p>이 View는 <code>LocalView.current</code>를 호출해서 가져오는데 코드를 따라가보면 결국 최상위  <code>AndroidComposeView</code>의 View를 얻어옵니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ViewTreeViewModelStoreOwner.<span class="keyword">get</span>(LocalView.current)</span><br></pre></td></tr></table></figure>



<h2 id="화면-단위-ViewModel-구성"><a href="#화면-단위-ViewModel-구성" class="headerlink" title="화면 단위 ViewModel 구성"></a>화면 단위 ViewModel 구성</h2><p>이전 내용에서 컴포즈에서 기본 생성자로 생성한 ViewModel은 최상위 <code>AndroidComposeView</code>의 View를 가져와 <code>ViewModelStoreOwner</code>를 지정한다고 얘기했습니다. </p>
<p>즉, 액티비티나 프래그먼트를 생성 후 화면전체의 요소를 컴포즈로 구현하고 확장함수인 <code>viewModels()</code>를 호출하여 ViewModel을 컴포저블에게 전달하거나 컴포저블 함수에서 직접 <code>viewModel()</code>을 호출해도 컴포넌트가 완전히 파괴되기 전까지 동일한 인스턴스를 호출하기 때문에 기존 방법대로 의도하여 동작하게 할 수 있습니다.</p>
</br>

<p>하지만 하나의 액티비티안에 컴포즈로만 구현할 때는 화면 단위의 ViewModel의 생성과 소멸을 직접 컨트롤해야하기 때문에 어려움이 따릅니다. 다음 예시를 한번 살펴보겠습니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">       <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">  setContent &#123;</span><br><span class="line">     Theme &#123;</span><br><span class="line">       <span class="keyword">var</span> currentScreen <span class="keyword">by</span> remember &#123; mutableStateOf(Screen.Home) &#125;</span><br><span class="line">			Crossfade(targetState = currentScreen) &#123; screen -&gt;</span><br><span class="line">				<span class="keyword">when</span> (screen) &#123;</span><br><span class="line">					Screen.Home -&gt; </span><br><span class="line">           	HomeScreen(onNavigateCategory = &#123; currentScreen = Screen.Category &#125;)</span><br><span class="line">					Screen.Category -&gt; </span><br><span class="line">            CategoryScreen(onBackScreen = &#123; currentScreen = Screen.Home &#125;)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>액티비티에서 Crossfade 컴포저블 함수를 이용하여 2가지의 화면간 전환을 구현한다고 가정했을 때 위와 같은 코드로 작성할 수 있습니다.</p>
</br>

<p>그리고 각 화면인 HomeScreen과 CategoryScreen 컴포저블 함수를 구현하고 기본 생성자만 가지고 있는 ViewModel을 정의합니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">HomeScreen</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    onNavigateCategory: () -&gt; <span class="type">Unit</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    homeViewModel: <span class="type">HomeViewModel</span> = viewModel()</span></span>,</span><br><span class="line">    categoryViewModel: CategoryViewModel = viewModel()</span><br><span class="line">) &#123;</span><br><span class="line">    Log.d(<span class="string">&quot;HomeScreen&quot;</span>, <span class="string">&quot;HomeViewModel: <span class="variable">$homeViewModel</span>&quot;</span>)</span><br><span class="line">    Log.d(<span class="string">&quot;HomeScreen&quot;</span>, <span class="string">&quot;CategoryViewModel: <span class="variable">$categoryViewModel</span>&quot;</span>)</span><br><span class="line">    Button(onClick = &#123; onNavigateCategory() &#125;) &#123;</span><br><span class="line">        Text(<span class="string">&quot;Navigate to Category&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HomeViewModel</span> : <span class="type">ViewModel</span>()</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">CategoryScreen</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    onBackScreen: () -&gt; <span class="type">Unit</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    categoryViewModel: <span class="type">CategoryViewModel</span> = viewModel()</span></span>,</span><br><span class="line">    homeViewModel: HomeViewModel = viewModel()</span><br><span class="line">) &#123;</span><br><span class="line">  	Log.d(<span class="string">&quot;CategoryScreen&quot;</span>, <span class="string">&quot;HomeViewModel: <span class="variable">$homeViewModel</span>&quot;</span>)</span><br><span class="line">    Log.d(<span class="string">&quot;CategoryScreen&quot;</span>, <span class="string">&quot;CategoryViewModel: <span class="variable">$categoryViewModel</span>&quot;</span>)</span><br><span class="line">    Button(onClick = &#123; onBackScreen() &#125;) &#123;</span><br><span class="line">        Text(<span class="string">&quot;Back&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CategoryViewModel</span> : <span class="type">ViewModel</span>()</span><br></pre></td></tr></table></figure>

</br>

<p>해당 코드를 실행해보면 기존 화면에서 ViewModel 인스턴스는 소멸되고 전환된 화면에서 새로운 인스턴스를 기대하지만 동일한 인스턴스를 반환합니다. 이렇게 된다면 비즈니스 로직들을 가지고 있는 VIewModel을 다른 화면에서 재사용하기가 어려워집니다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HomeViewModel: com.kennethss.android.compose.HomeViewModel@ac8887</span><br><span class="line">CategoryViewModel: com.kennethss.android.compose.CategoryViewModel@a7973b4</span><br><span class="line">HomeViewModel: com.kennethss.android.compose.HomeViewModel@ac8887</span><br><span class="line">CategoryViewModel: com.kennethss.android.compose.CategoryViewModel@a7973b4</span><br></pre></td></tr></table></figure>

</br>

<p>ViewModel을 재생성 하기위해 화면간 전환 시  <code>LocalViewModelStoreOwner.current?.viewModelStore?.clear()</code>를 호출하여 ViewModel의 인스턴스 전체를 해제하거나 별도의 장치로 부분적으로 해제를 해야합니다. 이런 생성과 소멸에 대한 컨트롤을 구현하려면 많은 보일러플레이트 코드가 생성되고 유지보수가 어렵게됩니다. </p>
<p>이를 해결하기 위해 안드로이드에서는 화면간 전환을 도와주는 Navigation 컴포넌트를 제공하고있고 컴포즈 역시 이를 지원합니다.</p>
<br/>

<hr>
</br>

<h2 id="hiltViewModel"><a href="#hiltViewModel" class="headerlink" title="hiltViewModel()"></a>hiltViewModel()</h2><p>젯팩의 Navigation 컴포넌트는 컴포즈를 지원하여 기존 <code>Navigation</code> 기능들과 인프라들을 활용하여 컴포저블간의 이동을 도와주는 라이브러리입니다. 그리고 의존성 주입 라이브러리인 Hilt도 컴포즈와 원활하게 동작합니다. 이를 이용해서 <code>hiltViewModel()</code>이 동작하는 방법과 <code>viewModel()</code>과 다른점을 살펴보겠습니다.</p>
<p>컴포저블에서 hiltViewModel()을 호출하여 ViewModel을 생성 할 수 있습니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">HomeScreen</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    homeViewModel: <span class="type">HomeViewModel</span> = hiltViewModel()</span></span></span><br><span class="line">  	<span class="comment">//..</span></span><br><span class="line">) &#123;</span><br><span class="line">   <span class="comment">//..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@HiltViewModel</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HomeViewModel</span> <span class="meta">@Inject</span> <span class="keyword">constructor</span>(): ViewModel()</span><br></pre></td></tr></table></figure>

</br>

<p>hiltViewModel 내부 코드를 살펴보겠습니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> androidx.hilt.navigation.compose</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> VM : ViewModel&gt;</span> <span class="title">hiltViewModel</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    viewModelStoreOwner: <span class="type">ViewModelStoreOwner</span> = checkNotNull(LocalViewModelStoreOwner.current)</span></span> &#123;</span><br><span class="line">        <span class="string">&quot;No ViewModelStoreOwner was provided via LocalViewModelStoreOwner&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">): VM &#123;</span><br><span class="line">    <span class="keyword">val</span> factory = createHiltViewModelFactory(viewModelStoreOwner)</span><br><span class="line">    <span class="keyword">return</span> viewModel(viewModelStoreOwner, factory = factory)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="meta">@PublishedApi</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">createHiltViewModelFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    viewModelStoreOwner: <span class="type">ViewModelStoreOwner</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: ViewModelProvider.Factory? = <span class="keyword">if</span> (viewModelStoreOwner <span class="keyword">is</span> NavBackStackEntry) &#123;</span><br><span class="line">    HiltViewModelFactory(</span><br><span class="line">        context = LocalContext.current,</span><br><span class="line">        navBackStackEntry = viewModelStoreOwner</span><br><span class="line">    )</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Use the default factory provided by the ViewModelStoreOwner</span></span><br><span class="line">    <span class="comment">// and assume it is an @AndroidEntryPoint annotated fragment or activity</span></span><br><span class="line">    <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>해당 코드의 주석을 해석해보자면, 현재 내비게이션 그래프에서 백스택에 대한 새로운 ViewModel 스코프를 생성하고 내비게이션 그래프가 없다면 프래그먼트나 액티비티 같은 현재 사용되고 있는 스코프를 전달한다고 작성되어 있습니다.</p>
<p>코드를 보면 <code>createHiltViewModelFactory()</code> 함수를 이용해 별도의 factory를 가져오고 인자로 받은 ViewModelStoreOwner 타입이  <code>NavBackStackEntry</code>일 경우 <code>HiltViewModelFactory()</code> 함수를 호출하고 인자로 전달합니다. 그게 아니라면 null을 리턴하여 컴포즈에서 기본으로 생성할 수 있는 <code>viewModel()</code>호출과 동일한 동작을 합니다.</p>
</br>



<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> androidx.hilt.navigation</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">HiltViewModelFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    context: <span class="type">Context</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    navBackStackEntry: <span class="type">NavBackStackEntry</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: ViewModelProvider.Factory &#123;</span><br><span class="line">    <span class="keyword">val</span> activity = context.let &#123;</span><br><span class="line">        <span class="keyword">var</span> ctx = it</span><br><span class="line">        <span class="keyword">while</span> (ctx <span class="keyword">is</span> ContextWrapper) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ctx <span class="keyword">is</span> Activity) &#123;</span><br><span class="line">                <span class="keyword">return</span><span class="symbol">@let</span> ctx</span><br><span class="line">            &#125;</span><br><span class="line">            ctx = ctx.baseContext</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> IllegalStateException(</span><br><span class="line">            <span class="string">&quot;Expected an activity context for creating a HiltViewModelFactory for a &quot;</span> +</span><br><span class="line">                <span class="string">&quot;NavBackStackEntry but instead found: <span class="variable">$ctx</span>&quot;</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> HiltViewModelFactory.createInternal(</span><br><span class="line">        activity,</span><br><span class="line">        navBackStackEntry, <span class="comment">// SavedStateRegistryOwner로 치환</span></span><br><span class="line">        navBackStackEntry.arguments, <span class="comment">// Bundle 객체</span></span><br><span class="line">        navBackStackEntry.defaultViewModelProviderFactory, <span class="comment">//ViewModelProvider.Factory</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>결국 이렇게 전달받은 Context와 <code>NavBackStackEntry</code>는 HiltViewModelFactory클래스에서 Factory을 생성하기 위해 사용합니다.</p>
</br>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> VM : ViewModel&gt;</span> <span class="title">hiltViewModel</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    viewModelStoreOwner: <span class="type">ViewModelStoreOwner</span> = checkNotNull(LocalViewModelStoreOwner.current)</span></span> &#123;</span><br><span class="line">        <span class="string">&quot;No ViewModelStoreOwner was provided via LocalViewModelStoreOwner&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">): VM</span><br></pre></td></tr></table></figure>

</br>

<p>다시 hiltViewModel() 로 돌아가면 <code>LocalViewModelStoreOwner.current</code>는 ViewModelStoreOwner를 리턴하는데 current를 제공해주는 오브젝트는 <code>NavHost</code>에서 화면이 전환될 때 마다  <code>NavBackStackEntry</code>의 확장함수인 <code>LocalOwnersProvider</code>를 호출하여 CompositionLocal를 이용해 <code>NavBackStackEntry</code>를 전달하고 결과적으로 ViewModel은 <code>NavBackStackEntry</code>의 스코프를 가지게됩니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> NavBackStackEntry.<span class="title">LocalOwnersProvider</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="comment">// ..</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    CompositionLocalProvider(</span><br><span class="line">        LocalViewModelStoreOwner provides <span class="keyword">this</span>,</span><br><span class="line">      	<span class="comment">// ..</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// ..</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</br>

<hr>
</br>

<h2 id="NavGraph에서-ViewModel-인스턴스-유지"><a href="#NavGraph에서-ViewModel-인스턴스-유지" class="headerlink" title="NavGraph에서 ViewModel 인스턴스 유지"></a>NavGraph에서 ViewModel 인스턴스 유지</h2><p>Navigation 컴포즈를 사용할 때 로그인이나 회원가입 흐름에서 화면 단위로 공통된 ViewModel 인스턴스를 유지해야 하는 경우도 발생합니다. 이 경우 기존 Fragment에서는  <code>activityViewModels()</code>을 활용해 유지했다면 컴포즈 내비게이션에서는  <code>hiltViewModel()</code>을 이용해 ViewModel 인스턴스를 유지할 수 있습니다. </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">composable(</span><br><span class="line">  route = <span class="string">&quot;category&quot;</span></span><br><span class="line">  ..</span><br><span class="line">) &#123; backStackEntry -&gt;</span><br><span class="line">	<span class="keyword">val</span> parentEntry = remember(backStackEntry) &#123;</span><br><span class="line">		navController.getBackStackEntry(<span class="string">&quot;home&quot;</span>)</span><br><span class="line">	&#125;  </span><br><span class="line">  CategoryScreen(</span><br><span class="line">    categoryViewModel = hiltViewModel(parentEntry)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>CategoryScreen에서 뒤로가기를 눌러 HomeScreen으로 이동해도 CategoryViewModel의 인스턴스는 유지됩니다.</p>
</br>

<hr>
</br>

<h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p><code>viewModel()</code>과 <code>hiltViewModel()</code>의 가장 큰 차이는 <code>NavBackStackEntry</code>의 사용 여부라고 볼 수 있습니다. 왠지navViewModel과 같은 네이밍이 떠오르지만  <code>HiltViewModelFactory</code>를 이용해 Factory를 생성한다는 점에서 <code>hiltViewModel()</code> 이름을 짓지 않았을까 라고 추측해봅니다. 🧐</p>
<p>지금까지 긴  글 읽어주셔서 감사합니다. 🙇‍♂️</p>
<h3 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://developer.android.com/guide/navigation/navigation-type-safety">Type safety in Kotlin DSL and Navigation Compose</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://developer.android.com/jetpack/compose/libraries">Compose and other libraries</a></p>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-02-01T18:27:21.000Z" title="2023. 2. 2. 오전 3:27:21">2023-02-02</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-02-01T18:29:24.770Z" title="2023. 2. 2. 오전 3:29:24">2023-02-02</time></span><span class="level-item"><a class="link-muted" href="/categories/Design-Pattern/">Design Pattern</a></span><span class="level-item">6 minutes read (About 895 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/02/02/%EC%A4%91%EC%9E%AC%EC%9E%90-%ED%8C%A8%ED%84%B4-Mediator-Pattern/">중재자 패턴(Mediator Pattern)</a></h1><div class="content"><h2 id="중재자-패턴-Mediator-Pattern-이란"><a href="#중재자-패턴-Mediator-Pattern-이란" class="headerlink" title="중재자 패턴(Mediator Pattern)이란"></a>중재자 패턴(Mediator Pattern)이란</h2><p>**중재자 패턴(Mediator Pattern)**은 객체간의 상호작용을 캡슐화하는 디자인 패턴으로 프로그램의 실행중 행위를 바꾸는 방법으로 Behavior Pattern에 속하게됩니다. </p>
<p>객체 지향 프로그래밍에서 프로그램은 일반적으로 비즈니스 로직이나 계산 처리로 분류된 수 많은 클래스들로 구성되어있고 이런 클래스간의 상호작용하는 커뮤니케이션이 많아질수록 유지보수나 리팩토링은 더 어려워집니다. 또한 하나의 클래스 코드에 변경이 발생하면서 다른 코드에도 영향을 미치게합니다.</p>
<p>중재자 패턴(Mediator Pattern)은 중재자라는 객체안에서 서로 다른 객체들을 캡슐화하여 객체들이 더 이상 직접적으로 상호작용하지않고 중재자를 통해서만 커뮤니케이션하도록 합니다. 이런 방법은 객체간의 커뮤니케이션에서 의존성을 줄이며 클래스간 느슨한 결합을 만듭니다.</p>
</br>

<h3 id="목적과-사용-시점"><a href="#목적과-사용-시점" class="headerlink" title="목적과 사용 시점"></a>목적과 사용 시점</h3><p>중재자 패턴은 서로 상호작용하는 오브젝트들을 캡슐화함으로써 느슨한 결합을 유지하기 위해 사용합니다. 만약 객체들 사이의 M : N 의 관계가 형성되어 복잡한 상호작용을 하고 있다면 이것을 M : 1 관계로 바꿔주어 상호작용을 원활하게 합니다. 즉, 해당 패턴은 <strong>객체 간의 많은 의존관계</strong>를 가지거나 <strong>상호작용이 복잡해 질 때</strong> 사용합니다.</p>
</br>

<h3 id="구조"><a href="#구조" class="headerlink" title="구조"></a>구조</h3><p><img src="https://velog.velcdn.com/images/wlsrhkd4023/post/a735efc4-bd0b-467b-b1c1-9d25d60f5be0/image.jpg"></p>
<ul>
<li>Mediator : Colleague 객체간의 커뮤니케이션을 위한 인터페이스 정의</li>
<li>Colleague : Mediator를 통해 다른 Colleague와 커뮤니케이션을 위한 인터페이스 정의</li>
<li>ConcreteMediator : Mediator 구현체로 Colleague들간의 상호 커뮤니케이션을 위해 Colleague들을 가지고 있으며 커뮤니케이션을 조정함</li>
<li>ConcreteColleague : Colleague 인터페이스 구현체</li>
</ul>
</br>



<h3 id="예제"><a href="#예제" class="headerlink" title="예제"></a>예제</h3><p><img src="https://velog.velcdn.com/images/wlsrhkd4023/post/e8267cba-6920-4002-a3d0-11e931ee57b2/image.png"></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addUser</span><span class="params">(user: <span class="type">User</span>)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sendMessage</span><span class="params">(user: <span class="type">User</span>, msg: <span class="type">String</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> mediator: Mediator</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">receive</span><span class="params">(msg: <span class="type">String</span>)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">send</span><span class="params">(msg: <span class="type">String</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ManUser</span>(</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> mediator: Mediator</span><br><span class="line">) : User &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">receive</span><span class="params">(msg: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Man got msg: <span class="variable">$msg</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">send</span><span class="params">(msg: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        mediator.sendMessage(<span class="keyword">this</span>, msg)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WomanUser</span>(</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> mediator: Mediator</span><br><span class="line">) : User &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">receive</span><span class="params">(msg: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Woman got msg: <span class="variable">$msg</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">send</span><span class="params">(msg: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        mediator.sendMessage(<span class="keyword">this</span>, msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserMessageMediator</span> : <span class="type">Mediator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> userList = arrayListOf&lt;User&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">addUser</span><span class="params">(user: <span class="type">User</span>)</span></span> &#123;</span><br><span class="line">        userList.add(user)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">sendMessage</span><span class="params">(user: <span class="type">User</span>, msg: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        userList.forEach &#123;</span><br><span class="line">            <span class="keyword">if</span> (it != user) it.receive(msg)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> mediator = UserMessageMediator()</span><br><span class="line">    <span class="keyword">val</span> man = ManUser(mediator)</span><br><span class="line">    <span class="keyword">val</span> woman = WomanUser(mediator)</span><br><span class="line"></span><br><span class="line">    mediator.addUser(man)</span><br><span class="line">    mediator.addUser(woman)</span><br><span class="line"></span><br><span class="line">    man.send(<span class="string">&quot;Hi, how are you?&quot;</span>)</span><br><span class="line">    woman.send(<span class="string">&quot;I am good!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Woman got msg: Hi, how are you?</span></span><br><span class="line"><span class="comment">// Man got msg: I am good!</span></span><br></pre></td></tr></table></figure>



<h3 id="옵저버-패턴과의-차이"><a href="#옵저버-패턴과의-차이" class="headerlink" title="옵저버 패턴과의 차이"></a>옵저버 패턴과의 차이</h3><p><strong>옵저버 패턴</strong>은 1개의 발행자에 N개의 구독자가 존재하여 옵저버가 발행을 담당하고 <strong>중개자 패턴</strong>은 M개의 퍼블리셔와 N개의 구독자 사이에서 1개의 중개자를 통해 통신합니다. 옵저버 패턴은 재사용성은 좋지만 중개자 패턴은 애플리케이션의 로직에 맞추어 개발하기 때문에 재사용성 어렵습니다.</p>
<h3 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h3><ul>
<li><a target="_blank" rel="noopener" href="https://brownbears.tistory.com/568">[Design Pattern] 중재자 패턴 (Mediator Pattern)</a></li>
<li><a target="_blank" rel="noopener" href="https://ganghee-lee.tistory.com/8">[디자인패턴] Mediator Pattern (중재자 패턴)</a></li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-01-30T09:11:03.000Z" title="2023. 1. 30. 오후 6:11:03">2023-01-30</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-01-30T09:11:50.601Z" title="2023. 1. 30. 오후 6:11:50">2023-01-30</time></span><span class="level-item"><a class="link-muted" href="/categories/Kotlin/">Kotlin</a></span><span class="level-item">11 minutes read (About 1668 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/01/30/Kotlin-%EB%B6%88%EB%B3%80%EC%84%B1-Immutability-%EA%B3%BC-%EA%B0%80%EB%B3%80%EC%84%B1-Mutability/">Kotlin - 불변성(Immutability)과 가변성(Mutability)</a></h1><div class="content"><h2 id="불변성-Immutability-과-가변성-Mutability"><a href="#불변성-Immutability-과-가변성-Mutability" class="headerlink" title="불변성(Immutability)과 가변성(Mutability)"></a>불변성(Immutability)과 가변성(Mutability)</h2><h3 id="불변성이란-무엇일까"><a href="#불변성이란-무엇일까" class="headerlink" title="불변성이란 무엇일까?"></a>불변성이란 무엇일까?</h3><p>함수형 프로그래밍에서는 불변성을 중요하게 생각합니다. 코틀린은 함수형 프로그래밍을 지원하는 언어로 불변성을 강제하지않고 가변을 허용하지만 불변성을 권장하고 있습니다. </p>
<p>불변성(Immutability)이란 함수형 프로그램에서 중요하게 다루는 부분으로 보통의 의미는 <strong>상태를 변경하지 않는 것</strong>으로 정의됩니다.</p>
<p>그렇다면 상태를 변경하는 것은 프로그램의 변수를 변경하거나 재할당하는 행위라고 볼 수 있지만 더 근본적으로는 컴퓨터에 저장된 메모리의 특정 공간에 저장된 값을 변경하는 행위를 의미합니다. 이런 행위는 어떤 문제가 생기길래 코틀린에서 불변성을 권장할까요?</p>
</br>

<h3 id="가변성-Mutability-의-문제"><a href="#가변성-Mutability-의-문제" class="headerlink" title="가변성(Mutability)의 문제"></a>가변성(Mutability)의 문제</h3><p>불변성과 반대로 가변성은 상태를 가지는 경우를 얘기합니다. 만약 상태를 가지면 어떤 문제점들이 발생할까요? </p>
<p>앞서 상태를 변경하는 행위는 메모리의 저장된 값을 변경하는 행위라고 언급했습니다. 이렇게 메모리에 저장된 하나의 값을 누구든지 변경할 수 있다는 것은 무분별한 상태가 변경이 된다는 것을 의미합니다. 무분별한 상태가 변경이 되는 것은 다음과 같은 문제를 발생 시킬 수 있습니다.</p>
<ul>
<li>멀티스레드에서 값을 보장하지 못함</li>
<li>값의 예측이 어렵고 변경에 있어서 위험하다</li>
<li>테스트와 디버깅이 어려움</li>
<li>상태 변경 발생 시 처리를 해주어야함</li>
</ul>
</br>

<h3 id="불변성-Immutability-을-지켜야-하는-이유"><a href="#불변성-Immutability-을-지켜야-하는-이유" class="headerlink" title="불변성(Immutability)을 지켜야 하는 이유"></a>불변성(Immutability)을 지켜야 하는 이유</h3><p>불변성이란 값이나 상태를 변경할 수 없는 것으로 정의됩니다. 불변 객체는 생성 시점 이후 한 번 정의된 상태는 계속 유지하며 변경되지 않으므로 스레드 간 안전성이 보장되며 이를 통해 동기화 문제를 해결할 수 있습니다. 그리고 한 번 생성한 값은 변경되지 않으므로 캐시도 수월합니다. 또한 기존 객체에서 프로퍼티가 변경된 객체를 리턴 받고자 할 때 방어적 복사본을 작성하지 않아도됩니다.</p>
<ul>
<li>스레드 안전성(thread-safe)</li>
<li>캐시가 쉬움</li>
<li>방어적 복사본이나 깊은 복사를 하지 않아도됨</li>
<li>사이드 이펙트를 줄임</li>
</ul>
</br>

<h3 id="Kotlin에서는-가변성을-어떻게-제한하고-있을까"><a href="#Kotlin에서는-가변성을-어떻게-제한하고-있을까" class="headerlink" title="Kotlin에서는 가변성을 어떻게 제한하고 있을까?"></a>Kotlin에서는 가변성을 어떻게 제한하고 있을까?</h3><p>코틀린에서는 크게 3가지로 가변성을 제한하고 있습니다.</p>
<ul>
<li>읽기 전용 프로퍼티 <code>val</code></li>
<li>Mutable 컬렉션과 read-only 컬렉션 구분</li>
<li>data class의 copy()</li>
</ul>
</br>

<h3 id="Kotlin에서-불변-객체-사용과-데이터의-변경"><a href="#Kotlin에서-불변-객체-사용과-데이터의-변경" class="headerlink" title="Kotlin에서 불변 객체 사용과 데이터의 변경"></a>Kotlin에서 불변 객체 사용과 데이터의 변경</h3><p>코틀린에서는 value를 의미하는 읽기 전용 프로퍼티인  <code>val</code> 를 이용해 불변 변수를 사용할 수 있습니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Play</span> &#123;</span><br><span class="line">	<span class="keyword">val</span> count = <span class="number">0</span></span><br><span class="line">  <span class="keyword">val</span> countStr: String = <span class="string">&quot;Count&quot;</span></span><br><span class="line">  	<span class="keyword">get</span>() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;<span class="variable">$field</span> <span class="subst">$&#123;++count&#125;</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">fun</span> <span class="title">addedCount</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Added Count: <span class="variable">$countStr</span>&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// &quot;Added Count: Count 0&quot;</span></span><br><span class="line">	<span class="comment">// &quot;Added Count: Count 1&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>그치만 <code>val</code>는 완전한 불변이아닌 불변성에 가깝습니다. 그 이유는 countStr 변수에 backing field를 사용하여 호출할 때 마다 변경된 값을 리턴할 수 있기 때문입니다. 완전한 불변성으로 강제하는 방법은 <code>const val</code>를 사용하여 컴파일 타임 상수를 가지는 것입니다.</p>
</br>

<p>코틀린에서 불변성의 종류는 <strong>참조 불변성</strong>, <strong>불변 값</strong> 두 가지가 존재합니다. 불변 값은 <code>const val</code>을 통해 제공합니다.</p>
<p>참조 불변성 같은 경우 <code>val</code>를 제공하여 참조가 할당되었을 때 다시 할당할 수 없게 합니다. Collection의 MutableList를 예로 들어본다면 </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> list = mutableListOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">  println(list) <span class="comment">// [1, 2, 3]</span></span><br><span class="line">  list.add(<span class="number">4</span>) </span><br><span class="line">  println(list) <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">val</span> anotherList = mutableListOf(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">  list = anotherList <span class="comment">// 컴파일 에러</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>참조 불변성에 의하면 list는 값이 변경되어야 하지 않아야할텐데 변경이 일어났습니다. 이는 <code>val</code> 속성이 불변 참조를 하므로 실제 List의 인스턴스는 변하지 않았고 MutableList의 내부의 값만 변경되었기 때문에 에러가 발생하지 않습니다.</p>
<p>또한 코틀린은 컬렉션에 대해서 읽기 전용(read-only)와 가변 컬렉션을 엄격하게 구분하고 있습니다. </p>
<ul>
<li>읽기 전용 : Iterable, Collection, List, Set 인터페이스</li>
<li>Mutable : MutableIterable, MutableCollection, MutableSet, MutableList 인터페이스</li>
</ul>
<p>읽기 전용은 내부에서 값을 변경하는 함수들을 제공하지 않습니다. 만약 데이터를 추가, 삭제, 수정하려는 경우에는 <code>toMutableList()</code> 함수를 이용해서 요소들을 변경 가능한 컬렉션으로 변경하여 사용해야합니다. 만약 <code>list as MutableList</code>와 같이 다운캐스팅을 시도 한다면 코틀린에서 정한 읽기전용 규칙을 무시하기 때문에 이러한 행위는 지양해야 합니다.</p>
<p>또한 코틀린에서 컬렉션을 다룰 때  <code>var</code>와 함께 Mutable Collection을 사용하면 두개의 가변 포인트를 모두 동기화 해주어야 하기 때문에 이렇게 사용해서는 안됩니다.</p>
</br>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Fruit</span>(</span><br><span class="line">    <span class="keyword">val</span> name: String,</span><br><span class="line">    <span class="keyword">val</span> price: <span class="built_in">Int</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">val</span> banana = Fruit(<span class="string">&quot;banana&quot;</span>, <span class="number">500</span>)</span><br><span class="line">	<span class="keyword">val</span> strawberry = banana.copy(name = <span class="string">&quot;strawberry&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;banana <span class="subst">$&#123;banana.hashCode()&#125;</span> <span class="variable">$banana</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;strawberry <span class="subst">$&#123;strawberry.hashCode()&#125;</span> <span class="variable">$strawberry</span>&quot;</span>)</span><br><span class="line">    <span class="comment">//banana -337338577 Fruit(name=banana, price=500)</span></span><br><span class="line">    <span class="comment">//strawberry 986991237 Fruit(name=strawberry, price=500)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>data class의 copy를 통해서 기존 객체의 값을 변경하지 않고 프로퍼티를 변경하여 새로운 값을 할당한 객체를 받아 불변성을 유지할 수 있습니다.</p>
</br>

<h3 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h3><p>불변성이 항상 장점만 가진다고 생각하지는 않습니다. 가변을 피하기 위해 새로운 객체를 생성하는 것은 비용 증가로 이어지기 때문에 불필요한 인스턴스화나 잦은 복사는 오버헤드로 이어질 수 도있다고 생각합니다. 하지만 불변성이 가지는 장점들이 가변성의 많은 단점들을 해소하기 때문에 코틀린에서도 불변성을 권장했을겁니다. </p>
<p>긴 글 읽어주셔서 감사합니다. 🙇‍♂️</p>
</br>



<h3 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://readystory.tistory.com/105">Kotlin 코틀린(kotlin)과 불변성(immutability)</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://javabom.tistory.com/120">이펙티브 코틀린 Item1. 가변성을 제한하라</a></p>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-01-29T15:47:52.000Z" title="2023. 1. 30. 오전 12:47:52">2023-01-30</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-01-29T15:48:34.719Z" title="2023. 1. 30. 오전 12:48:34">2023-01-30</time></span><span class="level-item"><a class="link-muted" href="/categories/Coroutine/">Coroutine</a><span> / </span><a class="link-muted" href="/categories/Coroutine/Flow/">Flow</a></span><span class="level-item">11 minutes read (About 1618 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/01/30/Coroutine-StateFlow%EC%99%80-SharedFlow-%ED%8A%B9%EC%A7%95-%EB%B0%8F-%EC%B0%A8%EC%9D%B4/">Coroutine - StateFlow와 SharedFlow 특징 및 차이</a></h1><div class="content"><h2 id="들어가며"><a href="#들어가며" class="headerlink" title="들어가며"></a>들어가며</h2><p>안드로이드 개발을 하다보면 상태와 이벤트처리를 해야합니다. 기존에는 LiveData, SingleLiveData를 활용해서 View의 상태를 업데이트하거나 이벤트를 전달하는 방법을 제공했습니다.</p>
</br>

<p>하지만 LiveData를 도메인 레이어안에서 플랫폼 독립적으로 사용하려고 한다면 안드로이드 의존성 때문에 어려움이 생깁니다. 이전 RxJava를 많이 사용하던 시절에는 RxJava&#x2F;Kotlin의 Hot Stream인 Subject인 BehaviorSubject를 이용해 상태를 관리하여 안드로이드 플랫폼에 독립적으로 사용했습니다. </p>
</br>

<p>그러나 이제는 안드로이드 앱들이 Kotlin으로만 작성되고 있어 RxJava&#x2F;Kotlin의 의존성없이 Kotlin 코루틴의 Flow를 사용해서 데이터 스트림을 구현할 수 있습니다.</p>
</br>

<p>Flow는 기본적으로 Cold Stream 이지만 이를 Hot Stream으로 사용할 수 있는 Flow가 <code>StateFlow</code> , <code>SharedFlow</code> 입니다. 이 중 최신 상태를 관리하고 전달해 주는 <code>StateFlow</code>의 특징에 대해서 먼저 알아보겠습니다.</p>
</br>

<h2 id="StateFlow"><a href="#StateFlow" class="headerlink" title="StateFlow"></a>StateFlow</h2><p><code>StateFlow</code>는 컬렉터에게 단일의 최신 데이터 값만 업데이트를 보장하는 핫 플로우입니다.</p>
<p><code>StateFlow</code>의 특징은 초기값 가지며 <code>emit()</code> 혹은 <code>value</code> 로 프로퍼티에 접근할 수 있습니다. 또한 이전에 내보낸 값과 동일한 값을 소비자에게 전달하지 않도록 <code>distinctUntilChanged()</code>와 같은 연산자의 기능을 가지고 있습니다.</p>
<blockquote>
<p>📘 StateFlow는 Any.equals를 이용해서 이전에 내보낸 값과 동일한 값인지 비교하고 결합합니다.<br>      Any.equals의 규칙을 따르지 않은 클래스는 StateFlow에서 의도된 동작을 보장하지 못합니다.</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _stateFlow = MutableStateFlow(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">val</span> stateFlow = _stateFlow.asStateFlow() <span class="comment">// ready-only</span></span><br><span class="line"></span><br><span class="line">_stateFlow.emit(<span class="number">1</span>)</span><br><span class="line">_stateFlow.value = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><code>StateFlow</code>는 항상 최신의 값을 가져오기 때문에 최신 상태를 유지하는 데이터 홀더로써 사용이 권장됩니다</p>
<h2 id="SharedFlow"><a href="#SharedFlow" class="headerlink" title="SharedFlow"></a>SharedFlow</h2><p><code>SharedFlow</code>도 마찬가지로 Hot Flow로 애플리케이션에서 구독자들에게 이벤트를 전달하는 목적으로 사용합니다. </p>
<p><code>SharedFlow</code>의 생성은 MutableSharedFlow() 생성자 함수로 만들 수 있습니다. 파라미터가 없는 기본 생성자로 만들 수도 있지만 아래와 같은 파라미터로 <code>SharedFlow</code>의 옵션들을 설정할 수 있습니다.</p>
<ul>
<li><p><strong>replay</strong> : 새로운 구독자에게 이전 이벤트를 전달할 개수</p>
</li>
<li><p><strong>extraBufferCapacity</strong> : 추가적인 버퍼를 생성하고 emit 한 데이터를 버퍼에 유지</p>
</li>
<li><p><strong>onBufferOverflow</strong> : 버퍼가 가득찬 경우 어떤 동작을 할지 정의</p>
</li>
</ul>
<p><code>SharedFlow</code>는 replay cache에서 가장 최신의 값들을 가지며 새로운 구독자가 생겼을 때 가장 먼저 replay cache에서 데이터를 가져오고 이후 새로 emit된 값을 가져옵니다. replay cache는  <code>resetReplayCache()</code>함수로 재설정할 수 있습니다.</p>
<p><img src="https://velog.velcdn.com/images/wlsrhkd4023/post/c9aaa533-b8c6-48a9-b216-40ad21fc1610/image.png"></p>
<p>또한 replay cache는 버퍼를 제공하는데 뒤늦게 구독한 구독자가 일시 중단하지 않고 버퍼에서 값을 가져올 수 있도록 도와줍니다. 이러한 버퍼 값은 <code>SharedFlow</code>를 생성할 때  <code>extraBufferCapacity</code> 변수를 사용하여 추가 버퍼를 예약하여 사용할 수 있으며 이렇게 설정한 버퍼 공간은 앞서 구독한 구독자와 뒤늦게 구독한 구독자와의 데이터 지연의 정도를 결정합니다.</p>
<p><code>SharedFlow</code>의버퍼사이즈는 replay와 extraBufferCapacity를 합친 값으로 정의되므로 buffer를 사용하기 위해서는 extraBufferCapacity 값을 1이상으로 설정해주어야합니다.</p>
</br>

<p>하지만 이렇게 설정한 버퍼도 용량이 가득차게 된다면 오버플로에 맞는 전략을 수립해야합니다. SharedFlow에서 적용 가능한 BufferOverFlow는 3가지를 제공합니다.</p>
<ul>
<li><p><strong>BufferOverflow.SUSPEND</strong> : 버퍼가 가득찼을 때 업스트림인 send()나 emit()이 blocking 됩니다.</p>
</li>
<li><p><strong>BufferOverflow.DROP_OLDEST</strong> : 가장 오래된 값을 버리고 새로운 값을 추가합니다.</p>
</li>
<li><p><strong>BufferOverflow.LATEST</strong> : 최신 값을 버리고 새로운 값을 추가합니다.</p>
</li>
</ul>
<blockquote>
<p>📘 버퍼 오버플로는 새로운 값을 받을 준비가 안된 최소 하나의 구독자가 있을 때만 발생합니다.</p>
</blockquote>
<p>구독자가 하나도 없는 경우에는 최근의 replay value만 저장되며 오버플로는 트리거되지 않으며  만약  <code>BufferOverFlow.SUSPEND</code>, <code>BufferOverFlow.DROP_LATEST</code> 사용에도 blocking 되지 않습니다.</p>
</br>

<p>기본적으로 <code>SharedFlow</code>는 매개변수 없는 생성자 함수로 생성시 replay cache나 buffer가 없는 <code>StateFlow</code>를 만들 수 있습니다. 이런 경우에 <code>emit()</code>함수를 호출하면 구독자가 값을 받을 때 까지 일시중단하며 구독자가 없는 경우는 즉시 리턴합니다. </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">emit</span><span class="params">(value: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">	  <span class="keyword">if</span> (tryEmit(value)) <span class="keyword">return</span> <span class="comment">// fast-path</span></span><br><span class="line">	  emitSuspend(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SharedFlow의 내부 코드를 살펴보면 <code>emit()</code> 함수는 <code>tryEmit()</code>함수가 <code>true</code>라면 리턴하게 되어있습니다. </p>
</br>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">tryEmit</span><span class="params">(value: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> resumes: Array&lt;Continuation&lt;<span class="built_in">Unit</span>&gt;?&gt; = EMPTY_RESUMES</span><br><span class="line">    <span class="keyword">val</span> emitted = synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (tryEmitLocked(value)) &#123;</span><br><span class="line">        resumes = findSlotsToResumeLocked(resumes)</span><br><span class="line">        <span class="literal">true</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (cont <span class="keyword">in</span> resumes) cont?.resume(<span class="built_in">Unit</span>)</span><br><span class="line">    <span class="keyword">return</span> emitted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>따라서 <code>tryEmit()</code>은 구독자가 없는 경우라면 <code>true</code>를 반환하는 것을 알 수 있습니다. (이 경우 내보내려고 한 값은 즉시 손실됩니다)</p>
</br>



<p>SharedFlow를 이용해서 안드로이드에서 이벤트를 전파하는 코드는 다음과 같습니다. 안드로이드에선 일반적으로 ViewModel에서 해당코드를 작성하게 됩니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _events = MutableSharedFlow&lt;Event&gt;(</span><br><span class="line">	replay = <span class="number">0</span>,</span><br><span class="line">	extraBufferCapacity = <span class="number">1</span>,</span><br><span class="line">	onBufferOverflow = BufferOverflow.SUSPEND</span><br><span class="line">)</span><br><span class="line"><span class="keyword">val</span> events = _events.asSharedFlow()</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">sendEvent</span><span class="params">(event: <span class="type">Event</span>)</span></span> &#123;</span><br><span class="line">  	_events.emit(event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>StateFlow와 SharedFlow의 계층 구조는 다음과 같습니다.</p>
<p><img src="https://velog.velcdn.com/images/wlsrhkd4023/post/8a389d13-9ca0-4ced-b86d-587598670000/image.png"></p>
<h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><p>StateFlow와 SharedFlow 모두 각각의 특징을 가지고 있어 이러한 Hot Flow들을 적절히 활용하면 직관적이고 간결한 코드를 작성할 수 있습니다.</p>
<h3 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.kodeco.com/22030171-reactive-streams-on-kotlin-sharedflow-and-stateflow">Reactive Streams on Kotlin: SharedFlow and StateFlow</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-shared-flow/">kotlinx.coroutines - SharedFlow</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-state-flow/">kotlinx.coroutines - StateFlow</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://myungpyo.medium.com/stateflow-%EC%99%80-sharedflow-32fdb49f9a32">StateFlow 와 SharedFlow - Myungpyo Shim</a></p>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-01-28T06:45:16.000Z" title="2023. 1. 28. 오후 3:45:16">2023-01-28</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-01-28T06:45:50.471Z" title="2023. 1. 28. 오후 3:45:50">2023-01-28</time></span><span class="level-item"><a class="link-muted" href="/categories/Kotlin/">Kotlin</a></span><span class="level-item">5 minutes read (About 795 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/01/28/kotlin-default%EA%B0%80-final%EC%9D%B8-%EC%9D%B4%EC%9C%A0/">kotlin default가 final인 이유</a></h1><div class="content"><p>평상시에 코틀린 파일을 디컴파일하면서 final로 선언되어있는 코드를 보면서 의문만 가지고 이유에 대해서 찾아보지 못하다가 이번 기회에 코틀린에서 default가 final인 이유에 대해서 찾아보았습니다.</p>
<p>제가 생각했을 때는 크게 두가지 이유가 있습니다.</p>
</br>

<p><strong>첫번째</strong>는 코틀린은 함수형 프로그래밍에서 아이디어를 얻어왔고 가변을 사용했을 때 발생하는 문제점들을 줄이기 위해 불변을 사용합니다. 그래서 모든 클래스들이 기본값으로 final로 선언되어 있는 이유기도 합니다. </p>
</br>

<p><strong>두번째</strong>는 상속에대한 문제입니다.</p>
</br>

<p>코틀린 <a target="_blank" rel="noopener" href="https://kotlinlang.org/docs/inheritance.html">공식 문서</a>에 상속을 설명하는 부분을 보면 다음과 같은 문구가 있습니다.</p>
<blockquote>
<p>By default, Kotlin classes are final – they can’t be inherited. To make a class inheritable, mark it with the <code>open</code> keyword:</p>
</blockquote>
<p>코틀린 클래스는 기본적으로 final이며 이는 상속이 불가능하게 합니다. 만약 상속이 가능하게 하려면 <code>open</code>키워드를 써야합니다. 라고 설명되어있습니다.</p>
</br>

<p>객체지향 관점에서 상속은 개발자들이 아직까지도 올바르게 사용하지 못하는 실수들을 하곤합니다. 무분별한 상속은 객체지향의 의도나 목적과는 반대로 설계할 가능성이 있습니다. </p>
</br>

<p>스택오버플로에서 <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/49002/prefer-composition-over-inheritance">상속보다 구성을 선호</a>하는 원칙에 대해서 오래전 부터 논의한 내용이 있습니다. 그래서 제가 생각하기에는 코틀린은 클래스에 대해서 기본값을 final로 설정을하고 개발자들이 어떠한 문제를 마주했을 때 이 문제를 해결하기 위해서 상속을 사용하는 것 보다 더 나은 방법으로 문제를 해결할 수 있게 생각해보라는 의미로도 해석해 볼 수 있을 것 같습니다.</p>
</br>

<p>실제 글 작성 기준인 2023년 1월 28일 기준으로 코틀린 discuss의 <a target="_blank" rel="noopener" href="https://discuss.kotlinlang.org/t/classes-final-by-default/166/12">Classes final by default</a> 글에서 178명의 투표로 final이 52%, open이 48%로 비슷한 비율로 투표가 유지되고 있습니다.</p>
<p><img src="https://velog.velcdn.com/images/wlsrhkd4023/post/c842aa1e-0cf7-48b3-9355-c5ea57ea4ada/image.png"></p>
</br>

<p>final 키워드는 프로퍼티 값을 Immutable하게 만들거나 클래스나 메서드를 상속이나 오버라이드 하지 못하게 만드는 특징이 있습니다. 그렇기 때문에 런타임에 다형성을 체크하지 않아 성능상의 약간의 이점을 가져갈 수 도 있습니다.</p>
</br>

<h3 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h3><ul>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/51680006/why-are-kotlin-classes-final-by-default-instead-of-open">Why are Kotlin classes final by default instead of open?</a></li>
<li><a target="_blank" rel="noopener" href="https://cchcc.github.io/blog/Kotlin-%EB%94%94%ED%8F%B4%ED%8A%B8%EA%B0%80-final%EC%9D%B8-%EC%9D%B4%EC%9C%A0/">Kotlin 디폴트가 final인 이유</a></li>
<li><a target="_blank" rel="noopener" href="https://discuss.kotlinlang.org/t/classes-final-by-default/166/2">Kotlin discuss - <strong>Classes final by default</strong></a></li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-01-27T17:45:59.000Z" title="2023. 1. 28. 오전 2:45:59">2023-01-28</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-01-27T17:53:55.347Z" title="2023. 1. 28. 오전 2:53:55">2023-01-28</time></span><span class="level-item"><a class="link-muted" href="/categories/Kotlin/">Kotlin</a></span><span class="level-item">18 minutes read (About 2723 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/01/28/Kotlin-Type-alias%EC%99%80-Inline-class/">Kotlin - Type alias와 Inline class</a></h1><div class="content"><blockquote>
<p>❓ 이 글은 Kotlin 공식 문서를 번역과 함께 추가 첨언한 글입니다.</p>
</blockquote>
<p>alias는 사전상의 의미로 가명, ~라는 가명으로 알려진의 뜻으로 정의되어있습니다.</p>
<p>코틀린에서 Type aliase는 제네릭 타입의 컬렉션 쓸 때 이름이 길게 된다면 짧은 이름으로 줄여서 사용할 수 있게 별명을 지어주는 것을 가능하게 해줍니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> NodeSet = Set&lt;Network.Node&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typealias</span> FileTable&lt;K&gt; = MutableMap&lt;K, MutableList&lt;File&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>또한 고차 함수 형태도 짧은 이름으로 지어서 사용할 수 있습니다</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> MyHandler = (<span class="built_in">Int</span>, String, Any) -&gt; <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typealias</span> Predicate&lt;T&gt; = (T) -&gt; <span class="built_in">Boolean</span></span><br></pre></td></tr></table></figure>

<p>클래스 내부의 Inner class의 정보를 줄일 때도 사용할 수 있습니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">Inner</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">Inner</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typealias</span> AInner = A.Inner</span><br><span class="line"><span class="keyword">typealias</span> BInner = B.Inner</span><br></pre></td></tr></table></figure>

</br>

<p>Type aliases는 새로운 타입을 생성하기 위해 사용하는것이 아니라 기본적인 타입들을 동등하게 이해시키기 위해서 사용합니다. 만약 <code>typealias Predicate&lt;T&gt;</code> 를 추가하고 Predicate<T>를 코드에서 사용한다면 코틀린 컴파일러 (Int) -&gt; Boolean으로 확장합니다.  </p>
<p>따라서 일반적인 함수 유형을 변수 타입에 맞게 전달할 수 있고 그 반대도 마찬가지로 가능합니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> Predicate&lt;T&gt; = (T) -&gt; <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(p: <span class="type">Predicate</span>&lt;<span class="type">Int</span>&gt;)</span></span> = p(<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> f: (<span class="built_in">Int</span>) -&gt; <span class="built_in">Boolean</span> = &#123; it &gt; <span class="number">0</span> &#125;</span><br><span class="line">    println(foo(f)) <span class="comment">// prints &quot;true&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> p: Predicate&lt;<span class="built_in">Int</span>&gt; = &#123; it &gt; <span class="number">0</span> &#125;</span><br><span class="line">    println(listOf(<span class="number">1</span>, -<span class="number">2</span>).filter(p)) <span class="comment">// prints &quot;[1]&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Result</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// [1]</span></span><br></pre></td></tr></table></figure>



<p>Type Alias는 클래스 혹은 함수 내부에서 정의하는 것은 불가능하며 Top level에서 변수로 정의해야 합니다.  Top level에서 선언한 Type alias는 Public이기 때문에 internal로 사용범위를 모듈로 제한한다고 해도 모듈안에서는 누구나 접근 가능하기 때문에 꼭 필요한 곳에 명세하여 사용해야 합니다.</p>
<p>Type alias에 대해서 정리하면</p>
<ul>
<li>유의미한 이름을 정의해서 사용하면 코드의 가독성을 증가시킬 수 있음</li>
<li>반대로 명확하지 않고 명세나 정의되지 않은 typealias는 오히려 사용성을 저하시킬 수 있음</li>
<li>typealias는 Top level에서만 선언이 가능하기 때문에 여러 곳에서 접근이 가능</li>
</ul>
<hr>
<h1 id="Inline-classes"><a href="#Inline-classes" class="headerlink" title="Inline classes"></a>Inline classes</h1><p>Type alias와 같이 언급되는 Inline class가 있습니다. Inline class가 어떤 것인지 살펴보겠습니다.</p>
<p>비즈니스 로직을 작성하기위해 어떤 타입으로 감싸는 Wrapper를 작성하는 경우가 있습니다. 예를 들어 단순히 Price를 표시하기 위해 Int 형태의 Primitive 타입으로 작성할 수도 있지만 도메인을 조금 더 잘 표현하기 위해 의미를 부여하기 위해서 SalePrice 타입으로 표현할 수 있습니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Item</span>(</span><br><span class="line">	<span class="keyword">val</span> salePrice: <span class="built_in">Int</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Item</span>(</span><br><span class="line">	<span class="keyword">val</span> salePrice: SalePrice</span><br><span class="line">)</span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">SalePrice</span>(<span class="keyword">val</span> price: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure>



<p>하지만 SalePrice와 같은 Wrapper는 Heap영역에 할당되면서 런타임 오버헤드가 발생합니다. 만약 Wrapping된 대상이 Primitive 타입이라면 보통 받을 수 있는 런타임에 최적화를 받지 못해 런타임 성능을 더 악화시킵니다.</p>
<p>이 문제를 해결하기 위해 코틀린에서는 특별한 클래스인 인라인 클래스를 제공합니다. 인라인 클래스는 value 기반 클래스 하위의 집합으로 어떠한 식별자를 가지지 않고 값만 보유하고 있습니다.</p>
<p>인라인 클래스는 클래스 이름 앞에  <code>value</code> 한정자를 사용해서 선언할 수 있습니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value <span class="keyword">class</span> <span class="title class_">Password</span>(<span class="keyword">private</span> <span class="keyword">val</span> s: String)</span><br></pre></td></tr></table></figure>

<p>JVM 백엔드에서 인라인 클래스 선언은 <code>value</code> 한정자 위에 <code>@JvmInline</code> 어노테이션을 선언해야합니다.</p>
<blockquote>
<p>:warning: 인라인 클래스의 <code>inline</code> 한정자는 더 이상 사용되지 않습니다.</p>
</blockquote>
<p>인라인 클래스는 생성자에서 초기화된 단일 프로퍼티만 가질 수 있습니다. 인라인 클래스의 인스턴스는 런타임시에 단일 프로퍼티로 변경되어 표시됩니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 실제로 Password 클래스의 인스턴스화는 발생하지 않습니다.</span></span><br><span class="line"><span class="comment">// 런타임에는 &#x27;securePassword&#x27; 는 단순히 String만 가집니다.</span></span><br><span class="line"><span class="keyword">val</span> securePassword = Password(<span class="string">&quot;Don&#x27;t try this in production&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>이게 인라인 클래스의 핵심 기능이며 클래스의 데이터를 <em>inlined</em> 한다는 관점에서 inline 함수를 호출하는 방식과 유사해서 해당 방식에 영감을 받아 인라인 클래스라는 이름이 붙여지게 되었습니다.</p>
<h3 id="Members"><a href="#Members" class="headerlink" title="Members"></a>Members</h3><p>인라인 클래스는 일반적인 클래스의 기능들을 제공합니다. <code>init</code> 블록을 가질 수 있고 프로퍼티와 함수 또한 선언이 가능합니다. 내부 변수는 backing field를 가질 수 있지만 인라인 클래스의 프로퍼티는 backing field를 가질 수 없으며 간단한 연산가능한 프로퍼티로만 가져야합니다(lateinit과 delegated 프로퍼티도 안됨)</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JvmInline</span></span><br><span class="line">value <span class="keyword">class</span> <span class="title class_">Name</span>(<span class="keyword">val</span> s: String) &#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        require(s.length &gt; <span class="number">0</span>) &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> length: <span class="built_in">Int</span></span><br><span class="line">        <span class="keyword">get</span>() = s.length</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">greet</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Hello, <span class="variable">$s</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> name = Name(<span class="string">&quot;Kotlin&quot;</span>)</span><br><span class="line">    name.greet() <span class="comment">// method `greet` is called as a static method</span></span><br><span class="line">    println(name.length) <span class="comment">// property getter is called as a static method</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Inheritance"><a href="#Inheritance" class="headerlink" title="Inheritance"></a>Inheritance</h3><p>인라인 클래스는 인터페이스 상속이 가능하지만 항상 <code>final</code> 이어야 하기 때문에 다른 클래스로 확장하거나 상속할 수 없습니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Printable</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">prettyPrint</span><span class="params">()</span></span>: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JvmInline</span></span><br><span class="line">value <span class="keyword">class</span> <span class="title class_">Name</span>(<span class="keyword">val</span> s: String) : Printable &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">prettyPrint</span><span class="params">()</span></span>: String = <span class="string">&quot;Let&#x27;s <span class="variable">$s</span>!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> name = Name(<span class="string">&quot;Kotlin&quot;</span>)</span><br><span class="line">    println(name.prettyPrint()) <span class="comment">// Still called as a static method</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Representation"><a href="#Representation" class="headerlink" title="Representation"></a>Representation</h3><p>컴파일러는 생성된 코드에서 인라인 클래스의 <em>wrapper</em> 형태를 유지합니다. 따라서 인라인 클래스는 런타임에 Primitive 타입이나 wrapper 모두 표현할 수 있습니다. 이것은 Kotlin의 <code>Int</code> 클래스가 Primitive 타입인 <code>int</code> 나 Wrapper인 <code>Integer</code> 클래스로 표현하는 방법과 같습니다.</p>
<p>코틀린 컴파일러는 성능이 우수하거나 최적화된 코드를 생성하기 위해 wrapper 대신 기본 타입을 선호하지만  wrapper 형태의 유지를 필요할 때도 있습니다. 일반적으로 인라인 클래스는 다른 유형으로 사용될 때마다 자동으로 boxed, unboxed 되기 때문에 기본 값과 wrapper 모두를 참조 동등성을 비교하는 것은 의미가 없습니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">I</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@JvmInline</span></span><br><span class="line">value <span class="keyword">class</span> <span class="title class_">Foo</span>(<span class="keyword">val</span> i: <span class="built_in">Int</span>) : I</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">asInline</span><span class="params">(f: <span class="type">Foo</span>)</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">asGeneric</span><span class="params">(x: <span class="type">T</span>)</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">asInterface</span><span class="params">(i: <span class="type">I</span>)</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">asNullable</span><span class="params">(i: <span class="type">Foo</span>?)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">id</span><span class="params">(x: <span class="type">T</span>)</span></span>: T = x</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> f = Foo(<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">    asInline(f)    <span class="comment">// unboxed: used as Foo itself</span></span><br><span class="line">    asGeneric(f)   <span class="comment">// boxed: used as generic type T</span></span><br><span class="line">    asInterface(f) <span class="comment">// boxed: used as type I</span></span><br><span class="line">    asNullable(f)  <span class="comment">// boxed: used as Foo?, which is different from Foo</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// &#x27;f&#x27;가 먼저 boxed(&#x27;id&#x27;로 전달되는 동안)되고 이후에 unboxed(&#x27;id&#x27;에서 반환될 때)</span></span><br><span class="line">  	<span class="comment">// 결국 &#x27;c&#x27;는 unboxed된(단지 42의 값) f를 가집니다.</span></span><br><span class="line">    <span class="keyword">val</span> c = id(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>인라인 클래스는 제네릭 타입 파라미터를 기본 타입으로 가질 수 있습니다. 아래 케이스에서는 컴파일러가 Any?로 맵하거나 일반적으로 타입 파라미터의 상한하는 경우입니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JvmInline</span></span><br><span class="line">value <span class="keyword">class</span> <span class="title class_">UserId</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">val</span> value: T)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">compute</span><span class="params">(s: <span class="type">UserId</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;&#125; <span class="comment">// compiler generates fun compute-&lt;hashcode&gt;(s: Any?)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>:warning: 제네릭 인라인 클래스는 <a target="_blank" rel="noopener" href="https://kotlinlang.org/docs/components-stability.html">실험</a> 기능입니다. 언제든지 버려질 수 있으며  <code>-language-version 1.8</code> 컴파일러 옵션이 요구됩니다.</p>
</blockquote>
<h3 id="Managling"><a href="#Managling" class="headerlink" title="Managling"></a>Managling</h3><p>인라인 클래스는 Primitive타입으로 컴파일되므로 시그니처 충돌이라든지 예상하지 못한 오류를 마주할 수 있습니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JvmInline</span></span><br><span class="line">value <span class="keyword">class</span> <span class="title class_">UInt</span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Represented as &#x27;public final void compute(int x)&#x27; on the JVM</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">compute</span><span class="params">(x: <span class="type">Int</span>)</span></span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Also represented as &#x27;public final void compute(int x)&#x27; on the JVM!</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">compute</span><span class="params">(x: <span class="type">UInt</span>)</span></span> &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>이런 문제를 해결하기 위해 인라인 클래스를 사용하는 함수는 함수 이름안에 정적인 해시코드를 추가하여 public final void compute-hashcode(int x) 처럼 지저분하게 표현됩니다.</p>
<blockquote>
<p>📘 mangling 스키마는 1.4.30 부터 변경되었습니다. 컴파일러 플래그에 <code>-Xuse-14-inline-classes-mangling-scheme</code>를 사용하여 컴파일러가 1.4.0 mangling 방식을 사용하여 바이너리 호환성을 유지하도록 합니다.</p>
</blockquote>
<h3 id="Java-코드에서-호출"><a href="#Java-코드에서-호출" class="headerlink" title="Java 코드에서 호출"></a>Java 코드에서 호출</h3><p>Java 코드에서도 인라인 클래스를 허용하는 함수를 호출할 수 있습니다. 이렇게 하려면 함수 선언 앞에  <code>@JvmName</code> 어노테이션을 추가해서 mangling을 수동으로 비활성화해야합니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JvmInline</span></span><br><span class="line">value <span class="keyword">class</span> <span class="title class_">UInt</span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">compute</span><span class="params">(x: <span class="type">Int</span>)</span></span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JvmName(<span class="string">&quot;computeUInt&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">compute</span><span class="params">(x: <span class="type">UInt</span>)</span></span> &#123; &#125;</span><br></pre></td></tr></table></figure>



<h3 id="Inline-classes-and-delegation"><a href="#Inline-classes-and-delegation" class="headerlink" title="Inline classes and delegation"></a>Inline classes and delegation</h3><p>인라인 클래스에서 인터페이스로 인라인 프로퍼티 값에 대한 delegate 구현은 허용됩니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> = <span class="string">&quot;foo&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JvmInline</span></span><br><span class="line">value <span class="keyword">class</span> <span class="title class_">MyInterfaceWrapper</span>(<span class="keyword">val</span> myInterface: MyInterface) : MyInterface <span class="keyword">by</span> myInterface</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> my = MyInterfaceWrapper(<span class="keyword">object</span> : MyInterface &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// body</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    println(my.foo()) <span class="comment">// prints &quot;foo&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="Inline-classes-vs-type-alias"><a href="#Inline-classes-vs-type-alias" class="headerlink" title="Inline classes vs type alias"></a>Inline classes vs type alias</h3><p>인라인 클래스와 type alias는 타입에 대해서 새로운 타입으로 변경하고 런타임에 원래 타입으로 변경되어 사용된다는 점은 동일합니다. 하지만 이 둘의 차이점은 분명히 있습니다. <strong>type aliases</strong>는 기존 타입에 별칭을 붙여 완벽하게 호환하는 것인 반면 <strong>인라인 클래스</strong>는 새로운 타입을 생성하는 것으로 기존 타입과 구분되어 호환되지 않습니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> NameTypeAlias = String</span><br><span class="line"></span><br><span class="line"><span class="meta">@JvmInline</span></span><br><span class="line">value <span class="keyword">class</span> <span class="title class_">NameInlineClass</span>(<span class="keyword">val</span> s: String)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">acceptString</span><span class="params">(s: <span class="type">String</span>)</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">acceptNameTypeAlias</span><span class="params">(n: <span class="type">NameTypeAlias</span>)</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">acceptNameInlineClass</span><span class="params">(p: <span class="type">NameInlineClass</span>)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> nameAlias: NameTypeAlias = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">val</span> nameInlineClass: NameInlineClass = NameInlineClass(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> string: String = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    acceptString(nameAlias) <span class="comment">// OK: 기존 타입 대신에 alis를 넘겨주어도 됨</span></span><br><span class="line">    acceptString(nameInlineClass) <span class="comment">// Not OK: 기존 타입 대신에 인라인 클래스는 넘길 수 없음</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// And vice versa:</span></span><br><span class="line">    acceptNameTypeAlias(string) <span class="comment">// OK: alias 대신에 기본 타입을 넘길 수 있음</span></span><br><span class="line">    acceptNameInlineClass(string) <span class="comment">// Not OK: 기존 타입 대신에 인라인 클래스는 넘길 수 없음</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>지금까지 type alias와 Inline class에 대해서 알아보았습니다. </p>
<p>정리하자면 도메인에서 비즈니스 로직을 감싸기 위해 사용하는 Wrapper는 오버헤드가 발생할 수 있으니 Inline class를 활용해서 작성하면 좋을 것 같고 type alias 같은 경우는 복잡한 형태의 중첩된 제너릭을 사용해서 도메인으로서 사용하는 자료구조의 이름이 복잡할 때 컨벤션을 정해서 이름을 줄여 사용하면 유용해 보입니다.</p>
<h3 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://kotlinlang.org/docs/type-aliases.html">Kotlin - Type aliases</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://kotlinlang.org/docs/inline-classes.html#inline-classes-and-delegation">Kotlin - Inline classes</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://thdev.tech/kotlin/2020/10/13/kotlin_effective_06/">Taehwan - Kotlin typealias와 inline class를 알아보고 적절한 사용법을 알아보자.</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://wooooooak.github.io/kotlin/2021/01/03/inline_class/">쾌락코딩 - Kotlin Inline class</a></p>
</li>
</ul>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/page/0/">Previous</a></div><div class="pagination-next"><a href="/page/2/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li></ul></nav></div><div class="column column-left is-3-tablet is-3-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Your name"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Your name</p><p class="is-size-6 is-block">Your title</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Your location</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">27</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">14</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">10</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/KennethSS" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/KennethSS"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Android/"><span class="level-start"><span class="level-item">Android</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/Android/Compose/"><span class="level-start"><span class="level-item">Compose</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/CS/"><span class="level-start"><span class="level-item">CS</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/CS/Data-Structure/"><span class="level-start"><span class="level-item">Data Structure</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Coroutine/"><span class="level-start"><span class="level-item">Coroutine</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/Coroutine/Flow/"><span class="level-start"><span class="level-item">Flow</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Design-Pattern/"><span class="level-start"><span class="level-item">Design Pattern</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/Design-Pattern/Behavioral/"><span class="level-start"><span class="level-item">Behavioral</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Design-Pattern/Creational/"><span class="level-start"><span class="level-item">Creational</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Kotlin/"><span class="level-start"><span class="level-item">Kotlin</span></span><span class="level-end"><span class="level-item tag">9</span></span></a><ul><li><a class="level is-mobile" href="/categories/Kotlin/Coroutine/"><span class="level-start"><span class="level-item">Coroutine</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/RxJava/"><span class="level-start"><span class="level-item">RxJava</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/RxJava/Transforming/"><span class="level-start"><span class="level-item">Transforming</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/android/"><span class="level-start"><span class="level-item">android</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-02-09T15:15:04.000Z">2023-02-10</time></p><p class="title"><a href="/2023/02/10/Android-TextView-%EC%9E%90%EB%8F%99-%ED%81%AC%EA%B8%B0-%EC%A1%B0%EC%A0%88/">Android - TextView 자동 크기 조절</a></p><p class="categories"><a href="/categories/Android/">Android</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-02-09T11:37:50.000Z">2023-02-09</time></p><p class="title"><a href="/2023/02/09/Android-is-translated-here-but-not-found-in-default-locale-%EC%9D%B4%EC%8A%88/">Android - is translated here but not found in default locale 이슈</a></p><p class="categories"><a href="/categories/Android/">Android</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-02-08T17:31:51.000Z">2023-02-09</time></p><p class="title"><a href="/2023/02/09/Kotlin-%EC%96%95%EC%9D%80-%EB%B3%B5%EC%82%AC-Shallow-Copy-%EC%99%80-%EA%B9%8A%EC%9D%80-%EB%B3%B5%EC%82%AC-Depp-Copy/">Kotlin 얕은 복사(Shallow Copy)와 깊은 복사(Depp Copy)</a></p><p class="categories"><a href="/categories/Kotlin/">Kotlin</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-02-04T16:46:13.000Z">2023-02-05</time></p><p class="title"><a href="/2023/02/05/%EB%8F%99%EC%8B%9C%EC%84%B1-Concurrency-%EA%B3%BC-%EB%B3%91%EB%A0%AC%EC%84%B1-Parallelism/">동시성(Concurrency)과 병렬성(Parallelism)</a></p><p class="categories"><a href="/categories/CS/">CS</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-02-02T13:01:26.000Z">2023-02-02</time></p><p class="title"><a href="/2023/02/02/Compose-hiltViewModel-%EA%B3%BC-viewModel-%EC%B0%A8%EC%9D%B4/">Compose - hiltViewModel()과 viewModel() 차이</a></p><p class="categories"><a href="/categories/Android/">Android</a> / <a href="/categories/Android/Compose/">Compose</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/02/"><span class="level-start"><span class="level-item">February 2023</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/01/"><span class="level-start"><span class="level-item">January 2023</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/12/"><span class="level-start"><span class="level-item">December 2022</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Android/"><span class="tag">Android</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CS/"><span class="tag">CS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Compose/"><span class="tag">Compose</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Coroutine/"><span class="tag">Coroutine</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Design-Pattern/"><span class="tag">Design Pattern</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Flow/"><span class="tag">Flow</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Kotlin/"><span class="tag">Kotlin</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RxJava/"><span class="tag">RxJava</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/categories/"><span class="tag">categories</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/java/"><span class="tag">java</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe for updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="케니스의 개발 블로그" height="28"></a><p class="is-size-7"><span>&copy; 2023 John Doe</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/KennethSS"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>